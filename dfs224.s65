; automatically converted from: dfs224.asm.txt
;Disassembly of Acorn DFS 2.24
;Greg Cook, 20 May 2024

;Source: http://wouter.bbcmicro.net/bbc/bestanden/roms-2009.01.28.zip
;Path: roms/kopie_van_disk/Acorn/DFS__2.24
;Code length: &38D7
;Acorn CRC: &E3E0
;PKZIP CRC: &5E5D82CA
;XFER CRC: &00B813AB
;Cksum: 3911480006

;This is a BeebAsm assembly source file.
;
;  https://github.com/stardot/beebasm
;
;Most symbols copied from matching code in Acorn DNFS 3.00,
;as landmarks.
;
;  https://github.com/stardot/AcornDNFSv300/
;
;Comments by Greg Cook and occasionally the Acornsoft team.
;Comments beginning with capital letters are entry points.
;Questions with double marks are open queries regarding the code.
;Questions with single marks are flowchart nodes.
;[D] marks differences from DNFS 3.00.  Work in progress - variable
;usage and purposes of routines are being characterised.
;Potential space savings can be found near comments containing
;"redundant", "unused", "can save", "unreachable code".

;Define any of the following symbols on the BeebAsm command line
;to select build options.
;For example:
;	beebasm -i dfs224.asm.txt -D _BUGFIX -D _TURBO
;
;Alternatively pass this file through the attached beebasmpp.pl
;to strip unused conditional assembly paths, for readability
;or to make the current build options permanent.

;Usability options
                .weak
BUGFIX=false                    ;Various bug fixes (see below)
FASTGB=false                    ;OSGBPB calls 1..4 transfer whole sectors directly from
                                ;or to user memory
                .endweak
                .weak
NMOS=false                      ;Code uses only NMOS 6502 instructions
TURBO=false                     ;Unrolled 'save AXY' routine for shorter debugging traces
SQUEEZE=false                   ;Unreachable code removed and some routines shortened
                .endweak

                .weak
dfs226=false
                .endweak

                .if dfs226
                ; Bodge/hack region
close=$ffff
delete=$ffff
build=$ffff
dump=$ffff
list_=$ffff
roms=$ffff
type_=$ffff
pmhelp=$ffff
                .endif
                
;Bugs fixed by _BUGFIX:
;- LIBFS executable searches terminate (2.25)
;- OSWORD $7F drive parameter bit 3 enables double density
;- OSWORD $7F command $63, Format track handles the sector
;  size code correctly and fetches sector IDs from the given
;  coprocessor address
;- OSFIND with A=$00, Y=0 writes output files' final extents
;  to disc ("CLOSE#0 / *CLOSE bug") (2.25)
;- OSARGS with A=$FF, Y>0 ensures a file more efficiently
;- OSARGS with A=$03, Y>0 sets the extent ensuring available
;- space, zeroes in extended data area and update on closure
;  (2.25)
;- *SHUT closes all files on Acorn DFS media (2.25)
;- Accessing a disc with a file open, changing the disc and
;  pressing BREAK raises a "Disc changed" error, even if the
;  drive activity light was still on at BREAK (2.28)
;- OSGBPB calls 1..4 clear the EOF warning flag on exit
;- OSFILE calls 8..11 are translated
;- *COPY copies zero-length files
;  (credit: dp11 on Stardot.org.uk/forums)
;- *COMPACT closes all files on entry
;- SRAM accepts lowercase bank letters w..z
;- *SRLOAD/*SRSAVE handle pseudo-addressed bank crossings
;  while loading/saving to tape
;- *SRREAD/*SRWRITE/OSWORD $42 handle data blocks crossing
;  64 KiB boundaries on the coprocessor.
;
;Some bugs are reported fixed in the marked version of
;Acorn DFS, according to:
;  D. Atherton, Master operating system, including BBC B+
;  and Master Compact: a dabhand guide (Manchester:
;  Dabs Press, 1988, 2nd ed.)


                .cpu "65c02"

dftbid=$01                      ;Tube claimant ID for Disc Filing System
srtbid=$08                      ;Tube claimant ID for SRAM

prenmi=$00A0                    ;previous owner of NMI area
L00A1=$00A1                     ;b7=Tube data transfer b6=writing to disc
                                ;b0=includes partial sector transfer
L00A2=$00A2                     ;b7=NMISR busy b6..b2=WD 1770 status
L00A3=$00A3                     ;Number of sectors per track $0A=SD $10=DD
L00A4=$00A4                     ;Track stepping rate in WD 1770 format 0=fast..3=slow
L00A5=$00A5                     ;Number of FDC commands to send/sectors to transfer
L00A6=$00A6                     ;LSB number of bytes to transfer
L00A7=$00A7                     ;Next FDC command or MSB number of bytes to transfer
linno=$00A8                     ;b7=catalogue entry is waiting to be created in *COPY, *COMPACT
                                ;Flag for printing newlines in *CAT [D]linno now one byte
L00A9=$00A9                     ;b7=Copying between different discs in same drive (swapping)
utemp=$00AA                     ;$00=Source disc in drive $80=Destination disc in drive
                                ;=0 listing current directory during *CAT >0 listing other dirs
                                ;File attribute mask in *ACCESS $00=unlocked $80=locked
ltemp=$00AB                     ;Offset of catalogue entry of found file in *CAT, *WIPE, *COPY
ptemp=$00AE                     ;Pointer to dialogue or error message source string
temp=$00B0                      ;Pointer to private page, extended vector table, OSFILE or
                                ;OSWORD $7F control block or local copy of sector ID table
                                ;Offset of insertion point while creating catalogue entry
                                ;Number of sectors per track while converting LBA to CHS (=10)
L00B0=$00B0                     ;8 bytes; copy of OSWORD $42 control block
                                ;Pointer to private page; action address in service call 4
L00B0a=$00B0                    ;Sideways RAM bank number during transfer
L00B1=$00B1                     ;2 bytes; source address during sideways RAM transfer
xtemp=$00B2                     ;2 bytes
itemp=$00B3                     ;overlaps xtemp
L00B3=$00B3                     ;2 bytes; destination address during sideways RAM transfer
atemp=$00B4                     ;2 bytes
ytemp=$00B5                     ;overlaps atemp
L00B5=$00B5                     ;2 bytes; number of bytes to transfer to/from sideways RAM
vtemp=$00B6                     ;4 bytes
L00B7=$00B7                     ;Sideways RAM bank number in OSWORD $42 control block
                                ;Flag/pointer array offset; 1=read from SWRAM 3=write to SWRAM
ztemp=$00B8                     ;2 bytes, overlaps vtemp
L00B8=$00B8                     ;2 bytes; pointer to private page in SRAM
etemp=$00B9                     ;overlaps ztemp
work=$00BA
L00BA=$00BA                     ;4 bytes; general workspace: pseudo RAM bank, OSHWM,
                                ;object length, buffer start address, buffer length,
                                ;offset of end of argument plus mode bits for *command;
                                ;pointer to paged RAM header, Tube data transfer address,
                                ;pointer to paged ROM type table
lodcat=work  +$0000             ;temp cat offset in OSFILE $FF
baselo=work  +$0001             ;LSB base LBA in *FREE / *MAP
intwa=work  +$0001              ;integer working area in LA960
wrkcat=work  +$0002             ;load/exec/length/start sector in catalogue format
lodlo=work  +$0002              ;LSB load address in OSFILE
basehi=work  +$0002             ;MSB base LBA in *FREE / *MAP
L00BC=$00BC                     ;4 bytes, overlaps L00BA; sideways RAM address, mode bits,
                                ;buffer length, pointer to sideways RAM address,
                                ;converted hexadecimal argument, computed transfer size,
                                ;pseudo RAM bank
lodhi=work  +$0003              ;3MSB load address in OSFILE
frecat=work  +$0003             ;temp cat offset in *FREE / *MAP
L00BD=$00BD                     ;2 bytes; temporary SWRAM address while incrementing
exelo=work  +$0004              ;LSB exec address in OSFILE
L00BE=$00BE                     ;2 bytes; size of current SWRAM transfer or mode bits
exehi=work  +$0005              ;3MSB exec address in OSFILE
comtxt=work  +$0005             ;offset of command table entry [D] was work+$02
freelo=work  +$0005             ;LSB free space in *FREE / *MAP
L00BF=$00BF                     ;temporary; byte written to SWRAM, error message offset,
                                ;copyright string offset, sideways memory type, saved
                                ;X register, sideways RAM bank number
strtlo=work  +$0006             ;LSB start address in OSFILE 0
lenlo=work  +$0006              ;LSB file length in OSFILE
freehi=work  +$0006             ;MSB free space in *FREE / *MAP
strthi=work  +$0007             ;3MSB start address in OSFILE 0
lenhi=work  +$0007              ;2MSB file length in OSFILE
headlo=work  +$0007             ;LSB headroom in *FREE / *MAP
bitcnt=work  +$0007             ;bit counter in LA960
endlo=work  +$0008              ;LSB end address in OSFILE 0
lbahi=work  +$0008              ;MSB LBA in OSFILE
headhi=work  +$0008             ;MSB headroom in *FREE / *MAP
endhi=work  +$0009              ;3MSB end address in OSFILE 0
lbalo=work  +$0009              ;LSB LBA in OSFILE
lenhl=work  +$000A              ;MSB file length in OSFILE
L00C4=work  +$000A              ;temp cat offset in *RENAME
                                ;REUSED $0B=current FSC call is FSC 11 (_BUGFIX)
todolo=work  +$000A             ;LSB no. sectors remaining to be copied
todohi=work  +$000B             ;MSB no. sectors remaining to be copied
wrknam=work  +$000B             ;current filename
srclo=work  +$000C              ;LSB LBA of next sector to copy from source
L00C6=work  +$000C              ;microcode in *FREE / *MAP
srchi=work  +$000D              ;MSB LBA of next sector to copy from source
userpt=work  +$000D             ;pointer to user's OSWORD control block
dstlo=work  +$000E              ;LSB LBA of next sector to copy to destination
dsthi=work  +$000F              ;MSB LBA of next sector to copy to destination
L00C9=work  +$000F              ;microcode in *FORM / *VERIFY
cpycat=work  +$0010             ;catalogue pointer in *COPY
L00CA=work  +$0010              ;command line offset in *FORM / *VERIFY
qualif=$00CC                    ;current directory
fdrive=$00CD                    ;current drive
track=$00CE                     ;current track pos. of current drive in OSWORD $7F
sector=$00CF                    ;current sector no. on current drive in OSWORD $7F

worda=$00EF                     ;reason code in A on entry to OSWORD
wordx=$00F0                     ;LSB control block address in X on entry to OSWORD
wordy=$00F1                     ;MSB control block address in Y on entry to OSWORD
linptr=$00F2                    ;2 bytes; pointer to character array in GSINIT/Svc $25
romid=$00F4                     ;slot number of ROM currently paged in
romptr=$00F6                    ;2 bytes; pointer to next byte of RFS stream
L00F6=$00F6                     ;romptr+$00 when used as a temp
L00F7=$00F7                     ;romptr+$01 when used as a temp
escflg=$00FF                    ;b7=0 normal, b7=1 ESCAPE pressed

stack=$0100                     ;hardwired 6502 stack page
errbuf=$0100                    ;error trampoline so a language ROM can print the message

bytev=$020A                     ;BYTEV vector, redirected by SRAM
filev=$0212                     ;FILEV, first FS vector claimed by DFS
fscv=$021E                      ;FSCV vector to control/shut down current FS

tubadr=$0406                    ;set up address for tube

intnmi=$0D00                    ;NMI service routine
ecowsp=$0D60                    ;Econet reserved area; end of NMI service routine
priptr=$0DF0                    ;table of private pages to each ROM

base=$C000                      ;start of HAZEL extended memory
dirlow=base  +$0000             ;first sector of volume catalogue
catlow=dirlow+$0008             ;first catalogue entry; filename
catdun=catlow+$0000             ;b7=catalogue entry listed
modify=catlow+$0007             ;directory letter; b7=file locked
dirhig=dirlow+$0100             ;second sector of catalogue
cycno=dirhig+$0004              ;BCD cycle number, incremented when updating catalogue
dirlen=dirhig+$0005             ;number of files in catalogue * 8; pointer to last entry
option=dirhig+$0006             ;when accessing option bits
cathig=dirhig+$0008             ;first catalogue entry; attributes

mainws=dirhig+$0100             ;when saved/restored in bulk
buffer=mainws+$0000             ;64 bytes; file spec passed to command
tmpcin=mainws+$0045             ;18 bytes; saved arg ptr, cat attributes and filename
tmpcat=tmpcin+$0002             ;load/exec/length/start sector of file being copied
namtra=tmpcin+$000B             ;filename and directory of file being copied
tmpnam=mainws+$0058             ;filename and directory portion of file spec to *COPY
dosram=mainws+$0060             ;copy of OSGBPB/OSFILE ctrl block; temp filename in *CAT
                .if FASTGB
acc=dosram+$000D                ;temporary OSGBPB call number
ltemp0=dosram+$000E             ;temporary count of bytes remaining to transfer
                .endif
ldlow=mainws+$0072              ;4 bytes; load address passed to OSFILE; Tube tx addr
hiwork=ldlow +$0002             ;8 bytes; high words of load/exec/start/end to OSFILE
exlow=hiwork+$0000              ;overlaps ldlow; exec address passed to OSFILE
strthl=hiwork+$0004             ;2MSB start addres in OSFILE 0
strthh=hiwork+$0005             ;MSB start address in OSFILE 0
endhl=hiwork+$0006              ;MSB file length in OSFILE
btemp=mainws+$007D              ;2 bytes; pointer to user's OSGBPB control block
ctemp=mainws+$007F              ;transfer direction 0=writing from mem 1=reading to mem
tumflg=mainws+$0081             ;$00=transferring to/from host $FF=txing to/from Tube
catdrv=mainws+$0082             ;drive no. of catalogue in dirlow/hi; $FF=cat invalid
olddrv=mainws+$0083             ;set during init1, otherwise unused
dufflg=mainws+$0086             ;$20=update EXT if changed $00=ensure buffers only
LC287=mainws+$0087              ;b7=drive 0, b6=drive 1 uncalibrated
LC288=mainws+$0088              ;track no. under heads on drive 0/2, 1/3
LC28A=mainws+$008A              ;disc operation modifier...
LC28B=mainws+$008B              ;bad tracks 1,2 on drive 0/1, 2/3
LC290=mainws+$0090              ;high OSWORD $7F control block
LC29D=mainws+$009D              ;retry counter in *FORM / *VERIFY
LC29E=mainws+$009E              ;retry counter in OSWORD $7F
LC29F=mainws+$009F              ;number of tracks to *FORMAT / *VERIFY

prsist=mainws+$00C0             ;start of persistent workspace saved to private page
dcbmap=mainws+$00C0             ;channel open flags
dcbbit=mainws+$00C1             ;channel open bit mask for current open file
dcby=mainws+$00C2               ;channel workspace pointer for current open file
seqwb=mainws+$00C3              ;Offset of catalogue entry of current open file
seqwc=mainws+$00C4              ;counter for copying catalogue entry while opening file
LC2C4=mainws+$00C4              ;LSB offset of current buffer from start of file in OSARGS 1,Y
seqwx=mainws+$00C5              ;temporary copy of X register during sequential file ops
monflg=mainws+$00C6             ;*OPT 1 monitor $00=verbose $FF=quiet
enaflg=mainws+$00C7             ;*ENABLE counter $01=*ENABLE just called $00=current cmd
                                ;enabled $FF=current command not enabled
defqua=mainws+$00C9             ;default (CSD) directory character
defdsk=mainws+$00CA             ;default (CSD) drive
libqua=mainws+$00CB             ;library directory character
libdsk=mainws+$00CC             ;library drive
wildch=mainws+$00CD             ;$23=wildchard chars allowed in filespec $FF=not allowed
dashop=mainws+$00CE             ;$2A=asterisks allowed in filespec $FF=not allowed
frpage=mainws+$00CF             ;MSB of OSHWM; first free page of user memory
frsize=mainws+$00D0             ;number of pages of user memory
fdriv=mainws+$00D1              ;source drive in *BACKUP, *COPY
tdriv=mainws+$00D2              ;destination drive in *BACKUP, *COPY
colds=mainws+$00D3              ;$FF=allow warm start $00=force cold start
memflg=$00D4                    ;$FF=we have shared workspace $00=don't have workspace
notube=mainws+$00D6             ;$00=Tube coprocessor present $FF=Tube absent (inverted MOS flag)
qtemp=mainws+$00D7              ;2 bytes; action address in OSGBPB
linadr=mainws+$00D9             ;2 bytes; offsets to cmd line tail/start or pointer to tail
fcbadr=mainws+$00DB             ;pointer to user's OSFILE control block
seqsem=mainws+$00DD             ;$00=*SPOOL/*EXEC critical, close files on error
LC2DE=mainws+$00DE              ;[0] flags; [0..3] b7=40 track drv
LC2E2=mainws+$00E2              ;trampoline to previous OSBYTE handler

sramws=$00EE                    ;rest of private page used by SRAM
srwork=sramws+$0000             ;copy of OSWORD $42/$43 control block
sramfh=sramws+$000C             ;sideways RAM image file handle
sramln=sramws+$000D             ;2 bytes; sideways RAM image file length
srpsmp=sramws+$000F             ;sideways RAM pseudo-addressing bitmap
sramon=sramws+$0011             ;SRAM initialised; $4E=sramfh valid, close on BRK


seqmap=mainws+$0100             ;workspaces for channels $11..$15
seqcat=seqmap+$0000             ;when accessing the catalogue entry
seqll=seqcat+$0009              ;LSB of file length in catalogue entry
seqlm=seqcat+$000B              ;2MSB of file length in catalogue entry
seqrdo=seqcat+$000C             ;seventh character of filename; b7=channel read-only
seqlh=seqcat+$000D              ;top bits exec/length/load/LBA in catalogue entry
seqlok=seqcat+$000E             ;directory character of filename; b7=file locked
seqloc=seqcat+$000F             ;LSB of starting LBA in catalogue entry
seqpl=seqmap+$0010              ;LSB of sequential pointer (PTR)
seqpm=seqmap+$0011              ;2MSB of sequential pointer
seqph=seqmap+$0012              ;MSB of sequential pointer
seqbuf=seqmap+$0013             ;page of memory containing open file's sector buffer
seqlla=seqmap+$0014             ;LSB of open file's extent (EXT)
seqlma=seqmap+$0015             ;2MSB of open file's extent
seqlha=seqmap+$0016             ;MSB of open file's extent
seqflg=seqmap+$0017             ;channel flags b7=buffer contains PTR b6=buffer changed
                                ;b5=EXT changed b4=EOF warning given b1..b0=drive number
seqem=seqmap+$0019              ;LSB of number of sectors allocated to file
seqeh=seqmap+$001A              ;MSB of number of sectors allocated to file
seqbit=seqmap+$001B             ;channel open bit mask corresponding to open file
seqdal=seqmap+$001C             ;LSB of starting LBA
seqdah=seqmap+$001D             ;MSB of starting LBA

slots=seqmap+$0100              ;channel sector buffers

latch=$FE24                     ;floppy drive interface control latch
fdc=$FE28                       ;base of floppy drive controller registers
fdccmd=fdc   +$0000             ;WD 1770 command register (write only)
fdcsta=fdc   +$0000             ;WD 1770 status register (read only)
fdctrk=fdc   +$0001             ;WD 1770 track register
fdcsec=fdc   +$0002             ;WD 1770 sector register
fdcdat=fdc   +$0003             ;WD 1770 data register
romsw=$FE30                     ;ROMSEL paged ROM selection latch

reg3=$FEE5                      ;Tube FIFO 3

gsinit=$FFC2                    ;Initialise read
gsread=$FFC5                    ;Read char
osrdsc=$FFB9                    ;Read screen or paged ROM
osfind=$FFCE                    ;Open file
osgbpb=$FFD1                    ;Get/put bytes to file
osbput=$FFD4                    ;Put bytes to file
osbget=$FFD7                    ;Get bytes from file
osargs=$FFDA                    ;Read/write file arguments
osfile=$FFDD                    ;Read/write whole file
osrdch=$FFE0                    ;Read char from kbd
osasci=$FFE3                    ;OSWRCH + CR]CRLF
oswrch=$FFEE                    ;Write char to screen
osbyte=$FFF4                    ;Misc OS calls
oscli=$FFF7                     ;Execute command line


*=$8000

lang:                           ;Language entry
                brk
                .word $0000

                                ;Service entry
                jmp LAB9F

                .char $82       ;rom type: service only
                .char copyr-lang ;copyright offset pointer
                .char $79       ;version No.
                .text "DFS",$00 ;title and terminator byte
                .if dfs226
                .text "2.26"
                .else
                .text "2.24"    ;version string
                .endif
copyr:
                .char $00       ;terminator byte
                .text "(C)1985 Acorn",$00 ;copyright string and terminator byte

osfscm:                         ;Issue Filing System Call
                jmp (fscv)

dskmsg:                         ;Raise "Disk " error
                jsr estrng
                .char $00
                .text "Disc "
                bcc gstrng

illmsg:                         ;Raise "Bad " error
                jsr estrng
                .char $00
                .text "Bad "
                bcc gstrng

estrng:                         ;Check critical flag and prefix error message
                lda seqsem      ;if flag=$00 (i.e. if *SPOOL/*EXEC critical)
                bne estrn1
                jsr hmtspe      ;then close *SPOOL/*EXEC files.
estrn1:
                lda #$FF
                sta catdrv      ;no catalogue in pages $0E..F
                sta seqsem      ;clear *SPOOL/*EXEC critical flag:
fstrng:                         ;Prefix error message immediate
                ldx #$02        ;error message being built from offset 2
                lda #$00
                sta errbuf+$00  ;instruction at $0100 = BRK:
gstrng:                         ;Append error message immediate
                sta itemp       ;save A on entry
                pla             ;pop caller's address into pointer
                sta ptemp+$00
                pla
                sta ptemp+$01
                lda itemp       ;restore A on entry
                ldy #$00        ;set Y=0 for indirect indexed load:
                jsr tmpinc      ;increment ptemp
                lda (ptemp),y   ;get character from after JSR
                sta errbuf+$01  ;$0101 = error number
                dex             ;decrement error message offset or POS:
estrn0:
                jsr tmpinc      ;increment ptemp
                inx             ;increment error message offset or POS
                lda (ptemp),y   ;get character from after JSR
                sta errbuf,x    ;store character at end of error message
                bmi vstrnr      ;if b7=1 then opcode terminator, execute it
                bne estrn0      ;else if not NUL then copy more characters
                jsr reltub      ;else raise error. ensure Tube is released
                jmp errbuf      ;jump to BRK to raise error

vstrng:                         ;Print string immediate (via PCHR)
                sta itemp       ;save A on entry
                pla             ;pop caller's address into pointer
                sta ptemp+$00
                pla
                sta ptemp+$01
                lda itemp       ;restore A on entry and save on stack
                pha
                tya             ;save Y
                pha
                ldy #$00        ;set Y=0 for indirect indexed load
vstrlp:
                jsr tmpinc      ;increment ptemp
                lda (ptemp),y   ;get character from after JSR
                bmi vstrnx      ;if b7=1 then opcode terminator, execute it
                jsr pchr        ;else print character
                jmp vstrlp      ;and loop

vstrnx:
                pla             ;restore AY
                tay
                pla
vstrnr:
                clc             ;jump to address of end of string with C=0
                jmp (ptemp)

dpdot:                          ;Print digit and dot
                jsr digout
pdot:                           ;Print a dot
                lda #$2E
pchr:                           ;Print character in A (OSASCI)
                jsr savita      ;save AXY
                pha             ;else save character
                lda #$EC        ;call OSBYTE $EC = read/write char dest status
                jsr readby
                txa             ;save current output stream setting
                pha
                ora #$10        ;b4=1 disable *SPOOL output
                jsr wriwde      ;call OSBYTE $03 = specify output stream in A
                pla             ;restore previous output stream setting
                tax
                pla             ;restore character
                jsr osasci      ;call OSASCI
                jmp wriwdx      ;call OSBYTE $03 = specify output stream

                .if SQUEEZE
                .else
                                ;unreachable code
                jsr L8426       ;[D]
                .endif
bytout:                         ;Print hex byte
                pha             ;save A
                jsr sfour       ;shift A right 4 places
                jsr digout      ;print top nibble of byte
                pla             ;restore bottom nibble:
digout:                         ;Print hex nibble
                jsr digut1      ;[D]convert hex nibble to ASCII
                bne pchr        ;print character (always)

digut1:                         ;Convert hex nibble to ASCII
                and #$0F        ;extract b3..0
                cmp #$0A        ;if in range 10..15
                bcc digot0
                adc #$06        ;then C=1; add 7 to put in range 17..22
digot0:
                adc #$30        ;c=0; add 48, result 48..57, 65..70
                rts             ;return ASCII "0".."9" or "A".."F"

shftbo:                         ;Copy address to (work,hiwork)+X
                jsr shfttw      ;copy low word to zero page
                dex             ;backtrack destination offset
                dex
                jsr shftt0      ;copy high word to workspace:
shftt0:                         ;copy byte of high word to workspace
                lda (temp),y
                sta hiwork-$02,x
                inx             ;increment source and destination offsets
                iny
                rts

shfttw:                         ;copy low word to zero page:
                jsr shfton
shfton:                         ;copy byte of low word to zero page
                lda (temp),y
                sta work,x
                inx             ;increment source and destination offsets
                iny
                rts

getnam:                         ;Set current file from file spec
                jsr setdef      ;set current drive and directory = default
                jmp getnm0      ;parse file spec

frmnam:                         ;Set current file from argument pointer
                jsr setdef      ;set current drive and directory = default:
frmnm1:                         ;Parse file spec from argument pointer
                lda work+$00    ;copy argument pointer to GSINIT pointer
                sta linptr+$00
                lda work+$01
                sta linptr+$01
                ldy #$00        ;set Y = 0 offset for GSINIT
                jsr setupr      ;call GSINIT with C=0:
getnm0:                         ;Parse file spec
                ldx #$20        ;directory defaults to " "
                jsr rdchr       ;call GSREAD
                bcs namerr      ;if argument empty then "Bad filename"
                sta buffer+$00  ;else save first character of filename
                cmp #$2E        ;if not "." then skip to dir/filename
                bne getnm1      ;else empty dir spec, set directory = " ":
getnm2:
                stx qualif      ;set as current directory
                beq getnm0      ;loop to parse file spec (always)

getnm1:
                cmp #$3A        ;else is first character ":"?
                bne getnm3      ;if not then skip to dir/filename
                jsr getdrv      ;[D]else a drive is specified, get drive spec
                jsr rdchr       ;a pathname must follow, so call GSREAD
                bcs namerr      ;if only a drive spec then "Bad filename"
                cmp #$2E        ;else next character must be "."
                beq getnm0      ;if so then parse pathname, else:
namerr:                         ;Raise "Bad filename" error.
                jsr illmsg
                .char $CC
                .text "name"
                .char $00

getnm3:
                tax             ;save first char in case it's a directory
                jsr rdchr       ;call GSREAD, get second filename character
                bcs getnm4      ;if absent then process one-character name
                cmp #$2E        ;else is the second character "."?
                beq getnm2      ;if so then set current directory from X
                ldx #$01        ;else offset = 1, second character of buffer:
getnm5:
                sta buffer,x    ;store character of filename
                inx             ;point X to next character of current filename
                jsr rdchr       ;call GSREAD, get next character of leaf name
                bcs getnm6      ;if no more then filename complete, return
                cpx #$07        ;else have seven characters been read already?
                bne getnm5      ;if not then loop
                beq namerr      ;else raise "Bad filename" error.

rdchr:                          ;Call GSREAD and validate filename character
                jsr gsread      ;call GSREAD
                php             ;save result
                and #$7F        ;clear bit 7
                cmp #$0D        ;if result = $0D
                beq rdchok      ;then accept "|M" and "|!|M" as an embedded CR
                cmp #$20        ;else if ASCII value less than " "
                bcc namerr      ;then raise "Bad filename" error
                cmp #$7F        ;else if ASCII value = DEL or higher
                beq namerr      ;then raise "Bad filename" error
rdchok:
                plp             ;else restore GSREAD result
                rts             ;and return character in A, new offset in Y

getnm4:                         ;Process one-character filename
                ldx #$01        ;offset = 1, second character of buffer:
getnm6:                         ;Clear rest of filename buffer
                lda #$20        ;put " " in A
getnm7:
                sta buffer,x    ;fill rest of buffer with spaces
                inx             ;increment buffer offset
                cpx #$40        ;have we reached end of buffer?
                bne getnm7      ;if not then loop
                ldx #$06        ;else offset = 6:
clrnm0:
                lda buffer,x    ;copy filename in buffer
                sta wrknam,x    ;to current filename
                dex             ;loop until 7 characters copied
                bpl clrnm0
                rts

prtnam:                         ;Print filename from catalogue
                jsr savita      ;save AXY
                lda modify,y    ;get directory character
                php             ;save N = lock attribute
                and #$7F        ;extract ASCII character
                bne ptnam2      ;if NUL then file is in CSD
                jsr pdspc       ;so print two spaces
                beq ptnam3      ;branch (always)

ptnam2:
                jsr pchr        ;else print directory character
                jsr pdot        ;print a dot
ptnam3:
                ldx #$06        ;repeat 7 times:
ptnam0:
                lda catlow,y    ;get character of leaf name
                and #$7F        ;mask bit 7
                jsr pchr        ;print character
                iny
                dex
                bpl ptnam0      ;and loop
                jsr pdspc       ;print two spaces
                lda #$20        ;a = space
                plp             ;restore lock attribute in N
                bpl ptnam1      ;if lock bit set
                lda #$4C        ;then A = capital L
ptnam1:
                jsr pchr        ;print attribute character
                ldy #$01        ;print a space and exit
yspace:
                jsr pspace      ;Print number of spaces in Y
                dey             ;print a space
                bne yspace      ;loop until Y = 0
                rts

isoexe:                         ;Extract b7,b6 of A
                lsr a
                lsr a
isolen:                         ;Extract b5,b4 of A
                lsr a
                lsr a
                lsr a
                lsr a
                and #$03
                rts

isolod:                         ;Extract bit 3 to bits 1 and 0
                and #$08        ;[D]new
                beq L81BD       ;if bit 3 clear then return 0
                lda #$03        ;else return 3: b1=1,b0=1
L81BD:
                rts

sfive:                          ;Shift A right 5 places
                lsr a
sfour:                          ;Shift A right 4 places
                lsr a
sthree:                         ;Shift A right 3 places
                lsr a           ;[D]new entry point
                lsr a
                lsr a
                rts

lfive:                          ;Shift A left 5 places
                asl a
lfour:                          ;Shift A left 4 places
                asl a
                asl a
                asl a
                asl a
                rts

atot:                           ;Prepare ordinary file transfer
                lda #$05        ;[D]new
                sta LC290+$05
                lda fdrive
                sta LC290+$00
                lda #$0A        ;[D]set 10 sectors per track
                sta temp
                lda wrkcat+$00  ;copy user data address to NMI area
                sta LC290+$01
                lda wrkcat+$01
                sta LC290+$02
                lda ldlow+$02
                sta LC290+$03
                lda ldlow+$03
                sta LC290+$04
                lda #$FF        ;set track number for transfer
                sta LC290+$07   ;decrement, to increment at start of loop
                lda wrkcat+$06  ;get top bits exec/length/load/start sector
                jsr isolen      ;extract b5,b4 of A
                sta LC290+$0A   ;?$A5 = b17..16 (MSB) of length
                lda wrkcat+$04  ;copy LSB length
                sta LC290+$0B
                lda wrkcat+$05  ;copy 2MSB length
                sta LC290+$09
                lda wrkcat+$06
                and #$03        ;x = b9..8 (MSB) of relative LBA
                tax
                lda wrkcat+$07  ;get LSB of relative LBA:
trsca:
                sec             ;set C=1 to subtract without borrow:
trscb:
                inc LC290+$07   ;increment track number
                sbc temp        ;subtract sectors-per-track from LBA
                bcs trscb       ;loop until LSB borrows in
                dex             ;then decrement MSB of relative LBA
                bpl trsca       ;loop until MSB borrows in/underflows
                adc temp        ;add sectors per track to negative remainder
                sta LC290+$08   ;set sector number.
loksuc:
                rts

getlok:                         ;Ensure file matching spec in catalogue
                jsr getnam      ;set current file from file spec
                bmi errlok      ;ensure matching file in catalogue

frmlok:                         ;Ensure file matching argument in catalogue
                jsr frmnam      ;set current file from argument pointer:
errlok:                         ;Ensure matching file in catalogue
                jsr lookup      ;search for file in catalogue
                bcs loksuc      ;if found then return, else:
nofil:                          ;Raise "Not found" error
                jsr fstrng
                .char $D6
                .text "Not found"
                .char $00

ex:                             ;FSC  9 = *EX
                .if !dfs226
                jsr stxylp      ;set GSINIT pointer to XY, set Y=0 [D]new
                .endif
                jsr setdef      ;set current drive and directory = default
                jsr setupr      ;call GSINIT with C=0
                beq L8246       ;if no argument then list default directory
                jsr readd0      ;else parse directory spec
L8246:
                lda #$2A        ;set filename="*"
                sta buffer+$00
                jsr getnm4      ;process one-character filename
                jsr setwld      ;allow wildcard characters in filename
                jsr errlok      ;ensure matching file in catalogue
                .if SQUEEZE
                bcs L8265       ;print *INFO lines for all matching files
                .else
                jmp L8265       ;print *INFO lines for all matching files
                                ;can save 1 byte (BCS/BRA L8265)
                .endif

info:                           ;FSC 10 = *INFO
                .if !dfs226
                jsr stxylp      ;allow wildcard characters in filename
                .endif
                jsr setwld
                jsr setupr      ;call GSINIT with C=0
                .if !dfs226
                beq L826E       ;if no argument then raise "Bad name" error
                .endif
                jsr getlok      ;else ensure file matching spec in catalogue
L8265:
                jsr prtinf      ;print *INFO line
                jsr next        ;find next matching file
                bcs L8265       ;loop until no more files match.
                rts

                .if !dfs226
L826E:
                jmp namerr      ;raise "Bad name" error
                .endif
                
L8271:                          ;Search for file with execute privilege
                jsr L93AD       ;ensure catalogue loaded with execute privilege
                lda #buffer-buffer ;compare with name in buffer
                beq L8296

lookw:                          ;Search for wrknam in catalogue
                ldx #$06        ;7 characters to copy:
lookw0:
                lda wrknam,x    ;copy current leafname to workspace
                sta tmpnam,x
                dex             ;loop until 7 characters copied
                bpl lookw0
                lda #$20        ;set eighth character to space
                sta tmpnam+$07  ;to serve as filename terminator
                lda #tmpnam-buffer ;compare with name in tmpnam
                bne lookux

next:                           ;Find next matching file
                ldx #buffer-buffer ;compare with name in buffer
                beq next0

lookup:                         ;Search for file in catalogue
                lda #buffer-buffer ;compare with name in buffer:
lookux:
                pha
                jsr L93B1       ;ensure current volume catalogue loaded
                pla
L8296:
                tax             ;set X = offset of comparand
                lda #(<catlow)-$08 ;start at first catalogue entry
                sta vtemp+$00
next0:
                ldy #$00        ;y=0 point to start of leafname
                lda #>catlow    ;[D]set MSB of pointer to first catalogue page
                sta vtemp+$01
                lda vtemp+$00   ;set A = catalogue pointer
                cmp dirlen      ;have we reached the end of the catalogue?
                bcs matchf      ;if so return C=0 file not found
                adc #$08        ;else add 8 to A
                sta vtemp+$00   ;store new catalogue pointer
                jsr matchs      ;compare leafname with one in catalogue
                bcc next0       ;if unequal then loop until file found or not
                lda qualif      ;else set A = current directory
                ldy #$07        ;y=7 point to directory character:
                jsr cpchar      ;compare with character in catalogue
                bne next0       ;if unequal then loop until file found or not
                ldy vtemp+$00   ;y=absolute offset of found file in workspace
                sec             ;return C=1 file found:
unstep:                         ;Subtract 8 from Y
                dey             ;returns offset from start of catalogue
                dey
                dey
                dey
                dey
                dey
                dey
                dey
                rts

matchs:                         ;Compare leafname with one in catalogue
                jsr savita      ;save AXY
match1:
                lda buffer,x    ;get character of pattern
                cmp dashop      ;if not "*" or wildcards are barred
                bne match4      ;then compare literals
                inx             ;else advance X past the *
match6:
                jsr matchs      ;if rest of pattern matches rest of filename
                bcs matchr      ;then return C=1 file found
                iny             ;else skip one char of filename, adding it to wc
                cpy #$07        ;if not at end of filename
                bcc match6      ;then loop to see if pattern matches here
mathmt:
                lda buffer,x    ;else globbed to end of filename
                cmp #$20        ;if pattern does not also end here
                bne matchf      ;then return C=0 no match
                rts             ;else return C=1 file found

match4:
                cpy #$07        ;comparing literals; if end of filename reached
                bcs mathmt      ;then check pattern ends here also
                jsr cpchar      ;else compare characters
                bne matchf      ;if unequal return C=0 no match
                inx             ;else consume pattern character
                iny             ;consume filename character
                bne match1      ;loop to compare rest of pattern (always)

matchf:                         ;match failed
                clc             ;return C=0 file not found
matchr:                         ;match succeeded (C=1)
                rts             ;return C=1 file found

cpchar:                         ;Compare characters
                cmp dashop      ;if equal to "*" and wildcards are allowed
                beq cpret       ;then return Z=1 characters match
                cmp wildch      ;else if equal to "#" and wildcards allowed
                beq cpret       ;then return Z=1 characters match
                jsr caps        ;else test is character in A is a letter
                eor (vtemp),y   ;compare pattern character with filename
                bcs cpchr0      ;if pattern character is a letter
                and #$5F        ;then ignore case differences
cpchr0:
                and #$7F        ;ignore bit 7, return Z=characters equal
cpret:
                rts

setcap:                         ;Uppercase letter in A
                php             ;preserve flags
                jsr caps        ;is character in A a letter?
                bcs scap0       ;if not then just clear bit 7
                and #$5F        ;else clear bits 5 and 7, convert to capitals
scap0:
                and #$7F        ;clear bit 7
                plp             ;restore flags
                rts             ;and exit

delfil:                         ;Delete catalogue entry
                jsr chkopl      ;ensure file not locked or open (mutex)
dellop:
                lda catlow+$08,y ;copy next file's entry over previous entry
                sta catlow,y    ;shifting entries up one place
                lda cathig+$08,y ;(copies title/boot/size if catalogue full)
                sta cathig,y
                iny             ;loop until current file count reached
                cpy dirlen      ;have we reached the end of the catalogue?
                bcc dellop
                tya             ;copy Y to A = pointer to last file; C=1
                sbc #$08        ;subtract 8, catalogue contains one file less
                sta dirlen      ;store new file count
                clc
infrts:
                rts

caps:                           ;Set C=0 iff character in A is a letter
                pha             ;preserve character
                and #$5F        ;clear bits 5 and 7, convert lowercase to upper
                cmp #$41        ;is character less than capital A?
                bcc caps0       ;if so then return C=1
                cmp #$5B        ;else is it more than capital Z?
                bcc caps1       ;if not then return C=0
caps0:
                sec             ;else return C=1, character is a letter
caps1:
                pla
                rts

inform:                         ;Print *INFO line if verbose
                bit monflg      ;test *OPT 1 setting
                bmi infrts      ;if b7=1 then *OPT 1,0 do not print, else:
prtinf:                         ;Print *INFO line
                jsr savita      ;save AXY
                jsr prtnam      ;print filename from catalogue
                tya             ;save catalogue pointer
                pha
                lda #<dosram    ;set up pointer to OSFILE block in workspace
                sta temp+$00
                lda #>dosram
                sta temp+$01
                jsr chukbk      ;return catalogue information to OSFILE block
                ldy #$02        ;y = $02 offset of load address in block
                jsr pspace      ;print a space
                jsr prtin0      ;print load address
                jsr prtin0      ;print execution address
                jsr prtin0      ;print file length
                pla             ;restore catalogue pointer
                tay
                lda cathig+$06,y ;get top bits exec/length/load/start sector
                and #$03        ;extract MSB start sector
                jsr digout      ;print hex nibble
                lda cathig+$07,y ;get LSB start sector
                jsr bytout      ;print hex byte
                jmp pcrlf       ;print newline

prtin0:                         ;Print 24-bit field at dosram+Y
                ldx #$03        ;3 bytes to print (1 to skip on exit):
prtin1:
                lda dosram+$02,y ;y points to LSB, get MSB
                jsr bytout      ;print hex byte
                dey             ;decrement offset
                dex             ;decrement counter
                bne prtin1      ;loop until 3 bytes printed
                jsr step7       ;add 7 to Y to point to LSB of next field
                jmp pspace      ;print a space and exit

                .if SQUEEZE
                .else
                                ;can save 3 bytes (join)
getdir:
                jsr savita      ;save AXY
                jmp L93C0       ;load volume catalogue
                .endif

chukbk:                         ;Return catalogue information to OSFILE block
                jsr savita      ;save AXY
                tya             ;save catalogue pointer on stack
                pha
                tax             ;and copy to X
                ldy #$12        ;clear bytes at offsets 2..17
                lda #$00
chukb7:
                dey             ;[D]opto
                sta (temp),y
                cpy #$02
                bne chukb7      ;offset 2 = LSB load address
chukb5:
                jsr chukb4      ;copy two bytes from catalogue to OSFILE block
                iny             ;skip high bytes of OSFILE field
                iny
                cpy #$0E        ;loop until 3 fields half-filled:
                bne chukb5      ;load address, execution address, file length
                pla             ;restore catalogue pointer
                tax
                lda modify,x    ;get directory character
                bpl chukb3      ;if b7=1 then file is locked
                lda #$08        ;so set attributes to LRW/RW (old style)
                sta (temp),y    ;no delete, owner read/write, public read/write
chukb3:
                lda cathig+$06,x ;get top bits exec/length/load/start sector
                ldy #$04        ;offset 4 = 2MSB load address
                jsr chukb1      ;expand bits 3,2 to top 16 bits of field
                ldy #$0C        ;offset 12 = 2MSB file length
                lsr a           ;chukb1 returned A = ..eelldd
                lsr a           ;shift A right twice to make A = ....eell
                pha             ;save exec address
                and #$03        ;extract bits 1,0 for length (don't expand)
                sta (temp),y    ;store in OSFILE block
                pla             ;restore exec address in bits 3,2
                ldy #$08        ;offset 8 = 2MSB execution address:
chukb1:
                lsr a           ;shift A right 2 places
                lsr a
                pha             ;save shifted value for return
                and #$03        ;extract bits 3,2 of A on entry
                cmp #$03        ;if either one is clear [D]opto
                bne L83D8       ;then save both as b1,0 of 2MSB
                lda #$FF        ;else set MSB and 2MSB = $FF.
                sta (temp),y
                iny
L83D8:
                sta (temp),y
                pla             ;discard byte on stack
                rts

chukb4:                         ;Copy two bytes from catalogue to OSFILE block
                jsr chukb6
chukb6:
                lda cathig,x
                sta (temp),y
                inx
                iny
                rts

tmpinc:                         ;Increment ptemp
                inc ptemp+$00
                bne tmpin0
                inc ptemp+$01
tmpin0:
                rts

                .if TURBO
savita:                         ;Save AXY
                pha             ;stack = Rl,Rh,a,cl,ch,sl,sh
                jsr savit0      ;return to caller,RTS jumps to next line
savrta:                         ;Restore AXY and return to superroutine
                pla             ;stack = y,x,a,sl,sh
                tay             ;cl,ch=caller return address
                pla             ;sl,sh=superroutine return address
                tax
                pla
                rts

savit0:                         ;Poke AXY into stack, return to caller
                pha
                pha
                pha
                txa
                pha
                tsx             ;stack = x,a,a,a,Rl,Rh,a,cl,ch,sl,sh
                lda stack+$09,x ;caller address high byte
                sta stack+$04,x
                lda stack+$08,x ;caller address low byte
                sta stack+$03,x
                lda stack+$07,x ;A on entry
                sta stack+$09,x
                tya             ;Y on entry
                sta stack+$07,x ;stack = x,a,cl,ch,Rl,Rh,y,cl,a,sl,sh
                pla             ;X on entry
                sta stack+$08,x ;stack = a,cl,ch,Rl,Rh,y,x,a,sl,sh
                tax
                pla             ;restore A on entry
                rts             ;return to caller

savit:                          ;Save XY
                pha             ;stack = Rl,Rh,a,cl,ch,sl,sh
                jsr savit0      ;return to caller,RTS jumps to next line
                tsx
                sta stack+$03,x ;replace A on entry with A from caller
                jmp savrta      ;restore AXY and return to superroutine

                .else
savita:                         ;Save AXY
                pha             ;stack = Rl,Rh,y,x,a,cl,ch,sl,sh
                txa             ;cl,ch=caller return address
                pha             ;sl,sh=superroutine return address
                tya
                pha
                lda #>(savrta-$01)
                pha
                lda #<(savrta-$01)
                pha
savit0:
                ldy #$05        ;duplicate y,x,a,cl,ch
savit1:
                tsx
                lda stack+$07,x
                pha
                dey
                bne savit1
                ldy #$0A        ;copy top 10 bytes down 2 places:
savit2:
                lda stack+$09,x ;overwrite bottom copy of cl,ch
                sta stack+$0B,x
                dex
                dey             ;stack now contains:
                bne savit2      ;y,x,y,x,a,cl,ch,Rl,Rh,y,x,a,sl,sh
                pla             ;discard y,x:
                pla
savrta:                         ;Restore AXY and return to superroutine
                pla
                tay
                pla
                tax
                pla
                rts

savit:                          ;Save XY
                pha             ;push y,x,a
                txa
                pha
                tya
                pha
                jsr savit0      ;restack then "call" rest of caller's routine!
                tsx             ;get stack pointer
                sta stack+$03,x ;store A on exit from caller in stack:
                jmp savrta      ;restore y,x on entry, a on exit.
                .endif

L8426:                          ;Convert binary value in A to BCD
                jsr savit       ;save XY
                tay             ;if A=0
                beq L8436       ;then nothing to do, return A=0
                clc             ;else clear carry for add
                sed             ;set BCD mode
                lda #$00        ;start with A=0:
L8430:
                adc #$01        ;add 1 in BCD mode (C=0)
                dey             ;loop until conversion complete
                bne L8430
                cld             ;then clear BCD mode and exit
L8436:
                rts

                .if SQUEEZE
                .else
                                ;unreachable code
                                ;was *DUMP character filtering
                and #$7F
                cmp #$7F
                beq L8441
                cmp #$20
                bcs L8443
L8441:
                lda #$2E
L8443:
                rts
                .endif

L8444:                          ;Convert ASCII digit to binary and validate
                sec             ;C=1 iff invalid
                sbc #$30
                .if SQUEEZE
                .else
                bcc L845F       ;(redundant)
                .endif
                cmp #$0A
                rts

                .if SQUEEZE
                .else
                                ;unreachable code
                                ;Convert ASCII hex digit to binary and validate
                jsr setcap      ;uppercase letter in A
                jsr L8444       ;convert ASCII digit to binary and validate
                bcc L845E       ;if in range 0..9 then return C=0
                sbc #$07        ;else subtract 7; now C=1, A >= 3
                bcc L845F       ;(redundant)
                cmp #$0A        ;if A < 10 then invalid digit
                bcc L845F       ;so return C=1
                cmp #$10        ;else C=0 if 10 <= A < 16, otherwise return C=1
L845E:
                rts

L845F:
                sec
                rts
                .endif

L8461:                          ;Input number up to 3 digits
                jsr setupr      ;call GSINIT with C=0
                sec
                beq L848D       ;if no argument then exit Z=1, C=1
                php
                lda #$00        ;else set total = 0
                sta etemp
                beq L8482       ;and branch into loop (always)

L846E:
                jsr L8444       ;convert ASCII digit to binary and validate
                bcs L848C       ;if digit invalid return Z=0, C=1
                sta ztemp       ;else store new unit
                .if SQUEEZE
                asl etemp
                lda etemp
                .else
                lda etemp       ;double total
                asl a           ;(can save 1 byte: ASL etemp)
                sta etemp
                .endif
                asl a           ;multiply by four: A = 8 * total
                asl a
                adc etemp       ;add 2 * total
                adc ztemp       ;add unit: A = 10 * total + unit
                sta etemp       ;store new total:
L8482:
                jsr gsread      ;call GSREAD, get next character
                bcc L846E       ;if character present then convert it
                lda etemp       ;else put total in A
                plp             ;restore flags from GSINIT: Z=0
                clc             ;return Z=0, C=0, number valid
                rts

L848C:
                plp
L848D:
                rts

wdcat:                          ;FSC  5 = *CAT
                jsr stxylp      ;set GSINIT pointer to XY, set Y=0
                jsr readrv      ;[D]select specified or default drive
                jsr L93C0       ;load catalogue
                ldy #$FF
                sty linno       ;print a newline before first entry
                iny
                sty utemp       ;CSD printed first, directory char = NUL
cat8:
                lda dirlow,y    ;y=0; if Y=0..7 get char from sector 0
                cpy #$08        ;if Y=8..11
                bcc cat9
                lda dirhig-$08,y ;then get character of title from sector 1
cat9:
                jsr pchr        ;print character in A (OSASCI)
                iny             ;loop until 12 characters of title printed
                cpy #$0C
                bne cat8
                jsr vstrng      ;print " ("
                .text " ("
                lda cycno       ;get BCD catalogue cycle number
                jsr bytout      ;print hex byte
                jsr vstrng      ;print ") FM" +newline +"Drive "
                .text ") FM"
                .char $0D
                .text "Drive "
                lda fdrive
                jsr digout
                ldy #$0D
                jsr yspace      ;print number of spaces in Y
                jsr vstrng      ;print "Option "
                .text "Option "
                lda option      ;get boot option/top bits volume size
                jsr sfour       ;shift A right 4 places
                pha             ;a=0..3; save for printing descriptor
                jsr digout      ;print hex nibble
                jsr vstrng      ;print " ("
                .text " ("
                ldy #$03        ;4 characters to print
                pla
                asl a           ;multiply boot option by 4
                asl a
                tax             ;transfer to X for use as offset
cat5:
                lda opttab,x    ;get character of boot option descriptor
                jsr pchr        ;print character in A (OSASCI)
                inx             ;increment offset
                dey             ;decrement count
                bpl cat5        ;loop until 4 characters printed
                jsr vstrng      ;print ")" + newline + "Dir. :"
                .text ")"
                .char $0D
                .text "Dir. :"
                lda defdsk      ;get default drive
                jsr dpdot       ;print digit and dot
                lda defqua      ;get default directory
                jsr pchr        ;print character in A (OSASCI)
                ldy #$0B
                jsr yspace      ;print number of spaces in Y
                jsr vstrng      ;print "Lib. :"
                .text "Lib. :"
                lda libdsk      ;get library drive
                jsr dpdot       ;print digit and dot
                lda libqua      ;get library directory
                jsr pchr        ;print character in A (OSASCI)
                jsr pcrlf       ;print newline
                ldy #$00
cat0:
                cpy dirlen      ;have we reached the end of the catalogue?
                bcs catscn      ;if so then start sorting entries
                lda modify,y    ;else get directory character of cat entry
                eor defqua      ;compare with default (CSD) directory
                and #$5F        ;mask off lock bit, make caseless
                bne cat1        ;if directories differ skip to next entry
                lda modify,y    ;else set directory character to NUL
                and #$80        ;and preserve lock bit
                sta modify,y
cat1:
                jsr step        ;add 8 to Y
                bcc cat0        ;and loop (always)

catscn:
                ldy #$00        ;y=$00, start at first file entry
                jsr findir      ;find unlisted catalogue entry
                bcc newbst      ;if entries remaining then print them
                lda #$FF        ;else finish catalogue
                sta catdrv      ;forget catalogue in workspace
                jmp pcrlf       ;print newline

nxtcat:                         ;Find next unlisted catalogue entry
                jsr step        ;add 8 to Y
findir:                         ;Find unlisted catalogue entry
                cpy dirlen      ;if catalogue pointer beyond last file
                bcs findx       ;then return C=1
                lda catdun,y    ;else test first character of leaf name
                bmi nxtcat      ;if b7=1 then already listed, skip
findx:
                rts             ;else return C=0, catalogue pointer in Y

newbst:
                sty ltemp       ;save catalogue pointer
                ldx #$00        ;set filename offset = 0
catlop:
                lda catlow,y    ;copy name and directory of first entry
                jsr setcap      ;with b7 clear and capitalised
                sta dosram,x    ;to workspace
                iny
                inx
                cpx #$08        ;loop until 8 characters copied
                bne catlop
cattry:
                jsr findir      ;find unlisted catalogue entry
                bcs scand       ;if none remaining then print lowest entry
                sec             ;else set C=1 for subtraction
                ldx #$06        ;start at 6th character (LSB) of leaf name:
catsbc:
                lda catlow+$06,y ;get character of entry
                jsr setcap      ;clear bit 7, make uppercase
                sbc dosram,x    ;subtract character of workspace
                dey             ;loop until 7 characters compared
                dex
                bpl catsbc
                jsr step7       ;add 7 to Y
                lda modify,y    ;get directory character (MSB) of entry
                jsr setcap      ;mask off lock bit, make uppercase
                sbc dosram+$07  ;subtract directory character in workspace
                bcc newbst      ;if entry < wksp then copy entry to wksp
                jsr step        ;else add 8 to Y
                bcs cattry      ;and loop (always)

scand:
                ldy ltemp       ;get catalogue pointer
                lda catdun,y    ;set b7 in first character of leaf name
                ora #$80        ;marking entry as listed
                sta catdun,y
                lda dosram+$07  ;get directory character from workspace
                cmp utemp       ;compare with last one printed
                beq sameq       ;if same then add entry to group
                ldx utemp       ;else test previous directory
                sta utemp       ;set previous directory = current directory
                bne sameq       ;if prev=NUL we go from CSD to other dirs
                jsr pcrlf       ;so print double newline:
cat3:
                jsr pcrlf       ;print newline
                ldy #$FF        ;set Y = $FF going to 0, start of line
                bne firstc      ;branch (always)

sameq:
                ldy linno       ;have we printed two entries on this line?
                bne cat3        ;if so then print newline and reset counter
                ldy #$05        ;else tab to next field. Y = 5 spaces
                jsr yspace      ;print number of spaces in Y, set index = 1:
firstc:
                iny
                sty linno       ;y = index of next entry on this line
                ldy ltemp       ;get catalogue pointer
                jsr pdspc       ;print two spaces
                jsr prtnam      ;print filename from catalogue
                jmp catscn      ;loop until all files listed

opttab:                         ;Table of boot option descriptors 0..3
                .text "off",$00
                .text "LOAD"
                .text "RUN",$00
                .text "EXEC"

dskadr:                         ;Test if new file will fit after current file
                lda cathig+$06,y ;get top bits exec/length/load/start sector
                jsr isolen      ;extract b5,b4 of A = MSB length
                sta lbahi       ;save length in zero page (big-endian)
                .if SQUEEZE
                lda cathig+$04,y ;setting C=1 if file includes partial sector
                cmp #$01
                .else
                clc             ;can save 1 byte (CMP #$01)
                lda #$FF        ;subtract 1 from LSB length
                adc cathig+$04,y ;setting C=1 if file includes partial sector
                .endif
                lda cathig+$07,y ;add LSB start LBA + 2MSB length + C
                adc cathig+$05,y ;=LSB LBA after last sector of file
                sta lbalo       ;save LBA in zero page (big-endian)
                lda cathig+$06,y ;get top bits exec/length/load/start sector
                and #$03        ;extract MSB start LBA
                adc lbahi       ;add MSB start LBA + MSB length + C
                sta lbahi       ;=MSB LBA after last sector of file:
dskspc:                         ;Test if new file will fit at current LBA
                sec
                lda cathig-$01,y ;subtract LSBs LBA of file - current LBA
                sbc lbalo
                pha             ;=LSB no. free sectors after file
                lda cathig-$02,y ;get top bits exec/length/load/start sector
                and #$03        ;extract MSB start LBA
                sbc lbahi       ;subtract MSB current LBA
                tax             ;=MSB no. free sectors after file
                lda #$00        ;compare no. free sectors - file size in sectors
                cmp lenlo       ;c=0 iff file includes a partial sector
                pla             ;compare 2MSBs
                sbc lenhi
                txa             ;compare MSBs
                sbc lenhl       ;return C=1 file will fit, C=0 file won't fit.
return:
                rts

comtab:                         ;DFS command table
                .text "ACCESS"  ;*ACCESS                        $89AC
                .char >(access-$01),<(access-$01)
                .char $32       ;syntax $2,$3: <afsp> (L)
                .text "BACKUP"  ;*BACKUP                        $A436
                .char >(cpydsk-$01),<(cpydsk-$01)
                .char $04       ;syntax $4: <source> <dest.>
                .if dfs226
                .text "CLOSE"   ;*CLOSE
                .char >(close-$01),<(close-$01)
                .char $00
                .endif
                .text "COMPACT" ;*COMPACT                       $A263
                .char >(compct-$01),<(compct-$01)
                .char $07       ;syntax $7: (<drive>)
                .text "COPY"    ;*COPY                          $A482
                .char >(cpyfil-$01),<(cpyfil-$01)
                .char $24       ;syntax $4,$2: <source> <dest.> <afsp>
                .if dfs226
                .text "DELETE"
                .char >(delete-$01),<(delete-$01)
                .char $01
                .endif
                .text "DESTROY" ;*DESTROY                       $8756
                .char >(destry-$01),<(destry-$01)
                .char $02       ;syntax $2: <afsp>
                .text "DIR"     ;*DIR                           $8905
                .char >(set   -$01),<(set   -$01)
                .char $06       ;syntax $6: (<dir>)
                .text "DRIVE"   ;*DRIVE                         $87B0
                .char >(drive -$01),<(drive -$01)
                .char $09       ;syntax $9: (<drive>) (40)(80)
                .text "ENABLE"  ;*ENABLE                        $8B0D
                .char >(enable-$01),<(enable-$01)
                .char $00       ;syntax $0: no arguments
                .if dfs226
                .text "EX"
                .char >(ex-$01),<(ex-$01)
                .char $06
                .endif
                .text "FORM"    ;*FORM                          $A5DE
                .char >(form  -$01),<(form  -$01)
                .char $BA       ;syntax $A,$B: 40/80 (<drive>)...
                .text "FREE"    ;*FREE                          $A812
                .char >(free  -$01),<(free  -$01)
                .char $07       ;syntax $7: (<drive>)
                .if dfs226
                .text "INFO"
                .char >(info-$01),<(info-$01)
                .char $02
                .endif
                .text "LIB"     ;*LIB                           $8909
                .char >(slib  -$01),<(slib  -$01)
                .char $06       ;syntax $6: (<dir>)
                .text "MAP"     ;*MAP                           $A815
                .char >(map   -$01),<(map   -$01)
                .char $07       ;syntax $7: (<drive>)
                .text "RENAME"  ;*RENAME                        $8B72
                .char >(rename-$01),<(rename-$01)
                .char $05       ;syntax $5: <old fsp> <new fsp>
                .text "TITLE"   ;*TITLE                         $897D
                .char >(title -$01),<(title -$01)
                .char $08       ;syntax $8: <title>
                .text "VERIFY"  ;*VERIFY                        $A5DA
                .char >(verify-$01),<(verify-$01)
                .char $0B       ;syntax $B: (<drive>)...
                .text "WIPE"    ;*WIPE                          $8712
                .char >(wipe  -$01),<(wipe  -$01)
                .char $02       ;syntax $2: <afsp>
                                ;unrecognised command, *RUN it  $8835
                .char >(defcom-$01),<(defcom-$01)

initbl:                         ;Utility command table
                .if dfs226
                .text "BUILD"
                .char >(build-$01),<(build-$01)
                .char $01
                .endif
                .text "DISC"    ;*DISC                          $9B6B
                .char >(init  -$01),<(init  -$01)
                .char $00       ;syntax $0: no arguments
                .if dfs226
                .text "DUMP"
                .char >(dump-$01),<(dump-$01)
                .char $01
                .endif
                .if dfs226
                .text "LIST"
                .char >(list_-$01),<(list_-$01)
                .char $01
                .endif
                .if dfs226
                .text "ROMS"
                .char >(roms-$01),<(roms-$01)
                .char $01
                .endif
                .if dfs226
                .text "TYPE"
                .char >(type_-$01),<(type_-$01)
                .char $01
                .endif
                .text "DISK"    ;*DISK                          $9B6B
                .char >(init  -$01),<(init  -$01)
                .char $00       ;syntax $0: no arguments
                                ;unrecognised utility, return   $8626
                .char >(return-$01),<(return-$01)

hlptab:                         ;*HELP keyword table
                .text "DFS"     ;*HELP DFS                      $A125
                .char >(help  -$01),<(help  -$01)
                .char $00       ;syntax $0: no arguments
                                ;unrecognised keyword, skip     $A15D
                .if dfs226
                .text "UTILS"
                .char >(pmhelp-$01),<(pmhelp-$01)
                .char $00
                .endif
                .char >(nohelp-$01),<(nohelp-$01)

wname:                          ;FSC  3 = unrecognised *command
                jsr stxylp      ;set GSINIT pointer to XY, set Y=0
                ldx #<(comtab-comtab-$03) ;command table offset = $FD going to 0:
wname0:
                tya             ;save string offset
                pha
thunk:
                inx             ;skip action address, 2 bytes
                inx
                pla             ;restore offset of start of command line
                pha
                tay
                jsr setupr      ;call GSINIT with C=0
                inx             ;skip syntax byte
                lda comtab,x    ;fetch first byte
                bmi finish      ;if terminator,empty keyword matches anything
                dex             ;else decrement X and Y to stay in place:
                dey
                stx comtxt
firch:
                inx             ;advance command line and table offsets
                iny
                lda comtab,x    ;get byte from table
                bmi chklst      ;if terminator, check command also terminates
                eor (linptr),y  ;else compare with character of command
                and #$5F        ;make comparison case-insensitive
                beq firch       ;if equal then compare next characters
                dex
minus:
                inx             ;scan keyword in table
                lda comtab,x
                bpl minus       ;loop until terminator reached
                lda (linptr),y  ;get mismatching character of command
                cmp #$2E        ;is it a dot? abbreviation if so, else mismatch
                bne thunk       ;if mismatch then skip syntax, scan next kywd
                iny             ;else advance command line offset past the dot:
                bcs finish      ;accept abbreviated command (always)

chklst:
                lda (linptr),y  ;get character of command
                jsr caps        ;set C=0 iff character in A is a letter
                bcc thunk       ;if so then command longer than keyword, no match
finish:                         ;Accept command
                pla             ;discard offset to start of command
                lda comtab,x    ;get action address high byte
                pha             ;store high byte of vector
                lda comtab+$01,x ;get action address low byte
                pha             ;store low byte of vector
                rts             ;execute command.

stxylp:                         ;Set GSINIT pointer to XY, set Y=0
                stx linptr+$00
                sty linptr+$01
                ldy #$00
                rts

setupr:                         ;Call GSINIT with C=0
                clc             ;c=0 space or CR terminates unquoted strings
                jmp gsinit      ;jump to GSINIT

wipe:                           ;*WIPE
                jsr setwld      ;allow wildcard characters in filename
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr getlok      ;ensure file matching spec in catalogue
qdel0:
                lda modify,y    ;test lock bit
                bmi qdel4       ;if b7=1 then deletion not allowed, skip
                jsr prtnam      ;else print filename from catalogue
                jsr LA403       ;print " : " and ask user yes or no
                bne qdel2       ;if user replies no then find next match
                ldx vtemp       ;[D] hold catalogue pointer; what clobbers??
                jsr chksam      ;else ensure disc not changed
                stx vtemp       ;[D] restore catalogue pointer to zero page
                jsr deldec      ;delete catalogue entry
                sty ltemp       ;[D] stash updated catalogue pointer elsewhere
                jsr dirout      ;write volume catalogue; does it wipe pointer??
                lda ltemp       ;[D] put catalogue pointer back in workspace
                sta vtemp
qdel2:
                jsr pcrlf       ;print newline
qdel4:
                jsr next        ;find next matching file
                bcs qdel0       ;if found then wipe the file
                rts             ;else exit

                .if SQUEEZE
                .else
                                ;unreachable code
                                ;was *DELETE
                jsr clrwld      ;disallow wildcard characters in filename
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr getlok      ;ensure file matching spec in catalogue
                jsr inform      ;print *INFO line if verbose
                jsr delfil      ;delete catalogue entry
                jmp dirout      ;write volume catalogue
                .endif

destry:                         ;*DESTROY
                jsr chkena      ;ensure *ENABLE active
                jsr setwld      ;allow wildcard characters in filename
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr getlok      ;ensure file matching spec in catalogue
destr1:
                lda modify,y    ;test lock bit
                bmi destr5      ;if b7=1 then deletion not allowed, skip
                jsr prtnam      ;else print filename from catalogue
                jsr pcrlf       ;print newline
destr5:
                jsr next        ;find next matching file
                bcs destr1      ;loop until all unlocked files listed
                jsr sure        ;print "Go?" and ask user yes or no
                beq destr2      ;if user replies yes then destroy files
                jmp pcrlf       ;else print newline and exit

destr2:
                jsr chksam      ;ensure disc not changed
                jsr lookup      ;search for file in catalogue
destr3:
                lda modify,y    ;test lock bit
                bmi destr4      ;if b7=1 then deletion not allowed, skip
                jsr deldec      ;else delete file and decrement catalogue pointer
destr4:
                jsr next        ;find next matching file
                bcs destr3      ;loop until all unlocked files deleted
                jsr dirout      ;write volume catalogue
                jsr vstrng      ;print "Deleted" and exit
                .char $0D
                .text "Deleted"
                .char $0D
step:                           ;Add 8 to Y
                iny
step7:                          ;Add 7 to Y
                iny
                iny
                iny
                iny
                iny
                iny
                iny
                rts

deldec:                         ;Delete file and decrement catalogue pointer
                jsr delfil      ;delete file
                ldy vtemp       ;put catalogue pointer in Y
                jsr unstep      ;subtract 8 from Y
                sty vtemp       ;save new catalogue pointer
                rts

drive:                          ;*DRIVE
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr getdrv      ;select specified drive
                sta defdsk      ;set default drive = current drive
                jsr L8461       ;input number up to 3 digits
                beq L87D7       ;if no number given then preserve 40/80 setting
                cmp #$28        ;else does number = 40?
                beq L87CA       ;if so then C=1, set drive to 40 tracks
                cmp #$50        ;else does number = 80?
                clc
                beq L87CA       ;if so then C=0, set drive to 80 tracks
                jmp synerr      ;else raise "Syntax: " error.

L87CA:                          ;Set default drive to 40/80 tracks
                php             ;save C=1 40 track drive, C=0 80tracks [D]new
                ldx defdsk      ;get default drive
                lda LC2DE,x     ;get flags for default drive
                rol a           ;shift bit 7 into carry flag
                plp             ;restore state of carry flag on entry
                ror a           ;move carry flag into b7, preserve b6..0
                sta LC2DE,x     ;save updated drive flags
L87D7:
                rts

dodriv:                         ;Select drive in A
                and #$03        ;[D]no disc operation
                sta fdrive      ;mask drive number 0..3, set current drive
                rts

loader:                         ;OSFILE $FF = load file
                jsr frmlok      ;ensure file matching argument in catalogue
                jsr tryfl0      ;set up pointer to user's OSFILE block
                jsr chukbk      ;return catalogue information to OSFILE block
                lda #$80
loadt:                          ;Load file into memory
                sta LC290+$06   ;[D] store command in high OSWORD $7F control block
                sty lodcat      ;save catalogue offset of found file
                ldx #$00
                lda exelo       ;test offset 6, LSB exec from OSFILE block
                bne reloc       ;if non-zero, use load address in catalogue
                iny             ;else skip first two bytes of catalogue entry
                iny
                ldx #$02        ;skip over user-supplied load address in zp
                bne loadt0      ;branch (always)

reloc:
                lda cathig+$06,y ;get top bits exec/length/load/start sector
                sta lbahi
                jsr decodl      ;expand 18-bit load address to 32-bit
loadt0:
                lda cathig,y    ;copy load/exec/length/start from catalogue
                sta wrkcat,x    ;into low words of OSFILE block
                iny             ;(our copy, gave user theirs at loader+$06)
                inx
                cpx #$08        ;loop until 8 or 6 bytes copied, 0..7/2..7
                bne loadt0
                jsr decode      ;expand 18-bit exec address to 32-bit
                ldy lodcat      ;restore catalogue offset of found file
                jsr inform      ;print *INFO line if verbose
                jmp blkxx       ;read ordinary file L5 and exit
                                ;can save 1 byte: fall through, L8826 does BNE/BRA

blkrd:                          ;Read ordinary file L5
                lda #$80
                bne L8826

saver:                          ;OSFILE   0 = save file
                jsr dirdo       ;create file from OSFILE block
                jsr tryfl0      ;set up pointer to user's OSFILE block
                jsr chukbk      ;return catalogue information to OSFILE block
blkwr:                          ;Write ordinary file L5
                lda #$A0
L8826:
                sta LC290+$06   ;store command in high OSWORD $7F control block:
blkxx:                          ;Transfer ordinary file L5
                jsr atot        ;prepare ordinary file transfer
                jsr L93F9       ;transfer data and report errors L4
                lda #$01        ;return A=1, file found
                                ;(appears in A on exit from OSFILE 0/$FF
                                ;but these calls define no return value)
                rts

wnota:                          ;FSC  2/4/11 = */, *RUN, *RUN from library
                jsr stxylp      ;set GSINIT pointer to XY, set Y=0
                .if BUGFIX
                beq defcon      ;always branch

nobin:
                jmp LB4AD       ;raise "Bad command" error (NB: in SRAM)
                .endif

defcom:                         ;FSC  3 with *command not in table
                .if BUGFIX
                asl a           ;ensure A is even:
defcon:
                sta L00C4       ;save call number (<> $0B from FSC 3)
                .endif
                jsr supld       ;copy argument ptr and load to cat address
                sty linadr+$01  ;store offset of start of command line
                jsr frmnam      ;set current file from argument pointer
                sty linadr+$00  ;store offset of command line tail
                jsr L8271       ;search for file in catalogue
                bcs defsuc      ;if found then execute command binary
                ldy linadr+$01  ;else restore offset of start of command line
                lda libqua      ;get library directory
                sta qualif      ;set as current directory
                lda libdsk      ;get library drive
                jsr dodriv      ;select drive in A
                jsr frmnm1      ;parse file spec from argument pointer
                jsr L8271       ;search for file in catalogue
                bcs defsuc      ;if found then execute it
                lda linptr+$00  ;[D]else get LSB of GSINIT pointer
                adc linadr+$01  ;add offset of start of command line
                tax             ;hold in X
                ldy linptr+$01  ;put MSB of GSINIT pointer in Y
                bcc L8867       ;carry out to MSB
                iny
L8867:
                lda #$0B        ;[D]pass to library FS
                .if BUGFIX
                cmp L00C4       ;if already serving FSC 11
                beq nobin       ;then raise "Bad command" error
                .endif
                jmp osfscm      ;[BUG]no infinite loop check like ADFS

defsuc:                         ;Execute command binary
                lda cathig+$06,y ;[D]test exec address
                jsr isoexe
                cmp #$03        ;if b17 or b16 clear
                bne L88BA       ;then run as executable
                lda cathig+$02,y ;else both set. AND low bytes of exec address
                and cathig+$03,y
                cmp #$FF        ;if exec address <> $FFFFFFFF
                bne L88BA       ;then run as executable
                ldx #$06        ;else 7 characters to move:
L8882:
                lda buffer,x    ;shift filename down 7 characters
                sta buffer+$07,x
                dex
                bpl L8882
                lda #$0D        ;add CR command line terminator
                sta buffer+$0E
                lda #$45        ;prepend "E.:<drv>.<dir>."
                sta buffer+$00
                .if SQUEEZE
                .else
                lda #$2E
                sta buffer+$01
                .endif
                lda #$3A
                sta buffer+$02
                lda fdrive
                ora #$30
                sta buffer+$03
                lda #$2E        ;can save 2 bytes here
                .if SQUEEZE
                sta buffer+$01
                .endif
                sta buffer+$04
                sta buffer+$06
                lda qualif
                sta buffer+$05
                ldx #<buffer    ;*EXEC the file.
                ldy #>buffer
                jmp oscli

L88BA:
                lda #$81        ;$81 = read sector + execute privilege
                jsr loadt       ;load file into memory
                clc
                lda linadr+$00  ;get offset of command line tail
                tay             ;and pass to command in Y (if on host)
                adc linptr+$00  ;add it to GSINIT pointer in $F2,3
                sta linadr+$00  ;giving command line tail pointer
                lda linptr+$01  ;save it in linptr for OSARGS 1 (redundant)
                adc #$00
                sta linadr+$01
                lda exlow+$02   ;and high bytes of address
                and exlow+$03   ;a=$FF if address is in the host
                ora notube      ;a=$FF if Tube absent (inverted MOS flag)
                cmp #$FF        ;if host address or Tube absent
                beq runho       ;then jump indirect
                lda exelo       ;else copy low word of exec address
                sta exlow+$00   ;over high word of load addr in OSFILE block
                lda exehi
                sta exlow+$01
                jsr clatub      ;claim Tube
                ldx #<exlow     ;point XY to 32-bit execution address
                ldy #>exlow
                lda #$04        ;tube service call $04 = *Go
                jmp tubadr      ;jump into Tube service

runho:                          ;Execute command on host
                lda #$01        ;enter with A=$01, entering executable??
                jmp (exelo)     ;jump to execution address

supld:                          ;Copy argument ptr and load to cat address
                lda #$FF        ;lsb exec address in our OSFILE block = $FF:
                sta exelo       ;load executable to load address in catalogue
                lda linptr+$00  ;copy GSINIT string pointer to zero page
                sta work+$00    ;= command line pointer
                lda linptr+$01
                sta work+$01
                rts

set:                            ;*DIR
                ldx #defqua-defqua ;point X to default directory/drive
                beq slib1       ;branch (always)

slib:                           ;*LIB
                ldx #libqua-defqua ;point X to library directory/drive
slib1:
                jsr readdf      ;set current directory
                sta defdsk,x    ;set as default/library drive
                lda qualif      ;get current directory
                sta defqua,x    ;set as default/library directory
                rts

savmem:                         ;Copy shared workspace to private page
                jsr savita
                lda temp+$00    ;save current contents of page pointer
                pha
                lda temp+$01
                pha
                jsr suspri      ;set up pointer to private page
                ldy #$00        ;[D]opto
relme1:
                cpy #prsist-mainws ;store persistent main and channel workspace
                bcc relme2      ;(wrapped around so that private page
                lda mainws,y    ;contains: $00..$BF=seqmap, $C0..$ED=mainws)
                bcs relme3
relme2:
                lda seqmap,y
relme3:
                sta (temp),y
                iny
                cpy #sramws     ;[D]stop at SRAM workspace
                bne relme1
                pla             ;restore old contents of page pointer
                sta temp+$01
                pla
                sta temp+$00
                rts

readdf:                         ;Set current directory
                lda defqua      ;get default directory
                sta qualif      ;set as current directory
                jsr setupr      ;call GSINIT with C=0
                bne readd0      ;if argument present then parse it
                lda #$00        ;else default to drive 0
                jsr dodriv      ;select drive in A
                beq set3        ;and exit (always)

readd0:                         ;Parse directory spec
                lda defdsk      ;get default drive
                jsr dodriv      ;select drive in A
set4:
                jsr rdchr       ;call GSREAD and validate filename character
                bcs illdir      ;if invalid then raise "Bad dir" error
                cmp #$3A        ;else is character a colon?
                bne set0        ;if not then accept directory character
                jsr getdrv      ;else
                jsr rdchr       ;else call GSREAD
                bcs set3        ;if ":" by itself then "Bad drive" error
                cmp #$2E        ;else is character a full stop?
                beq set4        ;if so then expect a directory character, else:
illdir:                         ;Raise "Bad dir" error
                jsr illmsg
                .char $CE
                .text "dir"
                .char $00

set0:
                sta qualif      ;set directory from ASCII character
                jsr rdchr       ;if not at end of argument
                bcc illdir      ;then raise "Bad dir" error
set3:
                lda fdrive      ;else return drive number.
                rts

                .if SQUEEZE
                .else
title:                          ;*TITLE
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr setdef      ;set current drive and dir = default
                jsr getdir      ;load volume catalogue L4
                ldx #$0B        ;first offset to store = 11
                lda #$00        ;set title to 12 NULs:
clrti0:
                jsr titwit      ;store character of title
                dex             ;loop until 12 characters stored
                bpl clrti0
titset:
                inx             ;x=$FF, set X=0 offset of first character
                jsr rdchr       ;call GSREAD
                bcs titend      ;if end of argument write catalogue
                jsr titwit      ;else store character of title
                cpx #$0B        ;is this the twelfth character written?
                bcc titset      ;if not then loop to write more, else:
titend:
                jmp dirout      ;write volume catalogue and exit
                                ;can save 3 bytes (join; acces1 BCC booto)
                .endif

titwit:                         ;Store character of title
                cpx #$08        ;if offset is 8 or more
                bcc titllw
                sta dirhig-$08,x ;then store second sector, X=8..11
                rts

titllw:
                sta dirlow,x    ;else store in first sector, X=0..7
                rts

access:                         ;*ACCESS
                jsr setwld      ;allow wildcard characters in filename
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr getnam      ;set current file from argument
                ldx #$00        ;preset X=$00 file unlocked
                jsr setupr      ;call GSINIT with C=0
                bne acces5      ;if argument is empty
acces0:
                stx utemp       ;then attribute mask = $00, file unlocked
                .if SQUEEZE
                jsr errlok      ;ensure matching file in catalogue, then:
                .else
                jsr lookup      ;search for file in catalogue
                bcs acces1      ;if not found
                jmp nofil       ;then raise "Not found" error
                                ;can save 5 bytes (JSR errlok)
                .endif

acces1:
                jsr chkopn      ;ensure file not open (mutex)
                lda modify,y    ;get directory character from catalogue
                and #$7F        ;mask off old attribute
                ora utemp       ;apply new attribute
                sta modify,y    ;put back in catalogue
                jsr inform      ;print *INFO line if verbose
                jsr next        ;find next matching file
                bcs acces1      ;if found then set its attribute
                .if SQUEEZE
                bcc booto1
                .else
                bcc titend      ;else write volume catalogue and exit
                .endif

acces6:
                ldx #$80        ;found L, set bit 7 to indicate file locked:
acces5:
                jsr rdchr       ;call GSREAD, get character of attribute
                bcs acces0      ;if end of string then set attribute
                and #$5F        ;else clear bit 7, make uppercase
                cmp #$4C        ;is character "L" or "l"?
                beq acces6      ;if so then set bit 7
                jsr illmsg      ;else raise "Bad attribute" error.
                .char $CF
                .text "attribute"
                .char $00

wfopt:                          ;FSC  0 = *OPT
                jsr savita      ;save AXY
                txa
                cmp #$04        ;is it *OPT 4?
                beq booto       ;if so go and set boot option
                cmp #$02        ;else is it *OPT 0 or *OPT 1?
                bcc setmon      ;if so go and set monitoring option
                jsr illmsg      ;else raise "Bad option" error.
                .char $CB
                .text "option"
                .char $00

setmon:                         ;*OPT 0 / *OPT 1 monitor
                ldx #$FF
                tya             ;is verbosity level =0?
                beq stmon0      ;if so then set flag = $FF
                ldx #$00        ;else level >0, set flag = 0.
stmon0:
                stx monflg
                rts

booto:                          ;*OPT 4 set boot option
                tya             ;save requested option
                pha
                jsr setdef      ;set current drive and dir = default
                jsr L93C0       ;load volume catalogue
                pla             ;restore option
                jsr lfour       ;shift A left 4 places
                eor option      ;xor new option with old
                and #$30        ;clear all but option bits 5,4
                eor option      ;b5,4 contain new option, others preserved
                sta option      ;store new option in catalogue
                .if SQUEEZE
booto1:
                .endif
                jmp dirout      ;write volume catalogue and exit.

noroom:                         ;Raise "Disk full" error.
                jsr dskmsg
                .char $C6
                .text "full"
                .char $00

dirdo:                          ;OSFILE   7 = create file
                jsr frmnam      ;set current file from argument pointer
                jsr lookup      ;search for file in catalogue
                bcc filels      ;if found
                jsr delfil      ;then delete catalogue entry
filels:
                lda strtlo      ;save start address low word
                pha
                lda strthi
                pha
                sec             ;subtract end address - start address
                lda endlo       ;(24 bits) yielding file length
                sbc strtlo
                sta lenlo
                lda endhi
                sbc strthi
                sta lenhi
                lda endhl
                sbc strthl
                sta lenhl
                jsr genfil      ;create catalogue entry
                lda strthh      ;copy start address high word to data pointer
                sta ldlow+$03
                lda strthl
                sta ldlow+$02
                pla             ;restore low word to data pointer
                sta lodhi
                pla
                sta lodlo
                rts

genfil:                         ;Create catalogue entry
                lda #$00        ;start of data area = LBA $0002
                sta lbahi       ;set MSB of LBA = 0
                lda #$02        ;a=no. reserved sectors in data area
                sta lbalo       ;set as LSB of LBA
                ldy dirlen      ;get number of files in catalogue * 8
                cpy #$F8        ;if there are already 31 files
                bcs dirful      ;then raise "Cat full" error, else:
                jsr dskspc      ;test if new file will fit at current LBA
                jmp spachk      ;jump into loop

spalop:
                beq noroom      ;if cat ptr = 0 then raise "Disk full" error
                jsr unstep      ;else subtract 8 from Y
                jsr dskadr      ;test if new file will fit after current file
spachk:
                tya             ;test if catalogue pointer > 0
                bcc spalop      ;if file won't fit then test prev cat entry
                sty temp        ;else insert new catalogue entry here
                ldy dirlen      ;point Y to last valid catalogue entry:
moveup:
                cpy temp        ;compare pointer with insertion point
                beq insnam      ;stop copying if insertion point reached
                lda catlow-$01,y ;else copy current catalogue entry
                sta catlow+$07,y ;to next slot
                lda cathig-$01,y ;leaving one slot open
                sta cathig+$07,y ;for new catalogue entry
                dey             ;decrease pointer to work back from end
                bcs moveup      ;and loop (always)

insnam:                         ;Write entry into catalogue at Y=0..$F0
                ldx #$00        ;offset into current filename = 0
                jsr encode
namin:
                lda wrknam,x    ;get character of current filename+dir
                sta catlow,y    ;store in catalogue
                iny             ;increment both offsets
                inx
                cpx #$08        ;loop until 8 bytes copied:
                bne namin
varin:                          ;Write load/exec/length/start into catalogue
                lda wrkcat-$01,x ;x=8..1 copy from wrkcat
                dey             ;y=catalogue pointer + 7..0
                sta cathig,y    ;copy to catalogue address fields
                dex             ;loop until 8 bytes copied
                bne varin
                jsr inform      ;print *INFO line if verbose
                tya             ;save catalogue pointer
                pha
                ldy dirlen      ;get number of files in catalogue * 8
                jsr step        ;add 8 to Y
                sty dirlen      ;store new file count
                jsr dirout      ;write volume catalogue
                pla             ;restore catalogue pointer
                tay
                rts

dirful:                         ;Raise "Cat full" error.
                jsr estrng
                .char $BE
                .text "Cat full"
                .char $00

encode:                         ;Compose top bits exec/length/load/start
                lda exlow+$02   ;get b17,b16 exec address
                and #$03        ;place in b1,b0 of A, clear b7..b2
                asl a           ;shift A left 2 places
                asl a           ;a = ....ee..
                eor lenhl       ;place b17,b16 of length in b1,b0
                and #$FC        ;keep b7..b2 of A
                eor lenhl       ;a = ....eell
                asl a           ;shift A left 2 places
                asl a           ;a = ..eell..
                eor ldlow+$02   ;place b17,b16 of load address in b1,b0
                and #$FC        ;keep b7..b2 of A
                eor ldlow+$02   ;a = ..eelldd
                asl a           ;shift A left 2 places
                asl a           ;a = eelldd..
                eor lbahi       ;place b10,b9 of start LBA in b1,b0
                and #$FC        ;keep b7..b2 of A
                eor lbahi       ;a = eellddss
                sta wrkcat+$06  ;set top bits exec/length/load/start sector
                rts

enable:                         ;*ENABLE
                lda #$01        ;set *ENABLE flag = 1; will be nonnegative
                sta enaflg      ;(after FSC 8) for next *command only.
                rts

decodl:                         ;Expand 18-bit load address to 32-bit
                lda #$00
                sta ldlow+$03   ;set MSB of address = $00
                lda wrkcat+$06  ;get top bits exec/length/load/start sector
                jsr isolod      ;extract bit 3 to bits 1 and 0
                .if SQUEEZE
                beq decdl0      ;if clear then set high word = $0000, else:
LA5D1:                          ;Set high word of OSFILE load address = $FFFF
                .else
                cmp #$03        ;redundant (BEQ decdl0)
                bne decdl0      ;if clear then set high word = $0000
                .endif
                lda #$FF        ;else set high word of OSFILE load address = $FFFF
                sta ldlow+$03
decdl0:
                sta ldlow+$02
                rts

decode:                         ;Expand 18-bit exec address to 32-bit
                lda #$00
                sta exlow+$03   ;set MSB of address = $00
                lda wrkcat+$06  ;get top bits exec/length/load/start sector
                jsr isoexe      ;extract b7,b6 of A
                cmp #$03        ;if b7,b6 both set
                bne decde0
                lda #$FF        ;then a host address, set high word = $FFFF
                sta exlow+$03
decde0:
                sta exlow+$02   ;else set 2MSB parasite address $0..2FFFF
                rts

setdef:                         ;Set current drive and directory = default
                lda defqua      ;get default directory
                sta qualif      ;set as current directory:
setddr:                         ;Select default drive
                lda defdsk      ;get default drive
                jmp dodriv      ;select drive in A

readrv:                         ;Select specified or default drive
                jsr setupr      ;call GSINIT with C=0
                beq setddr      ;if argument empty select default drive, else:
getdrv:                         ;Set current drive from argument
                jsr rdchr       ;call GSREAD and validate filename character
                bcs drverr      ;if invalid then raise "Bad drive" error
                cmp #$3A        ;else is character a colon?
                beq getdrv      ;if so then skip it and loop
                sec
                sbc #$30        ;else convert ASCII digit to binary
                .if SQUEEZE
                .else
                bcc drverr      ;redundant
                .endif
                cmp #$04        ;ensure drive number in range 0..3
                bcs drverr      ;if not then raise "Bad drive" error
                jsr dodriv      ;else select drive in A
                clc             ;return C=0, drive spec valid
                rts

drverr:                         ;Raise "Bad drive" error
                jsr illmsg
                .char $CD
                .text "drive"
                .char $00

rename:                         ;*RENAME
                jsr clrwld      ;disallow wildcard characters in filename
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr getnam      ;set current file from file spec
                tya             ;save command line offset
                pha
                jsr errlok      ;ensure matching file in catalogue
                jsr chkopl      ;ensure file not locked or open (mutex)
                sty L00C4       ;save catalogue offset [D] was to itemp, $B3
                pla             ;restore command line offset
                tay
                jsr chksyn      ;call GSINIT with C=0 and require argument
                lda fdrive      ;save current drive
                pha
                jsr getnam      ;set current file from file spec
                pla             ;restore current drive
                cmp fdrive      ;compare with destination drive
                bne drverr      ;if rename across drives then "Bad drive"
                jsr lookup      ;else search for file in catalogue
                bcc ren4        ;if not found then update filename+dir
                cpy L00C4       ;else compare catalogue offsets
                beq ren4        ;if file specs match then allow case change
                jsr estrng      ;else raise "Exists" error.
                .char $C4
                .text "Exists"
                .char $00

ren4:
                ldy L00C4       ;get catalogue offset of file
                jsr step        ;add 8 to Y
                ldx #$07        ;8 characters to replace:
ren5:
                lda wrknam,x    ;get character of current filename+dir
                sta catlow-$01,y ;store in catalogue
                dey             ;decrement both offsets
                dex
                bpl ren5        ;loop until 8 bytes copied
                jmp dirout      ;write volume catalogue and exit


L8BBC:                          ;Internal OSWORD $7F handler
                clc             ;c=0 interrupts not enabled
                bcc L8BC1       ;branch into routine (always)

L8BBF:                          ;Internal OSWORD $7F handler w/interrupts
                cli             ;enable IRQ handling
                sec             ;set carry flag to indicate this
L8BC1:
                ror xtemp       ;save interrupt flag state in xtemp
                stx temp+$00    ;set up pointer to caller's control block
                sty temp+$01
                cld             ;clear decimal mode
                jsr L8C1C       ;prepare for OSWORD $7F operation
                lda L00A2       ;test result code
                bne L8BD8       ;if recalibration failed then skip
                ldy #$05        ;else get number of OSWORD $7F parameters
                lda (temp),y
                beq L8BD8       ;if zero then skip
                jsr L8CD1       ;else do OSWORD $7F operation
L8BD8:
                ldy #$05        ;get number of OSWORD $7F parameters
                lda (temp),y
                clc             ;add 7 = offset of OSWORD $7F result
                adc #$07
                tay             ;set new offset
                lda L00A2       ;get final controller status
                jsr L8C0D       ;convert WD 1770 status to i8271 result
                sta (temp),y    ;store in caller's control block
                pha             ;save status for return
                cmp #$18        ;$18 = sector not found
                bne L8BF1       ;if status matches
                lda #$FF        ;then mark both drives uncalibrated
                sta LC287
L8BF1:
                lda fdrive      ;get drive number
                and #$01        ;mask unit number
                tay             ;in Y as offset
                lda track       ;get track number of disc operation
                sta LC288,y     ;get track number of current unit
                jsr L8EDF       ;write track register
                bit L00A1       ;test Tube flag
                bpl L8C05       ;if Tube in use
                jsr L8F2F       ;then release Tube
L8C05:
                jsr L8F13       ;release NMI
                lda fdcdat      ;read and discard FDC data register
                pla             ;restore result code for return
                rts

L8C0D:                          ;Convert WD 1770 status to i8271 result
                ldx #L90F3-L90ED-$01 ;start at end of table
L8C0F:
                cmp L90ED,x     ;scan table for known WD 1770 results
                beq L8C18       ;if match found then convert
                dex             ;else step to start of table
                bpl L8C0F       ;loop until before first entry (X=$FF)
                rts             ;if not found return WD 1770 status.

L8C18:
                lda L90F3,x     ;return equivalent Intel 8271 result code
                rts

L8C1C:                          ;Prepare for OSWORD $7F operation
                jsr L8F04       ;claim NMI
                jsr L8F37       ;set track stepping speed from CMOS RAM
                lda #$00
                sta L00A1       ;clear read/write flag
                ldy #$09        ;copy bytes 9..11 of control block to zp
L8C28:
                lda (temp),y
                sta itemp-$09,y ;sets itemp, atemp, ytemp from parms 3..5
                iny
                cpy #$0C        ;do not copy offset 12
                bne L8C28
                ldy #$06        ;offset of command
                lda (temp),y    ;get command byte
                and #$F0        ;mask off flag bits (except m, multiple)
                cmp #$A0        ;is command $A0, write sector?
                beq L8C3E       ;if so then C=1, set write flag
                cmp #$F0        ;else set C=1 if $F0, write track else C=0
L8C3E:
                ror L00A1       ;b7=1 writing to disc, b7=0 reading from disc
                ldy #$03        ;offset of 2MSB data address
                lda (temp),y    ;get 2MSB data address
                iny             ;y=$04
                and (temp),y    ;and with MSB data address
                cmp #$FF        ;if both = $FF then it's a host address
                clc
                beq L8C69       ;so skip Tube setup with C=0, host transfer
                jsr L8EF4       ;else set Tube presence flag
                clc
                bmi L8C69       ;if Tube absent then skip setup with C=0
                jsr clatub      ;else claim Tube
                .if SQUEEZE
                lda #$00        ;clear b7..b1 of Tube call and make zero comparand
                cmp L00A1       ;c=1 iff flag=$00, read bytes from disc
                rol a           ;convert to $00=bytes to host, $01=bytes from host
                .else
                lda L00A1       ;flag=$80 write, $00 read
                rol a           ;convert to $01=bytes to disc, $00=bytes from disc
                rol a
                and #$01        ;redundant
                eor #$01        ;flip b0: $00=bytes to host, $01=bytes from host
                .endif
                ldx temp+$00    ;point XY to caller's control block
                ldy temp+$01
                inx             ;increment low byte of pointer
                bne L8C65       ;carry out to high byte
                iny             ;to point to data address in control block
L8C65:
                jsr tubadr      ;call Tube service to set up data transfer
                sec             ;set C=1, transferring to Tube:
L8C69:
                ror L00A1       ;set b7=Tube flag, b6=write flag
                jsr L8F48       ;install NMI service routine
                ldy #$00        ;$00 = offset of drive parameter
                lda (temp),y    ;get drive number to operate on
                bmi L8C78       ;if b7=1 reuse current drive then skip
                and #$0F        ;else mask drive number and option bits
                sta fdrive      ;set current drive
L8C78:
                lda fdrive      ;get current drive
                .if BUGFIX
                and #$0F        ;mask drive number and options
                cmp #$08        ;set C=bit 3, force double density
                and #$03        ;mask drive number 0..3
                tax             ;transfer to X for use as index
                lda LC2DE,x     ;get flags for selected drive
                sta LC28A       ;set current drive flags
                lda L90D1,x     ;set A=latches for drive 0..3 in X
                ldx #$0A        ;preset 10 sectors per track
                bcc o7fset      ;if double density
                eor #$20        ;then clear single density flag in b5
                ldx #$10        ;and set 16 sectors per track
o7fset:
                stx L00A3       ;set sectors per track
                sta latch       ;store in control latch
                lsr a           ;c=1 iff drive 0/2 selected
                and #$01        ;a=1 iff drive 1/3 selected
                tax             ;transfer to X for use as index
                lda LC288,x     ;get head position of chosen drive
                tax             ;hold in X
                sty L00A2       ;clear result code/NMI busy flag
                lda LC287       ;test b7=d0, b6=d1 uncal flags
                bcc L8CB3       ;if drive 0 is selected
                bpl L8CC4       ;and drive 0 uncal flag is set
                sty LC288+$00   ;then zero head 0 position
                and #$7F        ;and clear uncal flag
                bpl L8CBA

L8CB3:                          ;drive 1 selected
                asl a           ;drive 1 uncalibrated flag to N
                bpl L8CC4       ;if clear then set track register
                sty LC288+$01   ;else zero head 1 position
                and #$7F        ;clear drive 1 uncal flag
                ror a           ;restore drive 0 uncal flag to b7
                .else
                and #$03        ;mask drive number 0..3
                tax             ;transfer to X for use as index
                lda LC2DE,x     ;get flags for selected drive
                sta LC28A       ;set current drive flags
                lda fdrive      ;get current drive again
                ldy #$0A        ;preset 10 sectors per track
                and #$08        ;mask b3, force double density
                beq L8C8D       ;if set
                ldy #$10        ;then set 16 sectors per track
L8C8D:
                sty L00A3       ;set sectors per track
                eor L90D1,x     ;apply latches for drive 0..3 in X
                sta latch       ;store in control latch [BUG] wrong DD bit
                lsr a           ;c=0 drive 1/3; c=1 drive 0/2
                ldx LC288+$00   ;get head position of chosen drive
                bcs L8C9E       ;drive 0/2
                ldx LC288+$01   ;or drive 1/3
L8C9E:
                ldy #$00
                sty L00A2       ;clear result code/NMI busy flag
                lda LC287       ;test b7=d0, b6=d1 uncal flags
                bit LC287
                bcc L8CB3       ;if drive 0 is selected
                bpl L8CC4       ;and drive 0 uncal flag is set
                sty LC288+$00   ;then zero head 0 position
                and #$7F        ;and clear uncal flag
                bpl L8CBA

L8CB3:
                bvc L8CC4       ;likewise for drive 1
                sty LC288+$01
                and #$BF
                .endif
L8CBA:
                sta LC287       ;update uncal flags
                lda #$00        ;$00 = restore
                jsr L8DC9       ;execute WD 1770 command in A
                ldx #$00        ;head now at track 0:
L8CC4:
                txa             ;store current track
                sta track
                jsr L8EDF       ;write track register.
L8CCA:
                rts

L8CCB:
                jmp L8E64       ;$C0 read address

L8CCE:
                jmp L8DC9       ;execute WD 1770 command in A

L8CD1:                          ;Do OSWORD $7F operation
                jsr L8EB4       ;seek track
                bne L8CCA       ;if command failed then exit silently
                ldy #$06        ;get command byte
                lda (temp),y
                cmp #$10        ;if $10 seek
                beq L8CCA       ;then we just did it, so exit
                cmp #$C0        ;if $C0 read address
                beq L8CCB       ;then handle separately
                cmp #$E0        ;if $E0 read track/$F0 write track
                bcs L8CCE       ;then execute WD 1770 command in A
                ldy #$08        ;2nd parm, starting sector
                lda (temp),y
                bit xtemp       ;if called from OSWORD $7F
                bmi L8D49       ;then do single track operation
                ldx ytemp       ;else get ytemp set from XY+9
                beq L8CF8       ;if transferring a partial sector
                inc itemp       ;then round up LSB number of sectors
                bne L8CF8       ;carry out to MSB
                inc atemp
L8CF8:
                jsr L90AF       ;write sector register
                sta sector      ;store current sector
                .if SQUEEZE
                eor #$FF        ;c=1; take two's complement
                adc L00A3       ;subtract current sector from no. per track
                .else
                sbc L00A3       ;c=1; subtract number of sectors per track
                eor #$FF        ;take two's complement
                clc             ;can save 3 bytes (EOR #$FF:ADC L00A3)
                adc #$01        ;=number of sectors to end of track
                .endif
                sta L00A5       ;store sector count
                lda atemp       ;if more than 255 sectors to transfer
                bne L8D2B       ;then transfer rest of track
                lda itemp       ;else get LSB number of sectors
                beq L8D48       ;if zero then nothing to do, so exit
                cmp L00A5       ;else compare with span to end of track
                beq L8D14       ;if equal then transfer correct no. bytes
                bcs L8D2B       ;if more then transfer rest of track
L8D14:
                sta L00A5       ;else set sector count
                ldx ytemp       ;get number of bytes to transfer
                beq L8D2B       ;if >0, i.e. partial sector
                stx L00A6       ;then set byte count
                ror L00A1       ;set b0 of flag
                sec
                rol L00A1
                cmp #$01        ;if doing no whole sectors, only partial
                bne L8D2B       ;then no sector advance occurs
                lda L8FA7-L8F86+intnmi+$01 ;so emulate L8FA7: ?$0D4C=?$0D22
                sta L8FD1-L8F86+intnmi+$01 ;discard/write zeroes at end of count
L8D2B:
                lda itemp       ;get LSB number of sectors to transfer
                sec             ;subtract number of sectors in this operation
                sbc L00A5       ;store updated count of sectors remaining
                sta itemp
                lda atemp       ;borrow in from MSB
                sbc #$00
                sta atemp
                jsr L8DC5       ;execute WD 1770 command
                bne L8D48       ;if failed then exit silently
                lda itemp       ;else test number of sectors remaining
                ora atemp
                beq L8D48       ;if none remaining then exit Z=1
                jsr L8E81       ;else advance track and skip bad tracks
                beq L8CF8       ;if successful then loop to do next track
L8D48:
                rts             ;else exit

L8D49:                          ;do single track operation
                jsr L90AF       ;write sector register
                sta sector      ;store current sector
                ldy #$09        ;3rd parm, sector size+count
                lda (temp),y
                and #$1F        ;mask off sector size code
                beq L8D48       ;if no sectors to transfer then exit Z=1
                sta L00A5       ;else store sector count
                bit L00A1       ;test write flag in b6
                bvs L8DC5       ;if writing then execute WD 1770 command
                bit LC28A       ;else test disc op modifier (from C2DE,X)
                bvc L8DC5       ;if drive 0 and Z-BREAK in effect
                ldx #(L90AF-L901B+intnmi-ecowsp-$01) ;then X=size of overhang - $01:
L8D63:
                lda ecowsp,x    ;copy Econet reserved area
                sta buffer,x    ;to buffer
                dex
                bpl L8D63
                jsr L8D7D       ;emulate Intel 8271 disc operation
                ldx #(L90AF-L901B+intnmi-ecowsp-$01) ;x=size of saved Econet area
L8D71:
                lda buffer,x    ;restore Econet reserved workspace
                sta ecowsp,x    ;from buffer
                dex
                bpl L8D71
                lda L00A2       ;return final result code
                rts

L8D7D:                          ;Emulate Intel 8271 disc operation
                .if BUGFIX
                lda (temp),y    ;3rd parm, sector size+count
                sta atemp       ;store in temp shift register
                and #$80        ;extract b7 of byte = b2 of code
                bmi emudon      ;%111 = 128 * 128 bytes/sec
                lda #$08        ;%011 = 8 * 128 bytes/sec
emudon:
                asl atemp       ;test b6 of byte, b1 of code
                bmi emudo1      ;if b6=0, %x0x
                lsr a           ;then divide sector size by 4
                lsr a
emudo1:
                asl atemp       ;test b5 of byte, b0 of code
                bmi emudo2      ;if b5=0, %xx0
                lsr a           ;then halve sector size
emudo2:
                lsr a           ;halve again to get no. pages
                sta atemp       ;store MSB sector size
                lda #$00        ;clear LSB sector size
                ror a           ;shift carry into b7
                sta itemp       ;store LSB = 0 or 128 bytes
                .else
                lda #$00
                sta atemp       ;clear MSB sector size
                lda (temp),y    ;3rd parm, sector size+count
                and #$E0        ;extract sector size code
                bne L8D89       ;if %000, 128-byte sectors
                lda #$10        ;then sector size = 128 bytes
L8D89:
                asl a           ;[BUG] not decoded!
                rol atemp       ;shift sector size code
                asl a           ;into MSB sector size b2..b0
                rol atemp
                asl a
                rol atemp
                sta itemp       ;store LSB = 0 or 128 bytes
                tax             ;test LSB
                .endif
                beq L8D99       ;if sector size = 128 bytes
                inc atemp       ;then treat as one (short) page
L8D99:
                jsr L8FF2       ;install i8271 emulator ISR
                lda #$14        ;20 attempts
                sta vtemp+$01
L8DA0:
                lda #$E0        ;command = $E0 read track
                sta L00A2       ;set b7=1 ISR busy flag
                sta fdccmd      ;store command register
L8DA7:
                lda L00A2       ;test ISR busy flag
                bmi L8DA7       ;loop until ISR finished
                bne L8DC4       ;if error occurred then exit
                lda L00A5       ;else test no. sectors remaining
                beq L8DBA       ;if no more then set result code
                dec vtemp+$01   ;else decrement attempt counter
                bne L8DA0       ;if attempts remaining then try again
                lda #$10        ;else WD 1770 S4 = record not found
                sta L00A2       ;can save 1 byte: BNE L8DC4-$02
                rts

L8DBA:
                lda vtemp+$00   ;test found data address mark
                eor #$FB        ;if equal to $FB, normal DAM
                beq L8DC4       ;then return $00, good completion
                lda #$20        ;else WD 1770 S5 = deleted data mark
                sta L00A2
L8DC4:
                rts

L8DC5:                          ;Execute WD 1770 command
                ldy #$06
                lda (temp),y
L8DC9:                          ;Execute WD 1770 command in A
                ldy #$FF        ;y=$FF going to 0, point to start of table:
L8DCB:
                iny             ;search table for command
                cmp L90D5,y
                bne L8DCB       ;only recognised commands used, always terminates
                pha             ;save command
                lda L90E1,y     ;get status code mask corresponding to command
                sta L8F8A-L8F86+intnmi+$01 ;set AND operand in NMI handler
                ror L00A2       ;c=1; set b7 of flag, b7=1 ISR busy
                pla             ;restore command
                bpl L8E29       ;if a Type I command then branch
                bit L00A1       ;else test write flag
                bvc L8DE9       ;if writing to disc
                ldy track
                cpy #$14        ;and if track number >= 20
                bcc L8DE9
                ora #$02        ;then enable write precompensation
L8DE9:
                sta L00A7       ;store command byte
                ldy #$01        ;if command = $C0, read address
                cmp #$C0        ;then Y=1 read one address
                beq L8E0A       ;and no settling delay
                ora #$04        ;else enable head settling delay
                bcs L8E0A       ;if $F0 then write one track
                ldy L00A5       ;else $80/$A0 read/write Y sectors
                cmp #$85        ;if original command was $81
                beq L8E04       ;(read w/privilege) then command=$80
                cmp #$87        ;else if $83 (=$5E/$5F verify data)
                bne L8E0A
                lda #L8FD8-L8F8E-$02 ;then discard all data read during NMI
                sta L8F8E-L8F86+intnmi+$01
L8E04:
                lda #$80        ;set repeat command =$80 read sector
                sta L00A7
                lda #$84        ;actual first command =$84 read/settling
L8E0A:
                sty L00A5       ;set count of items
                sta fdccmd      ;send command to FDC
                cmp #$F0        ;if it is $F0, write track
                bcc L8E1B
                jsr L8E54       ;then wait until controller idle
                and #$5C        ;mask {WrProt NotFound CRCError LostData}
                sta L00A2       ;store command result
                rts

L8E1B:
                lda L00A2       ;else wait until ISR finished
                bmi L8E1B
                cmp #$20        ;if deleted data was read??
                bne L8E26
                jsr L8E5A       ;then wait until controller idle
L8E26:
                lda L00A2       ;return masked controller status
                rts

L8E29:                          ;type I command
                ldy #$01        ;execute it once
                sty L00A5
                ora L00A4       ;apply stepping speed bits in b1,b0
                sta fdccmd      ;send command to FDC
                bit xtemp       ;if called from OSWORD $7F
                bmi L8E1B       ;then wait for ISR and return status
                cmp #$20        ;else if $20 step/$40 step in/$60 step out
                bcs L8E1B       ;then wait for ISR and return status
L8E3A:
                lda L00A2       ;else seek/restore.  wait until ISR finished
                bpl L8E53       ;if so then exit
                lda escflg      ;else test escape flag
                bpl L8E3A       ;if Escape not pressed then keep waiting
                lda #$40        ;else $0D00 = RTI
                sta intnmi+$00
                lda #$00        ;b2=0 put FDC in reset
                sta latch
                .if BUGFIX
                lda #$FF
                .else
                lda escflg      ;reload escape flag = $FF [BUG]
                .endif
                sta catdrv      ;forget catalogue in workspace
                sta L00A2       ;set bogus controller status = $FF, escape
L8E53:
                rts

L8E54:                          ;Wait for controller to complete operation
                lda fdcsta      ;get status from FDC
                ror a           ;test WD1770 S0 = busy
                bcc L8E54       ;if not busy then wait for operation to start
L8E5A:                          ;Wait for controller to become idle
                lda fdcsta      ;get status from FDC
                ror a           ;test WD1770 S0 = busy
                bcs L8E5A       ;if busy then wait for operation to finish
                lda fdcsta      ;then get final status from FDC
                rts

L8E64:                          ;$C0 Read address
                lda #L8FD8-L8F8E-$02 ;?$0D4C=$48
                sta L8FD1-L8F86+intnmi+$01 ;set ISR to discard data after count read
                ldx L8F8E-L8F86+intnmi+$01 ;hold DRQ dispatch branch operand
L8E6C:
                sbc #$01        ;wait 180 microseconds
                bne L8E6C
                stx L8F8E-L8F86+intnmi+$01 ;restore branch operand (=$2F?? store bytes read)
                lda #$04        ;4 bytes to read
                sta L00A6       ;set count of bytes to transfer
                jsr L8DC5       ;execute WD 1770 command
                bne L8E80       ;if command failed exit Z=0
                dec itemp       ;else decrement count of sector IDs to read
                bne L8E6C       ;loop until all IDs read
L8E80:
                rts

L8E81:                          ;Advance track and skip bad tracks
                jsr L8EA1       ;advance track
                bne L8EA0       ;if failed then exit
                lda fdrive      ;else get drive number
                and #$01        ;mask unit number
                asl a           ;double it
                tay             ;to Y as bad track table offset
                lda track       ;get current track
                bit LC28A       ;test 40-track flag
                bpl L8E94       ;if set
                lsr a           ;then halve track number
L8E94:
                cmp LC28B,y     ;compare with first bad track
                beq L8E81       ;if equal then advance track
                cmp LC28B+$01,y ;else compare with second bad track
                beq L8E81       ;if equal then advance track
                lda #$00        ;else return Z=1, succeeded
L8EA0:
                rts

L8EA1:                          ;Advance track
                bit LC28A       ;test 40-track flag
                bpl L8EAD       ;if clear then step in once
                lda #$40        ;else $40 = step in
                jsr L8EAF       ;increment track and step drive
                bne L8EA0       ;if step failed then exit
L8EAD:
                lda #$50        ;$50 = step in, update track reg.
L8EAF:
                inc track       ;increment current track
                jmp L8DC9       ;execute WD 1770 command in A

L8EB4:                          ;Seek track
                lda fdrive      ;get current drive
                and #$01        ;extract unit number 0=0/2 1=1/3
                asl a           ;double it
                tax             ;to X as bad track register offset
                ldy #$07
                lda (temp),y    ;1st parm, track number
                jsr L8EE8       ;skip bad tracks on unit X/2
                bit LC28A       ;test current disc operation flags
                bpl L8EC7       ;if 40-track flag set
                asl a           ;then double track number
L8EC7:
                sta track       ;store current track number
                tay             ;if zero
                beq L8ED6       ;then command=$00 restore
L8ECC:
                sta fdcdat      ;else store track no. in data register
                cmp fdcdat      ;loop until FDC takes it
                bne L8ECC
                lda #$10        ;command=$10 seek
L8ED6:
                jsr L8DC9       ;execute WD 1770 command in A
                bne L8EF3       ;if command failed then exit silently
                ldy #$07        ;else get back 1st parm, track number
                lda (temp),y    ;set FDC track register to logical track number:
L8EDF:                          ;Write track register
                sta fdctrk
                cmp fdctrk
                bne L8EDF
                rts

L8EE8:                          ;Skip bad tracks on unit X/2
                jsr L8EEC       ;skip first bad track
                inx             ;point X to second bad track register:
L8EEC:
                cmp LC28B,x     ;if A equals or exceeds bad track no. then add 1
                .if SQUEEZE
                .else
                bcc L8EF3       ;redundant, can save 2 bytes
                .endif
                adc #$00        ;or 1 byte by unrolling (-INX)
L8EF3:
                rts

L8EF4:                          ;Set Tube presence flag
                lda #$EA
                ldx #$00        ;$00 = don't alter variable
                ldy #$FF        ;$FF = don't update variable
                jsr osbyte      ;call OSBYTE $EA = read Tube presence flag
                txa
                eor #$FF        ;invert; 0=tube present $FF=Tube absent
                sta notube      ;save Tube presence flag
                rts

L8F04:                          ;Claim NMI
                lda #$8F        ;OSBYTE $8F = issue service call
                ldx #$0C        ;service call $0C = claim NMI
                ldy #$FF        ;call OSBYTE with Y=$FF
                jsr osbyte
                sty prenmi      ;save ID of previous NMI owner
                inc colds       ;$00 = force cold start
                rts

L8F13:                          ;Release NMI
                ldy prenmi      ;Y = ID of previous NMI owner
                lda #$8F
                ldx #$0B        ;service call $0B = NMI release
                jsr osbyte      ;call OSBYTE $8F = issue service call
                dec colds       ;$FF = allow warm start
                rts

clatub:                         ;Claim Tube
                pha
clatb0:
                lda #$C0+dftbid ;tube service call = $C0 + ID for DFS (1)
                jsr tubadr      ;call Tube service
                bcc clatb0      ;loop until C=1, indicating claim granted
                pla
                rts

reltub:                         ;Release Tube
                jsr L8EF4       ;set Tube presence flag [D]opto
                bmi L8F36       ;if Tube not present then exit, else:
L8F2F:
                pha
                lda #$80+dftbid ;tube service call = $80 + ID for DFS (1)
                jsr tubadr      ;call Tube service
                pla
L8F36:
                rts

L8F37:                          ;Set track stepping speed from CMOS RAM
                lda #$A1        ;OSBYTE $A1 = read CMOS RAM
                ldx #$0B        ;$0B = ADFS start-up options, keyboard settings and floppy drive parameters
                jsr osbyte
                tya
                and #$02        ;if bit 1 set
                beq L8F45
                lda #$03        ;then set $03 = slowest stepping (30 ms)
L8F45:
                sta L00A4       ;else set $00 = fastest stepping (6 ms)
                rts

L8F48:                          ;Install NMI service routine
                ldx #L8FE4-L8F86-$01 ;set X=offset of last byte of routine
L8F4A:
                lda L8F86,x     ;copy routine to NMI service area at $0D00
                sta intnmi,x
                dex
                bpl L8F4A
                ldx #L8FC2-L8FBF ;if reading, X=3
                bit L00A1       ;to paste address into STA instruction
                bvc L8F69
                lda #L8FDD-L8F8E-$02 ;else set NMISR to write zeroes at end of transfer
                sta L8FA7-L8F86+intnmi+$01
                ldx #L8FF2-L8FE4 ;point X to last byte of write overlay
L8F60:
                lda L8FE4-$01,x ;replace part of NMI service routine with write overlay
                sta L8FBF-L8F86+intnmi-$01,x
                dex
                bne L8F60       ;finish with X=0
L8F69:
                bit L00A1       ;test Tube flag
                bmi L8F7B       ;if transferring to host
                ldy #$01        ;then get LSB of data address from control block
                lda (temp),y
                sta L8FBF-L8F86+intnmi+$01,x ;paste LSB LDA operand (X=0) or STA (X=3)
                iny             ;y=$02
                lda (temp),y    ;get 3MSB data address
                sta L8FBF-L8F86+intnmi+$02,x ;paste MSB LDA operand (X=0) or STA (X=3)
                rts

L8F7B:                          ;transferring to Tube.
                lda #$B0        ;0D3F=BCS L8FCD
                sta L8FC5-L8F86+intnmi+$00
                lda #L8FCD-L8FC5-$02 ;always branch; do not increment R3DATA address
                sta L8FC5-L8F86+intnmi+$01
                rts


                                ;NMI routine copied to $0D00
L8F86:
                pha             ;save A from main thread
                lda fdcsta      ;read status register
L8F8A:
                and #$18        ;apply mask matching command (pasted here)
                cmp #$03        ;if {DRQ Busy} then data request
L8F8E:
                beq L8FBF       ;so handle DRQ (default: read to Tube)
                and #$FC        ;else mask off {DRQ Busy}; b7 already clear
                bne L8F98       ;if S6..S2 set then return result code
                dec L00A5       ;else command complete; decrement sector count
                bne L8F9C       ;if more sectors then advance to next sector
L8F98:
                sta L00A2       ;clear NMI busy flag, b6..2=status
                pla             ;restore A from main thread
                rti             ;return from interrupt

L8F9C:                          ;advance sector
                lda L00A5       ;test no. sectors remaining
                cmp #$01        ;if next sector is the last
                bne L8FAC
                lda L00A1       ;then test b0=partial sector flag
                ror a
                bcc L8FAC       ;if set
L8FA7:
                lda #L8FD8-L8F8E-$02 ;then discard data/write zeroes at end of byte count
                sta L8FD1-L8F86+intnmi+$01
L8FAC:
                inc sector      ;increment current sector
                lda sector      ;get new current sector
L8FB0:
                sta fdcsec      ;write sector register
                cmp fdcsec      ;loop until FDC takes it
                bne L8FB0
                lda L00A7       ;get repeat command
                sta fdccmd      ;write to command register
                pla             ;restore A from main thread
                rti             ;return from interrupt

L8FBF:                          ;data request handler
                lda fdcdat      ;read data register
L8FC2:
                sta reg3        ;if reading to host, address pasted here
L8FC5:
                inc L8FC2-L8F86+intnmi+$01 ;increment low byte of host address
                bne L8FCD       ;(branched-over if transferring to/from Tube)
                inc L8FC2-L8F86+intnmi+$02 ;carry out to high byte
L8FCD:
                dec L00A6       ;decrement byte count
                bne L8FD6       ;exit ISR if bytes remaining
L8FD1:
                lda #L8FBF-L8F8E-$02 ;0D4B set dispatch branch offset for next DRQs
                sta L8F8E-L8F86+intnmi+$01 ;default: continue reading to memory
L8FD6:
                pla             ;restore A from main thread
                rti             ;return from interrupt

L8FD8:
                lda fdcdat      ;read and discard data register
                pla             ;restore A from main thread
                rti             ;return from interrupt

L8FDD:
                lda #$00        ;write zero to data register
                sta fdcdat
                pla             ;restore A from main thread
                rti             ;return from interrupt


L8FE4:                          ;Write overlay pasted to $0D39
                lda reg3        ;if writing to host, address pasted here / L8FBF
L8FE7:
                sta fdcdat      ;write data register
                inc L8FBF-L8F86+intnmi+$01 ;increment low byte of host address
                bne L8FF2       ;actually goes to L8FCD
                inc L8FBF-L8F86+intnmi+$02 ;carry out to high byte


L8FF2:                          ;Install i8271 emulator ISR
                ldx L8FC2-L8F86+intnmi+$01 ;extract I/O write address
                lda L8FC2-L8F86+intnmi+$02 ;from basic ISR, X=LSB A=MSB
                pha             ;save MSB
                ldy #L90AF-L901B ;y=offset of last byte of ISR
L8FFB:
                lda L901B-$01,y ;copy ISR from ROM
                sta intnmi-$01,y ;to NMI area at $0D00
                dey
                bne L8FFB
                pla             ;restore MSB write address
                bit L00A1       ;if reading to Tube
                bpl L9014
                lda #$B0        ;then $0D18 = BCS $0D20
                sta L9033-L901B+intnmi+$00
                lda #L903B-L9033-$02 ;always branch; do not increment R3DATA address
                sta L9033-L901B+intnmi+$01
                rts

L9014:
                stx L9030-L901B+intnmi+$01 ;else reading to I/O memory
                sta L9030-L901B+intnmi+$02 ;paste write address into new ISR.
                rts


                                ;NMI routine copied to $0D00
L901B:
                pha             ;save A from main thread
                lda fdcsta      ;read status register
                and #$1B        ;apply mask matching command (pasted here)
                cmp #$03        ;if idle or no DRQ
                bne L902A       ;then finish ISR
                lda fdcdat      ;else DRQ, read data register
L9028:
                bcs L9050       ;state 0: wait for IAM

L902A:
                and #$FC        ;mask off S1 DRQ/S0 busy
                sta L00A2       ;clear NMI busy flag, b6..2=status
                pla
                rti

L9030:                          ;state 8
                sta reg3        ;store data in I/O or Tube memory
L9033:
                inc L9030-L901B+intnmi+$01 ;increment LSB I/O address
                bne L903B       ;carry out to MSB
                inc L9030-L901B+intnmi+$02 ;fall through:
L903B:                          ;state 9
                dec L00A6       ;decrement LSB bytes remaining this sector
                bne L904E       ;borrow in from MSB
                dec L00A7
                bne L904E       ;if count underflows
                lda #L90A1-L9028-$02 ;then go to state 10 if more sectors
                dec L00A5       ;decrement sector count
                bne L904B       ;if no more sectors
                lda #L904E-L9028-$02 ;then go to state 13
L904B:
                sta L9028-L901B+intnmi+$01 ;set dispatch branch offset, fall through:
L904E:                          ;state 13
                pla             ;discard all further data from FDC
                rti

L9050:                          ;state 0
                cmp #$FE        ;if Index Address Mark reached
                beq L9058
                cmp #$CE        ;or variant due to sync error
                bne L904E
L9058:
                lda #L905C-L9028-$02 ;then go to state 1
                bne L904B

L905C:                          ;state 1
                sbc fdcdat      ;c=1, subtract data reg.; =0 if stable
                sta ytemp       ;this is the C parameter; save result
                lda #L9065-L9028-$02 ;go to state 2
                bne L904B

L9065:                          ;state 2
                lda #L9069-L9028-$02 ;discard H parameter
                bne L904B       ;go to state 3

L9069:                          ;state 3
                sbc sector      ;compare R with current sector
                ora ytemp       ;or difference with C result
                sta ytemp       ;ytemp=0 if sector numbers match
                lda #L9073-L9028-$02 ;go to state 4
                bne L904B

L9073:                          ;state 4
                lda #L9077-L9028-$02 ;discard N parameter
                bne L904B       ;go to state 5

L9077:                          ;state 5
                lda itemp       ;discard MSB ID CRC character
                sta L00A6       ;reset LSB number of bytes to read
                lda #L907F-L9028-$02 ;go to state 6
                bne L904B

L907F:                          ;state 6
                lda atemp       ;discard LSB ID CRC character
                sta L00A7       ;reset number of (short) pages to read
                lda #L9087-L9028-$02 ;go to state 7
                bne L904B

L9087:                          ;state 7
                cmp #$FB        ;if normal Data Address Mark reached
                beq L908F
                cmp #$F8        ;or Deleted Data Address Mark reached
                bne L904E       ;then proceed else exit ISR
L908F:
                sta vtemp+$00   ;store Data Address Mark found
                lda ytemp       ;if sector ID is incorrect
                bne L909B       ;then discard sector contents
                inc sector      ;else increment sector no. to match next
                lda #L9030-L9028-$02 ;and go to state 8
                bne L904B

L909B:                          ;discard sector contents
                inc L00A5       ;inc. sector count to include this interloper
                lda #L903B-L9028-$02 ;and go to state 9
                bne L904B

L90A1:                          ;state 10
                lda #L90A5-L9028-$02 ;discard MSB data CRC character
                bne L904B       ;go to state 11

L90A5:                          ;state 11
                lda #L90A9-L9028-$02 ;discard LSB data CRC character
                bne L904B       ;go to state 12

L90A9:                          ;state 12
                bne L904E       ;discard data until $00 found
                lda #L9050-L9028-$02 ;then go to state 0
                bne L904B

L90AF:                          ;Write sector register
                sta fdcsec
                cmp fdcsec      ;loop until FDC acknowledges new value
                bne L90AF
                rts

                .if SQUEEZE
                .else
                                ;unreachable code
                ldx #$00
                lda #$5A        ;set track reg. out of range
L90BC:
                sta fdctrk
                cmp fdctrk
                beq L90C9
                dex
                bne L90BC
L90C7:
                clc
                rts

L90C9:
                lda latch
                and #$03
                beq L90C7
                rts
                .endif

;Table of drive control latch values for drives 0..3
L90D1:
                .char $25,$26,$35,$36

;Table of WD 1770 commands
L90D5:
                .char $00,$10,$40,$50
                .char $80,$81,$83,$A0
                .char $A1,$C0,$E0,$F0

;Table of WD 1770 status code mask values
L90E1:
                .char $18,$18,$18,$18
                .char $3F,$1F,$1F,$5F
                .char $5F,$17,$1B,$5F

;Table of WD 1770 status codes
L90ED:
                .char $08,$10,$18,$20
                .char $40,$00

;Table of equivalent Intel 8271 result codes
L90F3:
                .char $0E,$18,$0C,$20
                .char $12,$00

;Addresses of format RLE tables
L90F9:
                .word L9121
L90FB:
                .word L90FD

L90FD:                          ;Double density format RLE table
                .char $3C
L90FE:                          ;lead-in to sector ID
                .char $0C,$03,$01
                .char $01,$01,$01,$01
                .char $01,$16,$0C,$03
                .char $01
L910A:                          ;sector data area (bytes)
                .char $FF
L910B:                          ;sector data area (pages)
                .char $01,$01
L910D:                          ;gap3
                .char $18
L910E:                          ;gap4
                .char $04
L910F:
                .char $4E,$00,$F5,$FE
L9113:                          ;CHRN values in sector header
                .char $00,$00,$00,$00
                .char $F7,$4E,$00,$F5
                .char $FB,$5A,$5A,$F7
                .char $4E,$4E

L9121:                          ;Single density format RLE table
                .char $10,$06,$00,$01
                .char $01,$01,$01,$01
                .char $01,$0B,$06,$00
                .char $01,$FF,$01,$01
                .char $13,$03
                .char $FF,$00,$00,$FE
                .char $00,$00,$00,$00
                .char $F7,$FF,$00,$00
                .char $FB,$E5,$E5,$F7
                .char $FF,$FF

L9145:                          ;Table of Intel 8271 commands
                .char $0A,$0B,$0E,$0F ;first four are write commands
L9149:
                .char $12,$13,$16,$17
                .char $1B,$1E,$1F,$23
                .char $29
L9152:                          ;Table of extension commands
                .char $20,$30

L9154:                          ;Table of equivalent WD 1770 commands
                .char $A0,$A0,$A1,$A1
                .char $80,$80,$81,$81
                .char $C0,$83,$83,$F0
                .char $10,$E0,$F0

L9163:                          ;OSWORD $7F = general read/write function (DFS)
                lda #$FF
                sta catdrv      ;forget catalogue in workspace
                stx userpt+$00  ;set up pointer to user's control block
                sty userpt+$01
                ldy #$0C        ;13 bytes to copy incl. space for format result
L916E:
                lda (userpt),y  ;copy bytes of user's control block
                sta work,y      ;to workspace
                dey             ;loop until 13 bytes copied
                bpl L916E
                ldx #L9152-L9145-$01 ;end of official command table
                lda work+$05    ;get number of parameters
                cmp #$0A        ;if equal to ten
                bne L9180
                ldx #L9154-L9145-$01 ;then search extension commands
L9180:
                lda work+$06    ;get command byte
                and #$3F        ;mask off drive select bits
                cmp #$3A        ;if =$3A write special registers
                beq L91D3       ;then branch
                cmp #$3D        ;if =$3D read special registers
                beq L91F3       ;then branch
                cmp #$35        ;if =$35 initialise
                bne L9193
                jmp L920E       ;then jump to handler

L9193:
                cmp L9145,x     ;compare user's command with table entry
                beq L919F       ;if match found then proceed with disc op
                dex             ;else loop until whole table scanned
                bpl L9193
L919B:                          ;command not found
                lda #$FE        ;return status $FE
                bmi L91C8       ;branch (always)

L919F:
                cmp #$23        ;if A=$0A,$0B,$0E,$0F or $23
                beq L91A7       ;(all write commands)
                cpx #L9149-L9145 ;then reject if 40-track flag set
                bcs L91B5
L91A7:
                lda work+$00    ;get drive number from control block
                bpl L91AD       ;if b7=1, reusing previous drive
                lda fdrive      ;then get current drive number
L91AD:
                and #$03        ;mask drive number in bits 1,0
                tay             ;transfer to y for use as index
                lda LC2DE,y     ;b7=40-track flag set on drive Y
                bmi L919B       ;if set then exit with status $FE
L91B5:
                ldy L9154,x     ;else fetch equivalent WD 1770 command
                sty work+$06    ;replace original in workspace
                cpy #$F0        ;if =$F0 write track
                bne L91C1
                jsr L9251       ;then convert CHRN table to track buffer
L91C1:
                ldx #<work      ;point XY to modified control block
                ldy #>work
                jsr L8BBF       ;call internal OSWORD $7F handler
                .if SQUEEZE
L920B:
                .endif
L91C8:
                pha             ;save result of disc operation
                lda work+$05    ;get number of parameters to command
                clc
                adc #$07        ;add 7 = offset of result byte
                tay             ;move to Y to use as index
                pla             ;restore result
                sta (userpt),y  ;store in caller's control block
                rts

L91D3:                          ;$3A Write special registers
                jsr L923E       ;validate bad track register address
                bcs L91DF       ;if not a bad track reg. then skip
                lda work+$08    ;2nd parm, register value
                sta LC28B,x     ;store in bad track array at X
                bcc L91EF       ;return result $00 (always)

L91DF:
                jsr L922D       ;validate current track register address
                bcc L920B       ;if invalid then return result $FE
                lda work+$08    ;else 2nd parm, register value
                ldy LC2DE,x     ;test 40-track flag for UNIT X
                bpl L91EC       ;if set
                asl a           ;then double track number
L91EC:
                sta LC288,x     ;store position of unit 0/1
L91EF:
                lda #$00        ;return result $00
                beq L920B

L91F3:                          ;$3D Read special registers
                jsr L923E       ;validate bad track register address
                bcs L91FD       ;if not a bad track reg. then skip
                lda LC28B,x     ;else read from bad track array at X
                bcc L920B       ;return track number as result (always)

L91FD:
                jsr L922D       ;validate current track register address
                bcc L920B       ;if invalid then return result $FE
                lda LC288,x     ;else get position of unit 0/1
                ldy LC2DE,x     ;test 40-track flag for UNIT X
                bpl L920B       ;if set
                lsr a           ;then halve track number
                .if SQUEEZE
                bpl L920B
                .else
L920B:
                jmp L91C8       ;can save 1 byte (BPL/BRA)
                .endif

L920E:                          ;$35 Initialise
                lda #$FF        ;preset result $FF (not $FE!)
                ldx #$00        ;preset offset 0 for unit 0
                ldy work+$07    ;1st parm, subcommand / parameter 0
                cpy #$10        ;$10 = load surface 0 bad tracks
                beq L921E       ;if match then set up unit 0
                cpy #$18        ;$18 = load surface 1 bad tracks
                bne L922A       ;if mismatch then return result $FF
                inx             ;else point to unit 1 bad track array
                inx             ;(can save time: LDX #$02)
L921E:
                lda work+$08    ;2nd parm, bad track 1
                sta LC28B,x
                lda work+$09    ;3rd parm, bad track 2
                sta LC28B+$01,x ;[BUG] current track not initialised
                lda #$00        ;return result $00
L922A:
                jmp L91C8

L922D:                          ;Validate current track register address
                ldx #$00        ;preset offset to 0
                lda work+$07    ;1st parm, register address
                cmp #$12        ;if =$12, unit 0 current track
                beq L923D       ;then accept with C=1, offset=0
                inx             ;else offset=1
                cmp #$1A        ;if =$1A, unit 1 current track
                beq L923D       ;then accept with C=1, offset=1
                lda #$FE        ;else result=$FE, unrecognised command
                clc             ;return C=0, invalid address
L923D:
                rts

L923E:                          ;Validate bad track register address
                lda work+$07    ;1st parm, register address
                and #$F6        ;accept n,n+1,n+8,n+9
                cmp #$10        ;if not $10,$11,$18,$19
                sec             ;then exit C=1 invalid address
                bne L9250
                lda work+$07    ;get back address
                lsr a           ;move b3, unit select
                lsr a           ;to b1 (b0=0 from previous test)
                ora work+$07    ;put bad track slot no. in b0
                and #$03        ;mask b1=unit, b0=bad track slot no.
                tax             ;to X as bad track array offset
L9250:
                rts

L9251:                          ;Convert CHRN table to track buffer
                jsr getlsz      ;get start and size of user memory
                lda work+$01    ;get LSB of caller's data address (CHRN table)
                sta temp+$00    ;set up LSB of data pointer
                sta atemp+$00   ;and LSB of track buffer pointer
                clc
                adc #$80        ;add 128 to it
                sta xtemp+$00   ;set up LSB of RLE table pointer
                lda work+$02    ;get MSB of caller's data address
                sta temp+$01    ;set up MSB of data pointer
                php             ;save carry flag from ADC
                jsr L8EF4       ;set Tube presence flag
                bmi L9271       ;if Tube absent
                lda work+$03    ;or high bytes = $FF
                ora work+$04    ;of source address
                cmp #$FF
                bne L9278
L9271:
                lda temp+$01    ;then atemp[1]=max(OSHWM,work[2])
                cmp frpage
                bcs L927B
L9278:
                lda frpage      ;else source on Tube; atemp[1]=OSHWM
L927B:
                plp
                sta atemp+$01   ;but now xtemp[]=atemp[]+$0080
                adc #$00        ;and     atemp[]=atemp[]+$0100
                sta xtemp+$01   ;i.e. 128/256 bytes above CHRN table
                inc atemp+$01   ;[BUG]clobbers user memory!
                lda work+$00    ;if b7=1, reusing previous drive
                bpl L928A
                lda #$00        ;then format drive 0, SD! (C=0)
L928A:
                rol a           ;shift bit 5 of drive parameter into carry
                rol a
                rol a
                sta LC28A       ;save b4..2 (and drive) as disc op modifier
                ldx #L90FB-L90F9 ;point to SD table address
                rol a           ;if b3, force DD, was set
                bmi L9297
                ldx #L90F9-L90F9 ;then point to DD table address
L9297:
                lda L90F9+$00,x ;set up pointer to RLE table in ROM
                sta vtemp+$00
                lda L90F9+$01,x
                sta vtemp+$01
                ldy #L9121-L90FD-$01 ;40 bytes to copy:
L92A3:
                lda (vtemp),y   ;copy RLE table from ROM
                sta (xtemp),y   ;to user memory
                dey             ;loop until 40 bytes copied
                bpl L92A3
                .if BUGFIX
                ldy #$01        ;size code %000 = 1 * 128 bytes
                lda work+$09
                bpl code1
                ldy #$10        ;size code %100 = 16 * 128 bytes = 2K
code1:
                sty vtemp+$00   ;store starter sector size in workspace
                asl a           ;put b6 of parameter = b1 of code in N
                bpl code0       ;if set
                asl vtemp+$00   ;then multiply sector size by 4
                asl vtemp+$00
code0:
                asl a           ;put b5 of parameter = b0 of code in N
                bpl coded       ;if set
                asl vtemp+$00   ;then multiply sector size by 2
coded:
                lsr a           ;restore sector count to bits 5..0
                lsr a
                and #$1F        ;mask sector count
                sta etemp       ;save as counter
                lda vtemp+$00   ;get number of 128-byte units per sector
                lsr a           ;halve it; 128-byte remainder in C
                ldy #L910A-L90FD ;point to data area (pages) count
                sta (xtemp),y   ;store in RLE table
                iny             ;point to data area (bytes) count
                lda #$00        ;set A=$00 no bytes
                ror a           ;or $80 if data area is 128 bytes
                sta (xtemp),y   ;store in RLE table
                .else
                iny             ;y=$00
                sty vtemp+$00   ;zero size code receiver
                lda work+$09    ;3rd parm, sector size+count
                pha             ;save sector count
                and #$E0        ;mask size code in b7..b5
                bne L92B6       ;all codes >0 indicate a whole no. of pages
                lda #$10        ;code 0 indicates 128-byte sectors:
L92B6:
                asl a           ;shift the three size code bits
                rol vtemp+$00   ;into the size code receiver
                asl a
                rol vtemp+$00
                asl a           ;now A=$00 or A=$80
                rol vtemp+$00
                ldy #L910A-L90FD ;point to data area (bytes) count
                sta (xtemp),y   ;store A in RLE table
                lda vtemp+$00   ;get size code in b2..b0
                iny             ;point to data area (pages) count
                sta (xtemp),y   ;set as count of pages
                                ;[BUG] not decoded! code %011 writes 768 bytes
                pla
                and #$1F        ;extract b5..b0
                sta etemp       ;store number of sectors on track
                .endif
                lda work+$08    ;2nd parm, gap3
                ldy #L910D-L90FD ;point to gap3 count
                sta (xtemp),y   ;store in RLE table
                lda work+$0B    ;5th parm, gap1
                ldy #$00        ;point to gap1 count
                sta (xtemp),y   ;store in RLE table
                tya
                .if SQUEEZE
                .else
                sta ztemp       ;redundant
                .endif
                jsr L9387       ;append run from table to track buffer
                jsr L8EF4       ;test Tube presence
                bmi L931B       ;if Tube absent then skip
                lda work+$03    ;if high bytes are $FF
                and work+$04    ;i.e. address is not a Tube address
                cmp #$FF
                beq L931B       ;then skip
                .if BUGFIX
                .else
                lda #$FF        ;else set high bytes to $FF
                sta work+$03    ;[BUG] WHAT??
                sta work+$04    ;Tube transfer starts from $FFFFxxxx
                .endif
                jsr clatub
                ldx #<(work+$01)
                ldy #>(work+$01)
                tya             ;a=0, bytes to host
                jsr tubadr      ;must delay 24 us from return to first LDr
                ldx atemp+$01   ;set temp[1]=host src addr or OSHWM
                dex
                stx temp+$01
                lda etemp       ;get number of sectors on track
                asl a
                asl a           ;* 4 = number of CHRN bytes; C=0
                tax             ;put in X as counter
                ldy #$00        ;start at beginning of local table (9.5 us):
L9309:
                lda #$07        ;wait 15.5 us (C=0)/18.0 us (C=1)
L930B:
                sbc #$01
                bne L930B       ;c=1 at end of loop
                lda reg3        ;get CHRN byte from Tube FIFO 3
                sta (temp),y    ;store in local table
                iny             ;increment offset
                dex             ;decrement counter
                bpl L9309       ;loop until CHRN acquired (26.5 us/byte)
                jsr L8F2F       ;release Tube
                .if BUGFIX
                lda #$FF        ;set high bytes to $FF
                sta work+$03    ;track buffer is in I/O memory
                sta work+$04
                .endif
L931B:
                lda atemp+$01
                sta work+$02    ;work[2] = atemp[1] w/o increments
L931F:
                ldy #L9113-L90FD ;point to sector ID in RLE table (C byte)
                ldx #$00        ;zero offset for indexed indirect load:
L9323:
                lda (temp,x)    ;get byte of CHRN table
                sta (xtemp),y   ;overwrite CHRN fields in RLE table
                inc temp        ;increment LSB of CHRN table pointer
                bne L932D       ;carry out to MSB
                inc temp+$01
L932D:
                iny             ;increment offset into RLE table
                cpy #L9113-L90FD+$04 ;have we reached the CRC insertion code?
                bne L9323       ;if not then update the rest of CHRN
                lda #L90FE-L90FD ;else start at ID lead-in sequence
                sta vtemp+$00   ;and add 13 entries including data area (bytes):
L9336:
                lda vtemp+$00   ;get current offset into RLE table
                cmp #L910B-L90FD ;have we reached the data area (pages)?
                bne L9341       ;if not then append rest of preamble
                jsr L9368       ;else append required number of pages of data
                beq L9344       ;and skip next instruction (always)

L9341:
                jsr L9387       ;append run from table to track buffer
L9344:
                inc vtemp+$00   ;increment RLE table offset
                lda vtemp+$00   ;get its current value
                cmp #L910E-L90FD ;are we now at the last entry (gap4)?
                bne L9336       ;if not then loop
                .if SQUEEZE
                .else
                inc ztemp       ;redundant
                .endif
                dec etemp       ;else decrement number of sectors remaining
                bne L931F       ;loop until all sectors added
                tay             ;transfer RLE table offset to Y
                lda #$0E        ;3584 bytes = SD track length 3125 + 459
                bit LC28A       ;if formatting double density
                bvc L935C
                lda #$1A        ;then 6656 bytes = DD track length 6250 + 406
L935C:
                clc
                adc work+$02    ;add MSB start of track buffer = generous end point
                sbc atemp+$01   ;subtract end of last sector
                bcs L9365       ;if track short then pad with gap4 [BUG] may be 0!
                lda #$01        ;else $01 = write 256 bytes:
L9365:                          ;Append byte from table x (A*256) to track buffer
                sta (xtemp),y   ;store run length in RLE table
                tya             ;copy offset to A:
L9368:                          ;Append run x 256 from table to track buffer
                jsr L9379       ;get run from RLE table
                beq L9378       ;if run length = $00 then exit, else:
                stx vtemp+$01   ;store run length in counter
                ldx #$00        ;$00 = repeat 256 times
L9371:
                jsr L938C       ;append A x X to track buffer
                dec vtemp+$01   ;decrement counter
                bne L9371       ;loop until 256*X bytes appended
L9378:
                rts             ;returns Z=1

L9379:                          ;Get run from RLE table
                tay             ;offset in A, transfer to Y
                lda (xtemp),y   ;get run length into X
                tax
                tya             ;put offset back in A
                clc             ;add run table length to point to values
                adc #L910F-L90FD
                tay             ;put new offset in Y
                lda (xtemp),y   ;get value in A
                cpx #$00        ;test run length; Z=1 if zero
                rts

L9387:                          ;Append run from table to track buffer
                jsr L9379       ;get run from RLE table
                beq L9399       ;if run length = $00 then exit, else:
L938C:                          ;Append A x X to track buffer
                ldy #$00        ;clear offset, start at (atemp)
L938E:
                sta (atemp),y   ;write value in A to track buffer
                inc atemp+$00   ;increment low byte of address
                bne L9396       ;carry out to high byte
                inc atemp+$01
L9396:
                dex             ;decrement repeat count
                bne L938E       ;loop until X copies appended
L9399:
                rts

                .if SQUEEZE
title:                          ;*TITLE
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr setdef      ;set current drive and dir = default
                jsr getdir      ;load volume catalogue L4
                ldx #$0B        ;first offset to store = 11
                lda #$00        ;set title to 12 NULs:
clrti0:
                jsr titwit      ;store character of title
                dex             ;loop until 12 characters stored
                bpl clrti0
titset:
                inx             ;x=$FF, set X=0 offset of first character
                jsr rdchr       ;call GSREAD
                bcs titend      ;if end of argument write catalogue
                jsr titwit      ;else store character of title
                cpx #$0B        ;is this the twelfth character written?
                bcc titset      ;if not then loop to write more, else:
titend:
                .endif
dirout:                         ;Write volume catalogue L4
                lda cycno       ;add 1 to BCD catalogue cycle number
                clc             ;[D]reordered
                sed
                adc #$01
                sta cycno
                cld
L93A5:                          ;Write volume catalogue as-is
                ldy #$A0        ;command = $A0, write sector
                bne L93C2       ;branch (always)

L93A9:                          ;Load catalogue with execute privilege
                ldy #$81        ;command = $80, read sector, b0 repurposed
                bne L93C2       ;branch (always)

L93AD:                          ;Ensure catalogue loaded with execute privilege
                ldy #$81        ;command = $80, read sector, b0 repurposed
                bne L93B3       ;branch (always)

L93B1:                          ;Ensure current volume catalogue loaded
                ldy #$80        ;command = $80, read sector
L93B3:
                bit fdcsta      ;test FDC status register
                bpl L93C2       ;if motor is off then load catalogue
                lda catdrv      ;else get drive number of loaded catalogue
                cmp fdrive      ;compare with current drive
                bne L93C2       ;if unequal then load volume catalogue
                rts             ;else exit

                .if SQUEEZE
getdir:
                jsr savita      ;save AXY
                .endif
L93C0:                          ;Load catalogue
                ldy #$80
L93C2:                          ;Transfer catalogue
                jsr L94EA       ;clear high OSWORD $7F control block
                sty LC290+$06   ;store WD 1770 command at offset 6
                lda fdrive      ;get current drive
                sta LC290+$00   ;store at offset 0
                lda #$02        ;512 bytes to transfer
                sta LC290+$09
                lda #>dirlow    ;set data address = $FFFFC000
                sta LC290+$02
                dec LC290+$03   ;set address high bytes = $FF
                dec LC290+$04
                jsr L93F9       ;transfer data and report errors L4
                lda fdrive      ;get current drive
                sta catdrv      ;set drive number of loaded catalogue
                rts

L93E6:                          ;Check for escape condition
                bit escflg      ;test escape flag
                bpl L93F8       ;if ESCAPE not pressed then return
escape:
                jsr ackesc      ;else acknowledge escape condition
                jsr fstrng      ;and raise "Escape" error.
                .char $11
                .text "Escape"
                .char $00

L93F8:
                rts

L93F9:                          ;Transfer data and report errors L4
                jsr L94CA       ;ensure not writing to 40-track mode drive
                lda #$06        ;5 attempts
                sta LC29E
                jsr L93E6       ;check for escape condition
L9404:
                lda LC290+$07   ;1st parm, track number
                ldx LC290+$00   ;get drive number to transfer to
                ldy LC2DE,x     ;test 40-track flag for said drive
                bpl L9410       ;if set
                asl a           ;then double track number
L9410:
                ldy #$18        ;preset result $18 = Sector not found
                cmp #$50        ;if track no. >80 then return this
                bcs L9475
                ldx #<LC290     ;else point XY to high OSWORD $7F control block
                ldy #>LC290
                jsr L8BBC       ;call internal OSWORD $7F handler
                tay             ;test result code
                beq L93F8       ;if no errors then return
                bmi escape      ;if escape key pressed then raise Escape error
                cmp #$12        ;else if result = $12, write protect
                beq L947A       ;then raise "Disc read only" error
                cmp #$20        ;else if result = $20, Deleted data found
                bne L9441
                lda LC290+$06   ;then test bit 0 of WD 1770 command
                ror a           ;in read sector commands, b0 unused and repurposed
                bcs L93F8       ;as execute privilege bit.  If not set when needed
                jsr fstrng      ;then raise "Execute only" error.
                .char $BC
                .text "Execute only"
                .char $00

L9441:
                cmp #$18        ;$18 = sector not found
                bne L9470       ;if another error then retry operation
                lda LC28A       ;else test disc operation modifier
                cmp #$04        ;if loading catalogue during boot sequence
                bne L945D
                ldx LC290+$06   ;and command = $81 read sector with exec privilege
                cpx #$81
                bne L945D
                lda #$FF        ;then invert first bad track register of unit 0
                eor LC28B+$00   ;putting it out of range
                sta LC28B+$00   ;but preserving its value
                bcs L9470       ;branch (always)

L945D:
                ldx track       ;otherwise if current track > 0
                beq L9470
                rol a           ;then move BIT 6 of disc op modifier
                and #$80        ;to bit 7, and mask it
                ldx LC290+$00   ;get drive number of OSWORD $7F operation
                eor LC2DE,x     ;toggle 40-track flag for drive if b6 was set
                sta LC2DE,x     ;update 40-track flag for drive
                jsr L94CA       ;ensure not writing to 40-track mode drive
L9470:
                dec LC29E       ;decrement retry counter
                bne L9404       ;loop until counter reaches zero
L9475:
                tya             ;y=result code. move to A:
dknern:                         ;Translate result code to error
                cmp #$12        ;if result = $12, write protect, then:
                bne dkerr0
L947A:                          ;Raise "Disc read only" error
                jsr dskmsg
                .char $C9
                .text "read only"
                .char $00

dkerr0:                         ;Raise "Disc fault ..." error
                pha             ;save result code in A
                jsr dskmsg      ;start "Disc ..." error
                .char $00       ;error number $00, empty string
                nop             ;not $00 = return, don't BRK
                jsr gstrng      ;append "fault " to error message
                .char $C7       ;replace error number with $C7
                .text "fault "
                nop             ;not $00 = return, don't BRK
                pla             ;restore result code
                jsr L94DA       ;append hex byte to error message
                jsr gstrng      ;append " at :" to error message
                .char $00       ;replace error number with $00
                .text " at :"
                lda fdrive      ;get current drive
                jsr L94E2       ;append hex byte to error message
                jsr gstrng      ;append space to error message
                .char $00
                .text " "
                lda track       ;get track number of OSWORD $7F command
                bit LC28A       ;test 40-track flag of current drive
                bpl L94B8       ;if set
                lsr a           ;then double track number
L94B8:
                jsr L94DA       ;append hex byte to error message
                jsr gstrng      ;append "/" to error message
                .char $00
                .text "/"
                lda sector      ;get sector number of OSWORD $7F command
                jsr L94DA       ;append hex byte to error message
                jsr gstrng      ;append empty string to error message
                .char $C7       ;error number $C7
                .char $00       ;jump to BRK to raise error

L94CA:                          ;Ensure not writing to 40-track mode drive
                lda LC290+$06   ;get command from high OSWORD $7F control block
                cmp #$A0        ;if $A0 write sector, $F0 write track
                bcc L94E9       ;OR $C0 read address
                ldx LC290+$00   ;then get drive number of OSWORD $7F operation
                lda LC2DE,x     ;test 40-track flag for drive
                bmi L947A       ;if set then raise "Disc read only" error
                rts             ;else exit

L94DA:                          ;Append hex byte to error message
                pha
                jsr sfour       ;shift A right 4 places
                jsr L94E2       ;print top nibble of byte
                pla             ;restore bottom nibble:
L94E2:
                jsr digut1      ;convert hex nibble to ASCII
                sta errbuf,x    ;append character to error message
                inx             ;and increment offset
L94E9:
                rts

L94EA:                          ;Clear high OSWORD $7F control block
                ldx #$0D
                lda #$00
L94EE:
                sta LC290-$01,x
                dex
                bne L94EE
                lda #$05
                sta LC290+$05
                rts

whlim:                          ;FSC  7 = range of valid file handles
                ldx #$11
                ldy #$15
shtal1:
                rts

wfdie:                          ;FSC  6 = new filing system starting up
                jsr savita      ;save AXY
                lda #$77        ;call OSBYTE $77 = close *SPOOL/*EXEC files
                jsr osbyte
                jmp relmem      ;[D]vacate absolute workspace

                .if SQUEEZE
                .else
                                ;unreachable code
                lda #$20
                sta dufflg
                .endif
close2:                         ;Close all files
                .if BUGFIX
                lda #$77        ;call OSBYTE $77 = close *SPOOL/*EXEC files
                jsr osbyte
                .else
                jsr wfdie       ;close *SPOOL/*EXEC files and vacate workspace
                                ;[BUG] clears dufflg
                .endif
shtall:
                lda #$00        ;set channel workspace pointer = $00:
shtal0:
                clc             ;add $20 to point to next channel
                adc #$20
                beq shtal1      ;if =0 then exit (close 5 files $A0..20).
                tay
                jsr vshut
                bne shtal0

wshut:                          ;Close a file/all files
                lda #$20        ;$20 = write EXT to catalogue if updated
                sta dufflg
                tya             ;if handle = 0
                beq close2      ;then close all files
                .if BUGFIX
wshut1:
                .endif
                jsr dcrych      ;else convert to pointer, if valid ($11..17)
vshut:
                pha
                jsr cheeky      ;validate workspace offset
                bcs vshutq      ;if channel invalid or closed then exit
                lda seqbit,y    ;else get bit mask corresponding to channel
                eor #$FF        ;invert it, bit corresponding to channel =0
                and dcbmap      ;clear bit of channel open flag byte
                sta dcbmap      ;update flag byte
                lda seqflg,y    ;get channel flags
                and #$60        ;if either buffer or EXT changed
                beq vshutq
                jsr vlook       ;then ensure open file still in drive
                lda seqflg,y    ;if EXT changed
                and dufflg      ;and this is a close operation
                beq vshdd
                ldx seqwb       ;then set X = catalogue pointer
                lda seqlla,y    ;copy low word of EXT to length in catalogue
                sta cathig+$04,x
                lda seqlma,y
                sta cathig+$05,x
                lda seqlha,y    ;get high byte of EXT
                jsr lfour       ;shift A left 4 places
                eor cathig+$06,x ;replace b5,b4 of top bits with b5,b4 from A
                and #$30
                eor cathig+$06,x
                sta cathig+$06,x ;store top bits back in catalogue
                jsr dirout      ;write volume catalogue
                ldy dcby        ;put channel workspace pointer in Y
vshdd:
                jsr bflush      ;ensure buffer up-to-date on disc L6
vshutq:
                ldx seqwx       ;restore X on entry
                pla             ;restore A on entry
                rts

vlook:                          ;Ensure open file still in drive
                jsr setq        ;set current vol/dir from open filename:
vlook3:                         ;Ensure open file still on current drive
                ldx #$06        ;start at seventh character of leaf name:
vshutl:
                lda seqcat+$0C,y ;copy leaf name of file to current leaf name
                sta wrknam,x
                dey             ;skip odd bytes containing length and addrs
                dey             ;select previous character of leaf name (Y>0)
                dex             ;decrement offset in current leaf name
                bpl vshutl      ;loop until 7 characters copied (X=7..1)
                jsr lookw       ;search for wrknam in catalogue
                bcc dskchn      ;if file not found then raise "Disk changed"
                sty seqwb       ;else save offset in catalogue
                ldy dcby        ;put channel workspace pointer in Y
cksam0:
                rts

setq:                           ;Set current drive/dir from open filename
                lda seqlok,y    ;get directory character of open file
                and #$7F        ;mask off b7 =channel file locked bit
                sta qualif      ;set as current directory
                lda seqflg,y    ;get drive containing open file
                jmp dodriv      ;select drive in A and exit

chksam:                         ;Ensure disc not changed
                jsr savita      ;save AXY
                lda cycno       ;get cycle number of last catalogue read
                jsr getdir      ;load volume catalogue L4
                cmp cycno       ;compare with freshly loaded cycle number
                beq cksam0      ;return if equal, else:
dskchn:                         ;Raise "Disk changed" error.
                jsr dskmsg
                .char $C8
                .text "changed"
                .char $00

wfind:                          ;OSFIND
                and #$C0
                bne wfind0      ;if A>=$40 then open a file
                jsr savita      ;else save AXY
                jmp wshut       ;and close a file/all files.

wfind0:                         ;Open a file
                jsr savit       ;save XY
                stx work+$00
                sty work+$01
                sta atemp       ;store file open mode in temporary var.
                bit atemp       ;set N and V from temporary variable
                php
                jsr frmnam      ;set current file from argument pointer
                jsr clrwld      ;disallow wildcard characters in filename
                jsr lookup      ;search for file in catalogue
                bcs newdcb      ;if found then set up channel
                .if SQUEEZE
                lda #$00
                plp             ;else if opening for read or update
                bvc vnewo       ;then existing file was expected, return A=0
                .else
                plp             ;else if opening for read or update
                bvc vnewo       ;(i.e. OSFIND call no. b6=1)
                lda #$00        ;then existing file was expected, return A=0
                .endif
                rts

vnewo:
                php             ;else opening new file for output.
                .if SQUEEZE
                .else
                lda #$00        ;can save 2 bytes (swap BVC/LDA)
                .endif
                ldx #$07
vnewl:
                sta wrkcat,x    ;clear load, exec, start and length = 0
                sta hiwork,x
                dex
                bpl vnewl
                dec exelo       ;set exec address = $FFFFFFFF
                dec exehi
                dec exlow+$02
                dec exlow+$03
                lda #$40        ;initial length = $4000 = 16 KiB
                sta endhi
                jsr dirdo       ;create file from OSFILE block
                                ;[BUG]even if no channels available:
newdcb:                         ;enter with Y=catalogue offset of open file
                plp             ;restore flags containing channel open mode
                php
                bvs find3       ;if opening for output (OSFIND b6=0)
                jsr chklok      ;then ensure file not locked
find3:
                jsr cmpfil      ;find free channel and check for clashes
                bcc find1       ;if file not open then continue
find2:
                lda seqrdo,y    ;else test if the channel is open read-write
                bpl filopn      ;if so, reopening is a conflict; raise error
                plp             ;else if reopening a r-o channel read-write
                php             ;(i.e. channel b7=1, OSFIND call no. b7=1)
                bmi filopn      ;then this also conflicts; raise error
                jsr nxtfil      ;else find any other channels open on this file
                bcs find2       ;if another channel found then loop
                                ;NB loop is redundant; can fall through instead
find1:
                ldy dcby        ;else get free channel workspace offset from cmpfil
                bne seqnul      ;if valid then set up channel
                jsr estrng      ;else raise "Too many open" error.
                .char $C0
                .text "Too many open"
                .char $00

filopn:                         ;Raise "Open" error.
                jsr estrng
                .char $C2
                .text "Open"
                .char $00

seqnul:
                lda #$08        ;set counter = 8
                sta seqwc
fillda:
                lda catlow,x    ;copy name and attributes of file
                sta seqcat,y    ;to bottom half of channel workspace
                iny
                lda cathig,x
                sta seqcat,y
                iny
                inx
                dec seqwc       ;loop until 8 byte pairs copied
                bne fillda
                ldx #$10        ;16 bytes to clear
                lda #$00
filldb:
                sta seqmap,y    ;clear top half of channel workspace
                iny
                dex
                bne filldb      ;loop until 16 bytes cleared
                lda dcby        ;put channel workspace pointer in A
                tay
                jsr sfive       ;shift A right 5 places, A=1..5, C=0
                adc #(>slots)-$01 ;add 17; A=$12..16
                sta seqbuf,y    ;store page number of channel buffer
                lda dcbbit      ;get bit mask corresponding to channel
                sta seqbit,y    ;store in channel workspace
                ora dcbmap      ;set that bit in channel open flags byte
                sta dcbmap      ;marking this channel open
                lda seqll,y     ;test LSB of file length
                adc #$FF        ;c=0 from last ADC; c=1 if partial sector
                lda seqlm,y     ;copy 2MSB length to allocation
                adc #$00        ;rounding up to whole sector
                sta seqem,y
                lda seqlh,y     ;get top bits exec/length/load/start sector
                ora #$0F        ;mask off load/start sector
                adc #$00        ;carry out to length in bits 5 and 4
                jsr isolen      ;extract b5,b4 of A
                sta seqeh,y     ;store MSB allocation
                plp             ;restore OSFIND call number to N and V
                bvc vfindo      ;if opening for output then branch
                bmi vfind1      ;if opening for update then branch
                lda #$80        ;else opening for input.
                ora seqrdo,y    ;set b7=1 of seventh char of leaf name
                sta seqrdo,y    ;marking channel read-only.
vfind1:
                lda seqll,y     ;input or update; set EXT = length of file
                sta seqlla,y
                lda seqlm,y
                sta seqlma,y
                lda seqlh,y
                jsr isolen      ;extract b5,b4 of A
                sta seqlha,y
vfinxx:
                lda fdrive      ;get current drive
                ora seqflg,y    ;OR with channel flags in high nibble
                sta seqflg,y    ;set drive of open file in low nibble
                tya             ;set A=workspace pointer
                jsr sfive       ;shift A right 5 places
                ora #$10        ;return A=file handle $11..15.
                rts

vfindo:                         ;opening for output
                lda #$20        ;set channel flag b5=1, "EXT changed"
                sta seqflg,y    ;to truncate file's initial allocation
                bne vfinxx      ;branch to return file handle (always)

nxtfil:                         ;Find any other channels open on this file
                txa             ;x=catalogue offset of open file, save
                pha
                jmp cmpfl1      ;jump to decrement workspace offset and loop

cmpfil:                         ;Find free channel and check for clashes
                lda #$00        ;preset workspace pointer = $00
                sta dcby        ;to return if all channels in use / none free
                lda #$08        ;start at $08, open flag mask for channel $15
                sta ytemp       ;save as shift register
                tya             ;y=catalogue offset of open file, move to X
                tax
                ldy #$A0        ;start at channel workspace offset $A0:
cmpfl4:
                sty itemp       ;save workspace offset
                txa             ;save catalogue offset
                pha
                lda #$08        ;set counter = 8
                sta xtemp
                lda ytemp       ;get open flag mask for current channel
                bit dcbmap      ;test channel open flag
                beq cmpfl5      ;if Z=1 channel closed then skip channel
                lda seqflg,y    ;else get drive of open file
                eor fdrive      ;compare with current drive
                and #$03        ;mask off channel flags, compare drives only
                bne cmpfl1      ;if unequal then no match
cmpfl0:
                lda catlow,x    ;get character of filename to compare
                eor seqcat,y    ;compare with char of open filename
                and #$7F        ;ignore bit 7
                bne cmpfl1      ;if unequal then no match
                inx             ;skip to next character of comparand
                iny             ;skip even addresses cont'g file attributes
                iny             ;skip to next character of open filename
                dec xtemp       ;decrement counter
                bne cmpfl0      ;loop until 7 leaf name chars + dir tested
                sec             ;return C=1 matching filename found.
                bcs cmpfl2      ;branch to finish (always)

cmpfl5:                         ;channel closed
                sty dcby        ;set offset of lowest free channel
                sta dcbbit      ;set open mask bit of lowest free channel:
cmpfl1:                         ;no match
                sec             ;subtract $20 from channel workspace pointer
                lda itemp
                sbc #$20
                sta itemp
                asl ytemp       ;shift channel open bit mask to next channel down
                clc             ;return C=0 no match:
cmpfl2:
                pla             ;restore catalogue offset
                tax
                ldy itemp       ;return Y=free channel offset or Y=0 none free
                lda ytemp       ;test channel open bit mask
                bcs cmpfl3      ;if matching filename found return C=1
                bne cmpfl4      ;else if more channels to compare then loop
cmpfl3:
                rts             ;else return C=0 no channels match open file.

ensur:                          ;OSARGS A=$FF ensure file/all files
                jsr wopa        ;have A=0 returned on exit
nsrnow:                         ;Ensure file/all files up-to-date on disc (flush)
                lda dcbmap      ;save channel open flags
                pha
                lda #$00        ;$00=this is an ensure operation
                sta dufflg      ;do not update EXT in catalogue
                tya             ;if Y>0
                bne ensur1      ;then close file to ensure contents
                jsr shtall      ;else close all files to ensure contents
                beq ensur0      ;and restore channel open flags (always)

ensur1:                         ;OSARGS A=$FF, Y>0 ensure file up-to-date
                .if BUGFIX
                jsr wshut1      ;ensure a file
                .else
                jsr wshut       ;close a file/all files [BUG] sets dufflg again
                .endif
ensur0:
                pla             ;restore channel open flags.
                sta dcbmap
                rts

wopa:                           ;Have A=0 returned on exit
                pha             ;caller called Save AXY, A was at $0105,S
                txa             ;save caller's AX
                pha             ;these two bytes plus return address make 4
                lda #$00        ;superroutine's A is thus 5+4 = 9 bytes down
                tsx
                sta stack+$09,x
                pla             ;restore caller's AX
                tax
                pla
                rts

wargs:                          ;OSARGS
                jsr savita      ;save AXY
                cmp #$FF        ;if A=$FF
                beq ensur       ;then ensure file up-to-date on disc
                cpy #$00        ;else if Y = 0
                beq wargs1      ;then perform Y = 0 functions
                cmp #$04        ;else file handle in Y.  if A>=4
                bcs wargsr      ;then return
                jsr wopa        ;else have A=0 returned on exit
                cmp #$03        ;if A=3
                beq L97A9       ;then set EXT
                cmp #$01        ;else compare A - 1
                bne vradr       ;if A=0 or A=2 then return PTR or EXT
                jmp vstar       ;else A=1 set PTR

wargs1:                         ;OSARGS Y=0
                cmp #$02        ;if A>=2
                bcs wargsr      ;then return
                jsr wopa        ;else have A=0 returned on exit
                beq rdfsno      ;if A=0 then return FS number, else:
                                ;unreachable code
                                ;as FileSwitch intercepts OSARGS 1,0
                lda #$FF        ;OSARGS A=1, Y=0 read command line tail
                sta $02,x       ;command line is always in I/O processor
                sta $03,x       ;so return a host address, $FFFFxxxx
                lda linadr+$00  ;copy address of command line arguments
                sta $00,x       ;from workspace where stored by FSC 2..4
                lda linadr+$01  ;to user's OSARGS block
                sta $01,x       ;return A=0
wargsr:
                rts

rdfsno:                         ;OSARGS A=0, Y=0 return filing system number
                lda #$04        ;a=4 for Disc Filing System
                tsx
                sta stack+$05,x ;save in stack to return via Restore AXY
                rts

vradr:                          ;OSARGS A=0/2, Y>0 return PTR/EXT
                jsr dcrych      ;ensure file handle valid and open
                sty dcby        ;save channel workspace pointer
                asl a           ;A=0 or 2, multiply by 2
                adc dcby        ;A=0 offset of PTR, A=4 offset of EXT
                tay             ;add offset to channel workspace pointer
                lda seqpl,y     ;copy PTR or EXT
                sta $00,x       ;to 3 LSBs of user's OSARGS block
                lda seqpm,y
                sta $01,x
                lda seqph,y
                sta $02,x
                lda #$00        ;clear MSB of user's OSARGS block
                sta $03,x       ;PTR <= EXT < 16 MiB
                rts

L97A9:                          ;OSARGS A=3, Y>0 set EXT
                jsr dcrych      ;ensure file handle valid and open
                .if BUGFIX
                jsr scmp        ;compare EXT - requested EXT
                bcs trunc_      ;if EXT < request
                lda seqph,y     ;then extend file. save current PTR
                pha
                lda seqpm,y
                pha
                lda seqpl,y
                pha
                jsr vstara      ;set PTR = request, extending file
                pla             ;restore previous PTR
                sta seqpl,y
                pla
                sta seqpm,y
                pla
                sta seqph,y
                jsr vstarc      ;update buffer-contains-PTR channel flag
trunc_:
                lda seqrdo,y    ;else get channel read-only bit in b7
                bmi freado      ;if set then raise "Read only"
                                ;(or BMI dfsfix: pretend file is shorter)
                ora seqlok,y    ;get channel file locked bit in b7
                bmi flockd      ;if set then raise "File locked"
                                ;(or BMI dfsfix)
                lda #$20        ;b5=1, EXT has changed
                jsr setbit      ;set channel flag bits (A = OR mask)
dfsfix:
                lda $00,x       ;copy 3 LSBs of user's OSARGS block
                sta seqlla,y    ;to EXT
                lda $01,x
                sta seqlma,y
                lda $02,x
                sta seqlha,y
                txa             ;save OSARGS block pointer
                pha
                tya             ;a=y, compare with extent
                jsr pcmp        ;compare PTR - EXT
                pla             ;restore OSARGS block pointer
                tax
                bcc args3x      ;if PTR >= EXT
                jsr vstara      ;then set PTR = request = EXT
args3x:
                lda #$EF        ;clear b4=0, EOF warning not given
                jmp clrbit      ;clear channel flag bits (A = AND mask)

freado:
                jmp vbput2

flockd:
                jmp delprt

                .else
                lda $00,x       ;copy 3 LSBs of user's OSARGS block
                sta seqlla,y    ;to EXT
                lda $01,x       ;[BUG] may overlap next file
                sta seqlma,y    ;[BUG] extended part of file not zeroed
                lda $02,x       ;[BUG] EXT-changed flag not set
                sta seqlha,y
                rts

                .if BUGFIX
args3x:
                lda #$EF        ;clear b4=0, EOF warning not given
                jmp clrbit      ;clear channel flag bits (A = AND mask)
                .endif
                .endif

cheeky:                         ;Validate workspace offset
                pha             ;save A
                stx seqwx       ;save X in workspace
                tya             ;transfer workspace offset to A
                and #$E0        ;mask bits 7..5, offset = 0..7 * $20
                sta dcby        ;save channel workspace offset
                beq chekyz      ;if offset = 0 (i.e. channel $10) return C=1
                jsr sfive       ;else shift right five times, divide by 32
                tay             ;transfer to Y for use as counter
                lda #$00        ;clear channel open bit mask
                sec             ;set C=1 so first mask will be $80 for ch.$11:
chekya:
                ror a           ;shift channel open bit mask to next channel up
                dey             ;decrement counter
                bne chekya      ;loop 1..5 times for channel $11..15
                ldy dcby        ;put channel workspace pointer in Y
                bit dcbmap      ;if channel's open bit in flag byte = 1
                bne chekyb      ;then return C=0
                .if SQUEEZE
chekyz:
                sec             ;else return C=1
chekyb:
                pla             ;restore A on entry
                rts
                .else
chekyz:
                pla             ;else return C=1
                sec
                rts

chekyb:                         ;can save 3 bytes (.chekyz:SEC:.chekyb:PLA:RTS)
                pla
                clc             ;redundant (C=0 on entry)
                rts
                .endif

                .if SQUEEZE
                .else
                                ;unreachable code
                pha
                txa
                jmp dcryp2
                .endif

dcrypt:                         ;Convert file handle to channel pointer
                pha             ;save A
                tya
dcryp2:
                cmp #$10        ;if Y outside range $10..17
                bcc dcryp0
                cmp #$18
                bcc dcryp1
dcryp0:
                lda #$08        ;then return Y=0, C=1
dcryp1:
                jsr lfive       ;else multiply Y by 32
                tay             ;yielding $00..E0
                pla             ;transfer to Y as index
                rts             ;restore A on entry

hmtspe:                         ;Close *SPOOL/*EXEC file on error
                lda #$C6        ;OSBYTE $C6 = read/write *EXEC file handle
                jsr readby      ;call OSBYTE with X=0, Y=$FF
                txa             ;test *EXEC file handle in X
                beq hmtsp1      ;if no *EXEC file open then test *SPOOL handle
                jsr hmtcmp      ;else compare *EXEC handle with error handle
                bne hmtsp1      ;if unequal then test *SPOOL handle
                lda #$C6        ;else OSBYTE $C6 = read/write *EXEC file handle
                bne hmtbyt      ;set *EXEC file handle = 0

hmtsp1:
                lda #$C7        ;OSBYTE $C7 = read/write *SPOOL file handle
                jsr readby      ;call OSBYTE with X=0, Y=$FF
                jsr hmtcmp      ;compare *SPOOL handle with error handle
                bne hmtsp2      ;if unequal then exit
                lda #$C7        ;else OSBYTE $C7 = read/write *SPOOL file handle:
hmtbyt:                         ;Set *SPOOL/*EXEC file handle = 0
                ldx #$00
                ldy #$00
                jmp osbyte

hmtcmp:                         ;Compare file handle with channel workspace offset
                txa             ;on entry X=file handle, move to Y
                tay
                jsr dcrypt      ;convert file handle to channel pointer
                cpy dcby        ;compare with offset in use when error occurred
hmtsp2:
                rts             ;return Z=result

wfeof:                          ;FSC  1 = read EOF state
                pha             ;save AY
                tya
                pha
                txa             ;transfer file handle to Y
                tay
                jsr dcrych      ;ensure file handle valid and open
                tya             ;a=y = channel workspace pointer
                jsr pcmp        ;compare PTR - EXT
                bne wfeof0      ;if PTR <> EXT (blech!) then return 0
                ldx #$FF        ;else return $FF, we are at end of file
                bne wfeof2

wfeof0:
                ldx #$00
wfeof2:
                pla             ;restore AY and exit
                tay
                pla
dcryc0:
                rts

dcrych:                         ;Ensure file handle valid and open
                jsr dcrypt      ;convert file handle to channel pointer
                jsr cheeky      ;validate workspace offset
                bcc dcryc0      ;if channel open then return C=0
                jsr hmtspe      ;else close *SPOOL/*EXEC file on error
                jsr estrng      ;and raise "Channel" error.
                .char $DE
                .text "Channel"
                .char $00

illeof:                         ;Raise "EOF" error
                jsr estrng
                .char $DF
                .text "EOF"
                .char $00

wbget:                          ;OSBGET
                jsr savit       ;save XY
                jsr dcrych      ;ensure file handle valid and open
                tya             ;a=y = channel workspace pointer
                jsr pcmp        ;compare PTR - EXT
                bne noteof      ;if at EOF
                lda seqflg,y    ;then test EOF warning flag b4
                and #$10
                bne illeof      ;if set then raise "EOF" error
                lda #$10        ;else set EOF warning flag b4=1
                jsr setbit      ;set channel flag bits (A = OR mask)
                .if SQUEEZE
                .else
                ldx seqwx       ;redundant
                .endif
                lda #$FE        ;return A=$FE, error code for EOF
                sec             ;return C=1 indicating end-of-file
                rts             ;restore XY and exit

noteof:
                lda seqflg,y    ;not at EOF. get channel flags
                bmi vbgetb      ;if PTR not within current buffer
                jsr setq        ;then set current vol/dir from open filename
                jsr bflush      ;ensure buffer up-to-date on disc L6
                sec             ;c=1 read buffer from disc
                jsr xblock      ;read/write sector buffer L6
vbgetb:
                .if SQUEEZE
                ldx seqpl,y     ;get LSB of PTR
                stx work+$00    ;set LSB of buffer pointer
                .else
                lda seqpl,y     ;get LSB of PTR
                sta work+$00    ;set LSB of buffer pointer
                .endif
                lda seqbuf,y    ;get MSB buffer pointer from channel workspace
                sta work+$01    ;set MSB of buffer pointer
                ldy #$00        ;set Y=0 for indirect indexed load
                lda (work),y    ;get byte from channel buffer at old PTR
                pha
                ldy dcby
                .if SQUEEZE
                .else
                ldx work+$00    ;can save 2 bytes (LDX seqpl,Y)
                .endif
                inx             ;increment PTR
                txa
                sta seqpl,y
                bne vbgetx      ;if LSB rolls over
                clc             ;then carry out to 2MSB
                lda seqpm,y
                adc #$01
                sta seqpm,y
                lda seqph,y     ;and MSB
                adc #$00
                sta seqph,y
                jsr clrcbf      ;clear buffer-contains-PTR channel flag
vbgetx:
                clc             ;c=0, not at EOF:
                pla             ;return byte in A, set N and Z to match
                rts

setda:                          ;Set buffer sector address from PTR
                clc
                lda seqloc,y    ;get LSB start sector of open file
                adc seqpm,y     ;add 2MSB of PTR
                sta lbalo       ;store LSB sector address
                sta seqdal,y    ;store LSB sector address of buffer
                lda seqlh,y     ;get top bits exec/length/load/start sector
                and #$03        ;extract MSB start sector
                adc seqph,y     ;add MSB of PTR
                sta lbahi       ;store MSB sector address
                sta seqdah,y    ;store MSB sector address of buffer:
setcbf:                         ;Set buffer-contains-PTR channel flag
                lda #$80        ;b7=1 buffer contains byte at PTR:
setbit:                         ;Set channel flag bits (A = OR mask)
                ora seqflg,y
                bne clrbt3      ;store if >0 else fall through harmlessly:
clrcbf:                         ;Clear buffer-contains-PTR channel flag:
                lda #$7F
clrbit:                         ;Clear channel flag bits (A = AND mask)
                and seqflg,y
clrbt3:
                sta seqflg,y
                clc
                rts

bflush:                         ;Ensure buffer up-to-date on disc L6
                lda seqflg,y    ;test b6 of channel flag
                and #$40
                beq bflx        ;if buffer not changed then return
                clc             ;c=0 write buffer to disc:
xblock:                         ;Read/write sector buffer L6
                .if SQUEEZE
                .else
                php             ;redundant
                .endif
                inc seqsem      ;set *SPOOL/*EXEC critical flag (now $00)
                ldy dcby        ;put channel workspace pointer in Y
                lda seqbuf,y    ;get MSB address of buffer in shared wksp
                sta lodhi
                lda #$FF        ;set high word of buffer address = $FFFF
                sta ldlow+$02
                sta ldlow+$03
                lda #$00
                sta lodlo       ;clear LSB buffer address
                sta lenlo
                lda #$01        ;256 bytes to transfer
                sta lenhi
                .if SQUEEZE
                .else
                plp             ;redundant
                .endif
                bcs xblrd       ;if C was 1 on entry then read buffer
                lda seqdal,y    ;else copy channel's sector buffer address
                sta lbalo       ;to OSFILE control block (big-endian)
                lda seqdah,y
                sta lbahi
                jsr blkwr       ;write ordinary file L5
                ldy dcby        ;put channel workspace pointer in Y
                lda #$BF        ;b6=0 buffer not changed
                jsr clrbit      ;clear channel flag bits
                bcc xblfin      ;clear critical flag and exit

xblrd:                          ;Read channel buffer from disc L6
                jsr setda       ;set buffer sector address from PTR
                jsr blkrd       ;read ordinary file L5
xblfin:
                dec seqsem      ;clear *SPOOL/*EXEC critical flag (now $FF)
                ldy dcby        ;put channel workspace pointer in Y
bflx:
                rts

vbput1:
                jmp delprt      ;raise "Locked" error.

vbput2:                         ;Raise "Read only" error.
                jsr estrng
                .char $C1
                .text "Read only"
                .char $00

vbput:                          ;Write byte
                jsr savita      ;save AXY
                jmp wbput1

wbput:                          ;OSBPUT
                jsr savita      ;save AXY
                jsr dcrych      ;ensure file handle valid and open
wbput1:
                pha             ;save byte to write
                lda seqrdo,y    ;test channel read-only bit
                bmi vbput2      ;if b7=1 then raise "File read only" error
                lda seqlok,y    ;else test file locked bit
                bmi vbput1      ;if b7=1 then raise "File locked" error
                jsr setq        ;else set current vol/dir from open filename
                tya             ;a=y = channel workspace pointer
                clc             ;add 4 to point A to allocated length not EXT
                adc #$04
                jsr pcmp        ;compare PTR - allocated length
                bne notful      ;if within allocation then write
                jsr vlook3      ;else ensure open file still on current drive
                ldx seqwb       ;get offset of file in catalogue
                sec
                lda cathig-$01,x ;get LSB start LBA of previous file in cat
                sbc cathig+$07,x ;subtract LSB start LBA of open file
                pha             ;save LSB maximum available allocation
                lda cathig-$02,x ;get MSB start LBA of previous file in cat
                sbc cathig+$06,x ;subtract MSB start LBA of open file
                and #$03        ;extract b1,b0
                cmp seqeh,y     ;compare MSB length of file per workspace
                bne vok         ;if not equal then extend file
                pla             ;else restore LSB maximum available allocation
                cmp seqem,y     ;compare 2MSB length of file per workspace
                bne vokspl      ;if not equal then extend file
                .if SQUEEZE
                .else
                sty atemp       ;redundant (vestigial in DFS 1.20)
                .endif
                sty dcby        ;else save workspace pointer
                jsr hmtspe      ;close *SPOOL/*EXEC file on error
                jsr estrng      ;and raise "Can't extend" error.
                .char $BF
                .text "Can't extend"
                .char $00

vok:                            ;extend file
                lda seqeh,y     ;get MSB length of file per workspace
                clc             ;round up length to next 64 KiB
                adc #$01
                sta seqeh,y     ;store MSB file length in workspace
                .if SQUEEZE
                jsr lfour
                .else
                asl a           ;shift A left 4 places
                asl a           ;can save 1 byte (JSR lfour)
                asl a
                asl a
                .endif
                eor cathig+$06,x ;XOR with existing top bits
                and #$30        ;mask b5,b4; A=..XX....
                eor cathig+$06,x ;XOR old top bits with A; 6 bits old, 2 new
                sta cathig+$06,x ;set top bits exec/length/load/start sector
                pla             ;discard LSB maximum available allocation
                lda #$00        ;clear 2MSB file length: multiple of 64 KiB
vokspl:
                sta cathig+$05,x ;store 2MSB file length in catalogue
                sta seqem,y     ;store 2MSB file length in workspace
                lda #$00        ;clear LSB file length in catalogue
                sta cathig+$04,x
                jsr dirout      ;write volume catalogue
                ldy dcby        ;put channel workspace pointer in Y
notful:                         ;write byte to file
                lda seqflg,y    ;test channel flags
                bmi vbputb      ;if b7=1 buffer-contains-PTR then write byte
                jsr bflush      ;else ensure buffer up-to-date on disc L6
                lda seqlla,y    ;does EXT equal a whole number of sectors?
                bne notend      ;if not then read buffer from disc
                tya             ;else a=y = channel workspace pointer
                jsr pcmp        ;compare PTR - EXT
                bne notend      ;if not at EOF then read buffer from disc
                jsr setda       ;else set buffer sector address from PTR
                bne vbputb      ;branch (always)

notend:
                sec             ;c=1 read buffer from disc
                jsr xblock      ;read/write sector buffer L6
vbputb:
                lda seqpl,y     ;get LSB of PTR
                sta work+$00    ;set LSB of buffer pointer
                lda seqbuf,y    ;get MSB buffer pointer from channel workspace
                sta work+$01    ;set MSB of buffer pointer
                pla             ;restore byte to write
                ldy #$00        ;set Y=0 for indirect indexed store
                sta (work),y    ;put byte in channel buffer at old PTR
                ldy dcby        ;put channel workspace pointer in Y
                lda #$40        ;b6=1, buffer has changed
                jsr setbit      ;set channel flag bits (A = OR mask)
                inc work+$00    ;increment PTR
                lda work+$00
                sta seqpl,y
                bne ncarry      ;if LSB rolls over
                jsr clrcbf      ;then clear buffer-contains-PTR channel flag
                lda seqpm,y     ;carry out to 2MSB
                adc #$01        ;c=0 from clrcbf
                sta seqpm,y
                lda seqph,y     ;and MSB
                adc #$00
                sta seqph,y
ncarry:
                tya             ;a=y = channel workspace pointer
                jsr pcmp        ;compare PTR - EXT
                bcc vbputx      ;if at EOF (i.e. pointer >= EXT)
                .if FASTGB
updext:
                .endif
                lda #$20        ;then b5=1, EXT has changed
                jsr setbit      ;set channel flag bits (A = OR mask)
                ldx #$02        ;3 bytes to copy:
vbput3:
                lda seqpl,y     ;copy EXT = PTR
                sta seqlla,y
                iny
                dex
                bpl vbput3
vbputx:
                rts

vstar:                          ;OSARGS A=1, Y>0 set PTR
                jsr savita      ;save AXY
                                ;can save time by entering here from OSARGS
                jsr dcrych      ;ensure file handle valid and open
                .if SQUEEZE
                .else
                ldy dcby        ;redundant
                .endif
vstara:
                jsr scmp        ;compare EXT - requested PTR
                bcs vstarb      ;if EXT >= request then just set PTR
                lda seqlla,y    ;else set PTR = EXT
                sta seqpl,y
                lda seqlma,y
                sta seqpm,y
                lda seqlha,y
                sta seqph,y
                jsr vstarc      ;update buffer-contains-PTR channel flag
                lda vtemp+$00
                pha
                lda vtemp+$01
                pha
                lda ztemp+$00   ;[D]new save but what clobbers it??
                pha
                lda #$00        ;a = $00 filler byte
                jsr vbput       ;write byte to end of file
                pla
                sta ztemp+$00
                pla
                sta vtemp+$01
                pla
                sta vtemp+$00
                jmp vstara      ;loop until last byte is just before new PTR

vstarb:
                lda $00,x       ;copy requested PTR in user's OSARGS block
                sta seqpl,y     ;to channel pointer:
                lda $01,x
                sta seqpm,y
                lda $02,x
                sta seqph,y
vstarc:                         ;Update buffer-contains-PTR channel flag
                lda #$6F        ;b7=0 PTR not in buffer, b4=0 EOF warning clr
                jsr clrbit      ;clear channel flag bits
                lda seqloc,y    ;get LSB start sector of file
                adc seqpm,y     ;add 2MSB PTR
                sta LC2C4       ;store LSB target sector
                lda seqlh,y     ;get MSB start sector of file
                and #$03        ;extract b1,b0
                adc seqph,y     ;add MSB PTR
                cmp seqdah,y    ;compare with MSB sector address of buffer
                bne vbputx      ;if equal
                lda LC2C4       ;then compare LSB buffer offset with request
                cmp seqdal,y
                bne vbputx      ;if requested PTR within current buffer
                jmp setcbf      ;then set buffer-contains-PTR channel flag.

pcmp:                           ;Compare PTR - EXT (A=Y), - allocation (A=Y+4)
                tax             ;return C=1 iff at/past EOF or allocation
                lda seqph,y     ;return Z=1 iff at EOF or equal to allocation
                cmp seqlha,x
                bne pcmpx
                lda seqpm,y
                cmp seqlma,x
                bne pcmpx
                lda seqpl,y
                cmp seqlla,x
pcmpx:
                rts

scmp:                           ;Compare EXT - OSARGS parameter
                lda seqlla,y    ;return C=1 iff EXT >= parameter
                cmp $00,x
                lda seqlma,y
                sbc $01,x
                lda seqlha,y
                sbc $02,x
                rts

                                ;Table of boot commands
load:
                .text "L.!BOOT",$0D
exec:
                .text "E."
run:
                .text "!BOOT",$0D

L9ADE:                          ;DFS service call handler
                .if NMOS
                pha             ;save service call number
                lda priptr,x    ;get private page number
                cmp #$C0        ;c=0, n=1 if $40 <= A < $C0
                bmi nmos0       ;otherwise A < $40 or A >= $C0
                sec             ;so set C=1
nmos0:
                pla             ;restore service call number
                bcc L9B0E       ;if p.page >=$4000 and <$C000 then exit
                .else
                bit priptr,x    ;65C02 instruction
                bpl L9AE6       ;if private page address >=$8000
                bvs L9AE8       ;and <$C000
                rts             ;then exit

L9AE6:
                bvs L9B0E       ;else if >=$4000 and <$8000 then exit
                .endif
L9AE8:
                cmp #$12        ;else test service call number in A
                beq inifsy      ;if =$12 then initialise FS in Y
                cmp #$0B        ;else if in range $00..$0A
                bcc L9AFA       ;then call handler from jump table
                .if BUGFIX
                cmp #$28        ;else if >=$28
                .else
                cmp #$26        ;else if >=$26
                .endif
                bcs L9B0E       ;then exit
                cmp #$21        ;else if <$21
                bcc L9B0E       ;then exit
                sbc #$16        ;else C=1; handle calls $21..$25 from entries $0B..$10
L9AFA:
                asl a           ;double word offset to byte offset
                tax             ;transfer to X for use as index
                lda L9B0F+$01,x ;get high byte of action address - 1
                pha             ;push on stack
                lda L9B0F+$00,x ;get low byte of action address - 1
                pha             ;push on stack
                txa             ;transfer jump table offset to A
                ldx romid       ;put our ROM slot number in A for return
                lsr a           ;halve offset
                cmp #$0B        ;if more than 10
                bcc L9B0E
                adc #$15        ;then C=1; add 22, restore call number
L9B0E:
                rts             ;jump to action address and execute call handler

;Table of action addresses for paged ROM service calls $00..$0A, $21..$25
L9B0F:
                .word return-$01 ;Svc $00 = no operation         $8626
                .word return-$01 ;Svc $01 = reserve abs wkspace  $8626
                .word savpri-$01 ;Svc $02 = reserve private wksp $9C5B
                .word pmsg  -$01 ;Svc $03 = boot filing system   $9B37
                .word chkcom-$01 ;Svc $04 = unrecognised OSCLI   $9C97
                .word return-$01 ;Svc $05 = unrecog. interrupt   $8626
                .word return-$01 ;Svc $06 = break                $8626
                .word return-$01 ;Svc $07 = unrecognised OSBYTE  $8626
                .word unkwrd-$01 ;Svc $08 = unrecognised OSWORD  $9CCE
                .word dohelp-$01 ;Svc $09 = *HELP                $9C9F
                .word relmem-$01 ;Svc $0A = absolute wksp claim  $9CB2
                .word L9D18 -$01 ;Svc $21 = resv abs wksp HAZEL  $9D18
                .word L9D1F -$01 ;Svc $22 = resv priv wksp HAZEL $9D1F
                .word return-$01 ;Svc $23 = report top priv wksp $8626
                .word L9D28 -$01 ;Svc $24 = abs wksp HAZEL count $9D28
                .word L9D2B -$01 ;Svc $25 = retn filing sys info $9D2B
                .if BUGFIX
                .word shut  -$01 ;Svc $26 = *SHUT
                .word reset -$01 ;Svc $27 = reset occurred
                .endif

inifsy:                         ;Service call $12 = initialise FS
                jsr savita
                cpy #$04        ;if number of FS to initialise = 4
                beq init        ;then initialise DFS
                rts             ;else exit

pmsg:                           ;Service call $03 = boot filing system
                jsr savita
                sty itemp       ;save boot flag in scratch space
                lda #$7A        ;call OSBYTE $7A = scan keyboard from $10+
                jsr osbyte
                txa             ;test returned key code
                bmi L9B54       ;if N=1 no key is pressed, so init and boot
                cmp #$32        ;else if key pressed is D
                beq L9B4F       ;then register keypress, init and boot
                cmp #$61        ;else if key pressed is not Z
                bne L9B0E       ;then exit
                jsr LA9FB       ;else set up i8271/MOS 1.20 emulation:
L9B4F:
                lda #$78        ;OSBYTE $78 = write keys pressed information
                jsr osbyte
L9B54:
                lda itemp       ;a=boot flag passed to service call
                jsr vstrng
                .text "Acorn 1770 DFS"
                .char $0D
                .char $0D       ;iff A=0 then force cold start, enable boot
                .if NMOS
                bcc sinit0      ;branch always
                .else
                bra sinit0      ;65C02 instruction
                .endif

init:
                lda #$FF        ;$FF = allow warm start, disable boot
sinit0:
                jsr wopa        ;have A=0 returned on exit
L9B70:
                pha             ;save cold start flag
                lda #$06        ;FSC  6 = new filing system starting up
                jsr osfscm      ;issue Filing System call
                lda fdcdat
                ldx #$0D        ;7 vectors to replace:
init0:
                lda vtabb,x     ;copy addresses of extended vector handlers
                sta filev,x     ;to FILEV,ARGSV,BGETV,BPUTV,GBPBV,FINDV,FSCV
                dex             ;loop until 7 vectors transferred
                bpl init0
                lda #$A8        ;call OSBYTE $A8 = get ext. vector table addr
                jsr readby
                stx temp+$00    ;set up pointer to vector table
                sty temp+$01
                ldx #$07        ;7 vectors to transfer
                ldy #$1B        ;y = $1B = offset of FILEV in extended vector table:
init1:
                lda vtabf-$1B,y ;get LSB action address from table
                sta (temp),y    ;store in extended vector table
                iny
                lda vtabf-$1B,y ;get MSB action address from table
                sta (temp),y    ;store in extended vector table
                iny
                lda romid       ;get our ROM slot number
                sta (temp),y    ;store in extended vector table
                iny
                dex             ;loop until 7 vectors transferred
                bne init1
                sty catdrv      ;no catalogue in workspace
                sty olddrv      ;redundant
                stx fdrive      ;[D]current drive = 0
                lda #$FF
                sta LC287       ;both drives uncalibrated
                ldy #$03
L9BB4:
                sta LC28B,y     ;clear bad tracks, $FF = rogue value
                dey
                bpl L9BB4
                ldx #$0F        ;service call $0F = vectors claimed
                jsr doswcl      ;call OSBYTE $8F = issue service call
                jsr suspri      ;set up pointer to private page
                ldy #colds-mainws ;test cold start flag in private page
                lda (temp),y
                bpl initcl      ;if b7=0 then force a cold start
                pla             ;else test cold start flag passed to us
                pha
                beq initcl      ;if =$00 then force a cold start
                ldy #memflg     ;else test shared workspace possession flag
                lda (temp),y
                bmi bootit      ;if b7=1 then we have the workspace, proceed to boot
                jsr getmem      ;else issue service call $0A to claim the workspace
                ldy #$00        ;offset into private page = $00:
init2:
                lda (temp),y    ;get byte of private page
                cpy #prsist-mainws ;if offset =  $C0 or above
                bcc init3
                sta mainws,y    ;then store in persistent main workspace
                bcs init4       ;and branch (always)

init3:
                sta seqmap,y    ;else store in channel workspace
init4:
                dey             ;loop until entire private page restored
                bne init2
                lda #$A0        ;start at offset $A0, workspace for channel $15:
init6:
                tay             ;transfer offset to Y
                pha             ;save offset on stack
                lda #$3F        ;clear CBF=buffer contains PTR, CBU=buffer changed
                jsr clrbit      ;formerly (<v1.20) left set while stowing
                pla
                sta seqdah,y    ;set buffer LBA out of range to force re-reading
                sbc #$1F        ;c=0 from clrbit; subtract $20 from offset
                bne init6       ;loop until channels $11..$15 reset
                beq bootit      ;then proceed to boot (always)

initcl:                         ;Initialise DFS from cold
                jsr getmem      ;issue service call $0A to claim shared workspace
                lda #$24
                sta defqua      ;set default directory = "$"
                sta libqua      ;set library directory = "$"
                ldy #$00
                sty defdsk      ;set default drive = 0
                sty libdsk      ;set library drive = 0
                ldy #$00
                sty dcbmap      ;no channels open
                ldx #$03        ;[D]
                tya
L9C16:
                sta LC2DE,x     ;clear 40-track flags for drives 3..1
                dex
                bne L9C16
                dey             ;y=$FF
                sty enaflg      ;*commands are not *ENABLEd
                sty monflg      ;*OPT 1,0 quiet operation
                sty seqsem      ;*SPOOL and *EXEC files are non-critical
bootit:
                jsr L8EF4       ;[D]set Tube presence flag
                pla             ;restore cold start/boot flag
                bne noauto      ;if >0 then exit
                lda #$04        ;else enable inverting bad track reg. on read error
                ora LC2DE
                sta LC2DE
                jsr L93A9       ;load catalogue with execute privilege
                lda #$FB        ;disable inverting bad track reg. on read error
                and LC2DE
                sta LC2DE
                lda option      ;get boot option/top bits volume size
                jsr sfour       ;shift A right 4 places
                bne aboot2      ;if boot option = 0
noauto:
                rts             ;then exit

aboot2:
                ldy #>load      ;point XY to command "L.!BOOT"
                ldx #<load
                cmp #$02        ;if boot option = 1 then execute this command
                bcc aboot3
                beq arun        ;if boot option = 2 then execute "!BOOT"
                ldx #<exec
                bne aboot3      ;branch (always)

arun:
                ldx #<run       ;else option >= 3; execute "E.!BOOT"
aboot3:
                jmp oscli       ;call OSCLI and exit.

savpri:                         ;Service call $02 = reserve private workspace
                lda priptr,x    ;space ends at $DC00, highest valid alloc = $DA
                cmp #$DB        ;if we got our two pages in HAZEL
                bcc L9C66       ;during call $21, then initialise
                tya             ;else put private page in main memory instead
                sta priptr,x    ;replace private page pointer
L9C66:
                .if NMOS
                sta temp+$01    ;set up pointer to private page
                tya
                pha
                .else
                phy             ;65C02 instruction
                sta temp+$01    ;set up pointer to private page
                .endif
                lda #$00
                sta temp+$00
                lda #$FD        ;OSBYTE $FD = read/write last reset type
                jsr readby      ;call OSBYTE with X=$00, Y=$FF
                dex             ;now X=$FF soft break, $00 power on, $01 hard break
                txa
                ldy #colds-mainws
                and (temp),y    ;and modified reset type with cold start flag
                sta (temp),y    ;b7=0 force cold start after power on/CTRL BREAK
                php
                iny             ;y=memflg
                plp
                bpl notgot      ;if okay for warm start
                lda (temp),y    ;then private page contents valid
                bpl notgot      ;if we have the shared workspace
                jsr savmem      ;then copy it to the private page
notgot:
                lda #$00        ;b7=0 we don't own the shared workspace
                sta (temp),y    ;write to memflg offset of private page
                .if NMOS
                pla
                tay
                ldx romid       ;get paged ROM slot number as offset into table
                lda priptr,x
                bmi nmos1       ;if private page in main memory
                iny             ;then claim two pages of main memory
                iny
nmos1:
                lda #$02        ;a=$02, restore service call number
                .else
                lda #$02        ;a=$02, restore service call number
                ldx romid       ;get paged ROM slot number as offset into table
                ply             ;65C02 instruction
                bit priptr,x    ;65C02 instruction
                bmi L9C96       ;if private page in main memory
                iny             ;then claim two pages of main memory
                iny
L9C96:
                .endif
                rts

chkcom:                         ;Service call $04 = unrecognised *command
                jsr savita      ;save AXY
                ldx #<(initbl-comtab-$03) ;point to utility section of command table
L9C9C:
                jmp wname0      ;execute matching command.

dohelp:                         ;Service call $09 = *HELP
                jsr savita
                lda (linptr),y  ;y points to non-space character
                ldx #<(hlptab-comtab-$03) ;point to *HELP keyword section of command table
                cmp #$0D        ;if keyword specified
                bne L9C9C       ;then display help on matching keyword
                tya             ;else put command line offset in A for saving
                inx             ;x = <(hlptab-comtab-$01)
                inx
                ldy #$01        ;1 entry to print
                jmp help1       ;print list of *HELP keywords.

;[BUG] service call $0A overwrites private page with garbage
;if DFS does not own absolute workspace

relmem:                         ;Service call $0A = absolute workspace claimed
                jsr suspri      ;set up pointer to private page
                ldy #$00        ;y=$00 ensure all files up-to-date on disc
                jsr nsrnow      ;ensure a file/all files
                jsr savmem      ;copy shared workspace to private page
                jsr suspri      ;set up pointer again (clobbered during ensure)
                ldy #memflg
                lda #$00        ;always claim call since past gatekeeping
                sta (temp),y    ;b7=0 we don't own the shared workspace
                rts

                .if SQUEEZE
                .else
                                ;unreachable code
                lda #$0A
                .endif
unkswz:                         ;Have current value of A returned on exit
                tsx
                sta stack+$05,x
                rts

unkwrd:                         ;Service call $08 = unrecognised OSWORD
                jsr savita      ;save AXY
                jsr wopa        ;have A=0 returned on exit
                ldy worda       ;get OSWORD reason code in Y
                bmi unkswz      ;if >=$80 then put call number back, pass call on
                cpy #$7D        ;else if less than $7D
                bcc unkswz      ;then pass call on to lower ROMs
                .if SQUEEZE
                ldx wordy       ;else save pointer to user's control block
                stx userpt+$01  ;(as inner OSWORD/OSBYTE calls will destroy)
                ldx wordx
                stx userpt+$00
                .else
                ldx wordx       ;can save 2 bytes (swap)
                stx userpt+$00  ;else save pointer to user's control block
                ldx wordy       ;(as inner OSWORD/OSBYTE calls will destroy)
                stx userpt+$01
                .endif
                iny             ;if Y doesn't turn negative then it's $7D or $7E
                bpl gtdsks      ;so handle disc queries separately
                .if SQUEEZE
                .else
                ldx userpt+$00
                .endif
                ldy userpt+$01  ;else OSWORD $7F. point XY to user's control block
                jmp L9163       ;and jump to OSWORD $7F handler.

gtdsks:                         ;OSWORD $7D/$7E
                jsr setdef      ;set current drive and directory = default
                jsr getdir      ;load volume catalogue L4
                iny             ;if Y turns negative
                bmi getdsz      ;then it was $7E; branch
                .if SQUEEZE
                lda cycno       ;else point to first byte of user's control block
                ldy #$00        ;get cycle number of catalogue and return to user
                beq L9D15
                .else
                ldy #$00        ;else point to first byte of user's control block
                lda cycno       ;get cycle number of catalogue and return to user
                sta (userpt),y  ;can save 1 byte (BEQ $9D15)
                rts
                .endif

getdsz:                         ;OSWORD $7E return size of current volume
                lda #$00        ;LSB of volume size = $00
                tay             ;point to first byte of user's control block
                sta (userpt),y  ;write LSB volume size
                iny             ;y=$01
                lda dirhig+$07  ;get LSB volume size in sectors from catalogue
                sta (userpt),y  ;write 3MSB volume size
                iny             ;y=$02
                lda dirhig+$06  ;get boot option/top bits volume size
                and #$03        ;extract volume size in b1,b0
                sta (userpt),y  ;write 2MSB volume size
                iny             ;y=$03
                lda #$00        ;DFS volumes < 16 MiB
                .if SQUEEZE
L9D15:
                .endif
                sta (userpt),y  ;clear MSB volume size
                rts

L9D18:                          ;Service call $21 = reserve abs wksp in HAZEL
                cpy #$CA        ;need 10 pages
                bcs L9D1E       ;if high water mark is less
                ldy #$CA        ;then set it to HAZEL + 10 pages
L9D1E:
                rts

L9D1F:                          ;Service call $22 = reserve priv wksp in HAZEL
                tya             ;[BUG]Y may be too high OR too low at this point
                sta priptr,x    ;set private page pointer to Y anyway
                lda #$22        ;restore call number
                iny             ;claim two pages of HAZEL
                iny             ;and clean up during service call $02.
                rts

L9D28:                          ;Service call $24 = abs wkspace in HAZEL count
                dey             ;bid for two pages in HAZEL
                dey             ;leftovers from abs+private offered in call $23
                rts

L9D2B:                          ;Service call $25 = return FS information
                ldx #L9D51-L9D3B-$01 ;22 bytes to write:
L9D2D:
                lda L9D3B,x     ;get byte of reversed table
                sta (linptr),y  ;store forwards in MOS reserved area
                iny             ;increment MOS pointer
                dex             ;decrement table pointer
                bpl L9D2D       ;loop until 22 bytes copied
                lda #$25        ;restore service call number
                ldx romid       ;restore paged ROM slot number in X
                rts             ;pass updated Y to next ROM

;Filing system information block, in reverse
L9D3B:
                .char $04,$15,$11 ;FS number, highest, lowest file handles
                .text "    CSID" ;FS name
                .char $04,$15,$11 ;FS number, highest, lowest file handles
                .text "    KSID" ;FS name
L9D51:

                .if BUGFIX
shut:                           ;Service call $26 = *SHUT command issued
                tya             ;ported from DFS 2.29
                pha             ;save parameter
                jsr suspri      ;set up pointer to private page
                ldy #memflg     ;test shared workspace possession flag
                lda (temp),y    ;if b7=1 then we have the workspace, proceed
                bmi shut1
                ldy #dcbmap-mainws ;else test channel open flags in private page
                lda (temp),y
                and #$F8        ;if no files were open when stowed
                beq shut2       ;then return
                lda #$FF        ;else $FF = allow warm start, disable boot
                jsr L9B70       ;initialise DFS:
shut1:
                ldy #$00        ;y=$00 close all files
                jsr wshut       ;close a file/all files
shut2:
                pla             ;restore service call parameter
                tay
                ldx $F4         ;restore ROM slot number to X
                lda #$26        ;restore service call number
                rts             ;and pass service call on.

reset:                          ;Service call $26 = reset occurred
                jsr savita      ;save AXY
                jsr suspri      ;set up pointer to private page
                ldy #memflg     ;test shared workspace possession flag
                lda ($B0),y
                bpl LA26A       ;if b7=0 then we don't have it, return
                sta $C282       ;else b7=1; forget catalogue in workspace
LA26A:
                rts

                .elif SQUEEZE
                .else
;On receiving service call $26, DFS is already deselected and its
;files ensured to disc: the Terminal ROM has called OSBYTE $8D (*ROM)
;which issued FSC $06.  This handler as written would close all files
;if the cold start flag were set, but otherwise achieve nothing;
;although its clearing of CBF and CBU at this point would be harmless.
;Even so, this routine has no entry in the jump table and therefore
;*SHUT does not close files on DFS volumes.

                                ;unreachable code
                                ;service call $26 = *SHUT command issued
                .if NMOS
                tya
                pha
                lda #$FF        ;$FF = allow warm start, disable boot
                jsr L9B70       ;initialise DFS
                pla
                tay
                .else
                phy             ;65C02 instruction
                lda #$FF        ;$FF = allow warm start, disable boot
                jsr L9B70       ;initialise DFS
                ply             ;65C02 instruction
                .endif
                ldx romid
                lda #$26
                rts
                .endif

wfile:                          ;OSFILE
                jsr savit       ;save XY
                pha             ;push A
                jsr clrwld      ;disallow wildcard characters in filename
                stx temp+$00    ;set up pointer from XY
                stx fcbadr+$00
                sty temp+$01
                sty fcbadr+$01
                ldx #$00        ;destination offset = 0
                ldy #$00        ;source offset = 0
                jsr shfttw      ;copy filename pointer word to work; X=Y=2
wfile4:
                jsr shftbo      ;copy one word to work, one word to hiwork
                cpy #$12        ;loop until 16 bytes copied, 18 total
                bne wfile4
                pla             ;transfer call number to X
                tax
                inx             ;increment for use as index
                cpx #filjph-filjpl ;was call number $FF or 0..7?
                bcs wfile3      ;if not then exit
                lda filjph,x    ;else get action address high byte
                pha             ;save on stack
                lda filjpl,x    ;get action address low byte
                pha             ;save on stack
wfile3:
                lda #$00        ;a=0 on entry to routine
                rts             ;jump to action address

wfscm:                          ;FSC
                cmp #fschtb-fscltb ;if call outside range 0..11
                bcs wfile3      ;then exit
                stx ytemp       ;else save X
                tax             ;transfer call number to X as index
                lda fschtb,x    ;get action address high byte
                pha             ;save on stack
                lda fscltb,x    ;get action address low byte
                pha             ;save on stack
                txa             ;restore call number to A
                ldx ytemp       ;restore X on entry
wbgpbr:
                rts             ;jump to action address

wbgpb:                          ;OSGBPB
                cmp #wgptbh-wgptbl
                bcs wbgpbr      ;if call number >=9 then return
                jsr savita      ;else save AXY
                jsr wopa        ;have A=0 returned on exit
                stx btemp+$00   ;save OSGBPB block pointer in workspace
                sty btemp+$01
                tay             ;transfer call number to Y for use as index
                .if FASTGB
                jmp fastgb
upgbpb:
                .endif
                jsr wbrest      ;execute OSGBPB call
                php
                bit tumflg      ;[D]if Tube present
                bpl L9DBE
                jsr L8F2F       ;then release Tube
L9DBE:
                plp
                rts

wbrest:
                lda wgptbl,y    ;get low byte of action address from table
                sta qtemp+$00
                lda wgptbh,y    ;get high byte of action address from table
                sta qtemp+$01
                lda wbrwtb,y    ;get microcode byte from table
                lsr a           ;push bit 0 as C
                php
                lsr a           ;push bit 1 as C
                php
                sta ctemp       ;store Tube service call number as bits 0..5
                .if FASTGB
                .else
                jsr makatp      ;set up pointer to user's OSGBPB block
                .endif
                ldy #$0C        ;13 bytes to copy, $0C..$00:
wbgpb0:
                lda (atemp),y   ;copy user's OSGBPB block
                sta dosram,y    ;to workspace
                dey             ;loop until 13 bytes copied
                bpl wbgpb0
                lda dosram+$03  ;and high bytes of address
                and dosram+$04  ;a=$FF if address is in the host
                ora notube      ;a=$FF if Tube absent ($10D6=NOT MOS flag!)
                clc
                adc #$01        ;set A=0, C=1 if transferring to/from host
                beq wbgpba      ;if A>0
                jsr clatub      ;then claim Tube
                clc
                lda #$FF        ;and set A=$FF, C=0, transferring to/from Tube
wbgpba:
                sta tumflg      ;set Tube transfer flag
                lda ctemp       ;set A=0 if writing user mem, A=1 if reading
                bcs wbgpb9      ;if transferring to/from Tube
                ldx #<(dosram+$01) ;then point XY to OSGBPB data address
                ldy #>(dosram+$01)
                jsr tubadr      ;call Tube service to open Tube data channel
wbgpb9:
                plp             ;set C=microcode b1
                bcs wbgpbb      ;if reading/writing data then transfer it
                plp             ;else C=microcode b0 (=0), pop off stack
qjmi:
                jmp (qtemp)     ;and jump to action address.

wbgpbb:
                ldx #$03        ;4 bytes to copy, 3..0:
wbgpb8:
                lda dosram+$09,x ;copy OSGBPB pointer field
                sta vtemp,x     ;to zero page
                dex
                bpl wbgpb8
                ldx #vtemp      ;point X to pointer in zero page
                ldy dosram+$00  ;set Y=channel number
                lda #$00        ;set A=0, read PTR not EXT
                plp             ;set C=microcode b0
                bcs wbgpb1      ;if C=0
                jsr vstar       ;then call OSARGS 1,Y set PTR.
wbgpb1:
                jsr vradr       ;call OSARGS 0,Y return PTR
                ldx #$03        ;4 bytes to copy, 3..0:
wbgpb7:
                lda vtemp,x     ;copy pointer in zero page
                sta dosram+$09,x ;to OSGBPB pointer field
                dex
                bpl wbgpb7
wcbat0:
                jsr comwrk      ;invert OSGBPB length field
                bmi wbgpb4      ;and branch into loop (always)

wbgpb3:
                ldy dosram+$00  ;set Y = channel number
                jsr qjmi        ;transfer byte / element
                bcs wbgpb6      ;if attempted read past EOF then finish
                ldx #$09        ;else set X = $09, point to OSGBPB pointer
                jsr zerinc      ;increment pointer
wbgpb4:
                ldx #$05        ;set X = $05, point to OSGBPB length field
                jsr zerinc      ;increment OSGBPB length field (inverted)
                bne wbgpb3      ;if not overflowed to zero then loop
                clc             ;else set C = 0, no read past EOF:
wbgpb6:
                php
                jsr comwrk      ;invert OSGBPB length field
                ldx #$05        ;add one to get two's complement (0 -> 0)
                jsr zerinc      ;thus, number of elements not transferred
                .if BUGFIX
                ldy qtemp+$00   ;get LSB of OSGBPB action address
                cpy #<wcbatr    ;does it match 'return one filename'?
                beq wbgpbc      ;if not
                ldy dosram+$00  ;set Y = file handle from OSGBPB block
                jsr dcrypt      ;convert to workspace offset
                jsr args3x      ;clear EOF warning flag
wbgpbc:
                .endif
                ldy #$0C        ;13 bytes to copy, offsets 0..$C:
                jsr makatp      ;set up pointer to user's OSGBPB block
wbgpb5:
                lda dosram,y    ;copy OSGBPB block back to user memory
                sta (atemp),y
                dey
                bpl wbgpb5
                plp
                rts

wcbat:                          ;OSGBPB 8 = read filenames in default dir
                jsr setdef      ;set current vol/dir = default, set up drive
                jsr L93B1       ;ensure current volume catalogue loaded
                lda #<wcbatr    ;replace action address with wcbatr
                sta qtemp+$00   ;= return one filename
                lda #>wcbatr
                sta qtemp+$01
                bne wcbat0      ;and return requested number of filenames.

wcbatr:                         ;Return one filename (called during OSGBPB 8)
                ldy dosram+$09  ;set Y = catalogue pointer (0 on first call)
wcbat4:
                cpy dirlen      ;compare with no. files in catalogue
                bcs wcbat2      ;if out of files return C=1, read past EOF
                lda modify,y    ;else get directory character of cat entry
                jsr caps        ;set C=0 iff character in A is a letter
                eor qualif      ;compare with current directory character
                bcs wcbat5      ;if directory character is a letter
                and #$DF        ;then ignore case.
wcbat5:
                and #$7F        ;mask off attribute bit b7
                beq wcbat3      ;if catalogue entry not in current directory
                jsr step        ;then add 8 to Y
                bne wcbat4      ;and loop (always)

wcbat3:
                lda #$07        ;else write 7 to user memory
                jsr wbwrit      ;= length of filename
                sta temp        ;set counter to 7
wcbat1:
                lda catlow,y    ;get character of leaf name
                jsr wbwrit      ;write byte to user memory
                iny             ;increment catalogue pointer
                dec temp        ;loop until 7 characters transferred
                bne wcbat1      ;(Y is 7 up, inc at wbgpb3 puts pointer 8 up)
                clc             ;c=0, did not run out of filenames:
wcbat2:
                sty dosram+$09  ;put updated cat ptr in OSGBPB pointer field
                lda cycno       ;return catalogue cycle no. in channel field
                sta dosram+$00
                rts

rdtco:                          ;OSGBPB 5 = read title, boot option and drive
                jsr setdef      ;set current vol/dir = default, set up drive
                jsr L93B1       ;ensure current volume catalogue loaded
                lda #$0C        ;write 12 to user memory
                jsr wbwrit      ;= length of title
                ldy #$00        ;set offset to 0
rdtc0:
                cpy #$08        ;if writing characters 8..11
                bcs rdtc1       ;then fetch from second catalogue sector
                lda dirlow,y    ;else get characters 0..7 from first sector
                bcc rdtc2       ;and write to user memory (always)

rdtc1:
                lda dirhig-$08,y ;get characters 8..11 from offsets 0..3
rdtc2:
                jsr wbwrit      ;write to user memory
                iny
                cpy #$0C        ;loop until 12 characters written
                bne rdtc0
                lda option      ;get boot option/top bits volume size
                jsr sfour       ;shift A right 4 places
                jsr wbwrit      ;write boot option to user memory
                lda fdrive      ;get current drive
                jmp wbwrit      ;write to user memory and exit

rdbir:                          ;OSGBPB 6 = read default (CSD) drive and dir
                jsr wowrit      ;write binary 1 to user memory
                lda defdsk      ;get default drive
                ora #$30        ;convert to ASCII digit
                jsr wbwrit      ;write drive identifier to user memory
                jsr wowrit      ;write binary 1 to user memory
                lda defqua      ;get default directory character
                bne wbwrit      ;write it to user memory and exit

rlbir:                          ;OSGBPB 7 = read library drive and directory
                jsr wowrit      ;write binary 1 to user memory
                lda libdsk      ;get library drive
                ora #$30        ;convert to ASCII digit
                jsr wbwrit      ;write drive identifier to user memory
                jsr wowrit      ;write binary 1 to user memory
                lda libqua      ;get library directory character
                bne wbwrit      ;write it to user memory and exit

adrld:                          ;Set up pointer to user I/O memory
                .if SQUEEZE
                ldx dosram+$01
                stx ztemp+$00
                ldx dosram+$02
                stx ztemp+$01
                ldx #$00        ;offset = 0 for indexed indirect load/store
                rts

wbwri0:
                jsr adrld       ;set up pointer to user I/O memory
                sta (ztemp,x)   ;store byte at pointer and increment address:
                .else
                pha             ;can save 2 bytes
                lda dosram+$01
                sta ztemp+$00
                lda dosram+$02
                sta ztemp+$01
                ldx #$00        ;offset = 0 for indexed indirect load/store
                pla
                rts
                .endif

adrinc:                         ;Increment OSGBPB address field
                jsr savita      ;save AXY
                ldx #$01        ;set X = $01, point to OSGBPB data address:
zerinc:                         ;Increment OSGBPB field
                ldy #$04
zerin0:
                inc dosram,x
                bne zerin1
                inx
                dey
                bne zerin0
zerin1:
                rts             ;return Z=1 iff field overflows

comwrk:                         ;Invert OSGBPB length field
                ldx #$03
wbgpb2:
                lda #$FF
                eor dosram+$05,x
                sta dosram+$05,x
                dex
                bpl wbgpb2
                rts

makatp:                         ;Set up pointer to user's OSGBPB block
                lda btemp+$00
                sta atemp+$00
                lda btemp+$01
                sta atemp+$01
wbgtr0:
                rts

wowrit:                         ;Write binary 1 to user memory
                lda #$01
                bne wbwrit

                                ;OSGBPB 3 = set pointer and read data
                                ;OSGBPB 4 = read data
wbgtr:
                jsr wbget       ;call OSBGET; read byte from file
                bcs wbgtr0      ;if end-of-file reached return C=1, else:
wbwrit:                         ;Write data byte to user memory
                bit tumflg      ;test Tube flag
                bpl wbwri0      ;if Tube not in use then write to I/O memory
                sta reg3        ;else put byte in R3DATA
                bmi adrinc      ;and increment OSGBPB address field (always)

                .if SQUEEZE
                .else
wbwri0:
                jsr adrld       ;set up pointer to user I/O memory
                sta (ztemp,x)   ;store byte at pointer and increment address
                jmp adrinc      ;can save 3 bytes (join)
                .endif

                                ;OSGBPB 1 = set pointer and write data
                                ;OSGBPB 2 = write data
wbptr:
                jsr wbread      ;get byte from user memory
                jsr wbput       ;call OSBPUT; write byte to file
                clc             ;return C=0 no end-of-file condition
                rts

wbread:                         ;Read data byte from user memory
                bit tumflg      ;test Tube transfer flag
                bpl wbrea0      ;if b7=0 then read from I/O memory
                lda reg3        ;else read from R3DATA
                jmp adrinc      ;increment OSGBPB address field

wbrea0:
                jsr adrld       ;set up pointer to user I/O memory
                lda (ztemp,x)   ;read byte from user I/O memory
                jmp adrinc      ;increment OSGBPB address field

wstus:                          ;FSC  8 = *command has been entered
                bit enaflg      ;if *ENABLEd flag b7=0 (i.e. byte = 0 or 1)
                bmi clrwld
                dec enaflg      ;then enable this command, not the ones after:
clrwld:                         ;Disallow wildcard characters in filename
                lda #$FF
                sta dashop
setwl0:
                sta wildch
                rts

setwld:                         ;Allow wildcard characters in filename
                lda #$2A
                sta dashop
                lda #$23
                bne setwl0

frdcat:                         ;OSFILE   5 = read catalogue information
                jsr tryfil      ;ensure file exists
                jsr chukbk      ;return catalogue information to OSFILE block
                lda #$01        ;return A=1, file found
                rts

fdefil:                         ;OSFILE   6 = delete file
                jsr tryflc      ;ensure unlocked file exists
                jsr chukbk      ;return catalogue information to OSFILE block
                jsr delfil      ;delete catalogue entry
                bcc dort1a      ;write volume catalogue, return A=1

fwrcat:                         ;OSFILE   1 = write catalogue information
                                ;[BUG] can set attributes on open file
                jsr tryfil      ;ensure unlocked file exists
                jsr mvilod      ;set load address from OSFILE block
                jsr mviexe      ;set exec address from OSFILE block
                bvc dort1b      ;branch to set attributes and write (always)

                                ;[D]swapped vs DFS 1.20
fwrexe:                         ;OSFILE   3 = write execution address
                jsr tryfil      ;ensure unlocked file exists
                jsr mviexe      ;set exec address from OSFILE block
                bvc dort1a      ;branch to write catalogue (always)

fwrlod:                         ;OSFILE   2 = write load address
                jsr tryfil      ;ensure unlocked file exists
                jsr mvilod      ;set load address from OSFILE block
                bvc dort1a      ;branch to write catalogue (always)

fwratt:                         ;OSFILE   4 = write file attributes
                jsr tryfil      ;ensure file exists
                jsr chkopn      ;ensure file not open (mutex)
dort1b:
                jsr mviatt      ;set file attributes from OSFILE block
dort1a:
                jsr titend      ;write volume catalogue (=JMP dirout)
                lda #$01        ;return A=1, file found
                rts

mvilod:                         ;Set load address from OSFILE block
                jsr savita      ;save AXY
                ldy #$02        ;set offset = 2
                lda (temp),y    ;get LSB load address from OSFILE block
                sta cathig+$00,x ;store in catalogue entry
                iny             ;increment offset; Y=3
                lda (temp),y    ;get 3MSB load address
                sta cathig+$01,x ;store in catalogue entry
                iny             ;increment offset; Y=4
                lda (temp),y    ;get 2MSB load address
                asl a           ;extract b17,b16, place in b3,b2
                asl a
                eor cathig+$06,x ;XOR with existing top bits
                and #$0C        ;mask b3,b2; A=....XX..
                bpl mviin0      ;branch to update top bits (always)

mviexe:                         ;Set exec address from OSFILE block
                jsr savita      ;save AXY
                ldy #$06        ;set offset = 6
                lda (temp),y    ;get LSB exec address from OSFILE block
                sta cathig+$02,x ;store in catalogue entry
                iny             ;increment offset; Y=7
                lda (temp),y    ;get 3MSB exec address
                sta cathig+$03,x ;store in catalogue entry
                iny             ;increment offset; Y=8
                lda (temp),y    ;get 2MSB load address
                ror a           ;extract b17,b16, place in b7,b6
                ror a
                ror a
                eor cathig+$06,x ;XOR with existing top bits
                and #$C0        ;mask b7,b6; A=XX......
mviin0:
                eor cathig+$06,x ;XOR old top bits with A; 6 bits old, 2 new
                sta cathig+$06,x ;set top bits exec/length/load/start sector
                clv             ;return V=0
                rts

mviatt:                         ;Set file attributes from OSFILE block
                jsr savita      ;save AXY
                ldy #$0E        ;set Y=14, offset of file attributes
                lda (temp),y    ;get LSB of file attributes
                and #$0A        ;test b3=file locked, b1=writing denied
                                ;NB b2..b0 are in opposite sense to RISC OS
                                ;where they enable execute, write, read resp.
                                ;this is well-documented in DFS and RISC OS
                beq mviat0      ;if either is set
                lda #$80        ;then b7=1 file locked
mviat0:
                eor modify,x    ;else b7=0 file unlocked. get directory char
                and #$80        ;from catalogue entry
                eor modify,x    ;preserve b6..0, replace b7 from A
                sta modify,x    ;save directory char with new lock attribute
                rts

tryflc:                         ;Ensure unlocked file exists
                jsr tryfl1      ;test if file exists
                bcc tryfl2      ;if not then return A=0 from caller, else:
chklok:                         ;Ensure file not locked
                lda modify,y    ;if directory character b7=1
                bpl chkopr
delprt:
                jsr estrng      ;then raise "File locked" error.
                .char $C3
                .text "Locked"
                .char $00

chkopl:                         ;Ensure file not locked or open (mutex)
                jsr chklok      ;ensure file not locked
chkopn:                         ;Ensure file not open (mutex)
                jsr savita      ;save AXY
                jsr cmpfil      ;find free channel and check for clashes
                bcc tryfl3      ;if file not open then return
                jmp filopn      ;else raise "Locked" error.

tryfil:                         ;Ensure file exists
                jsr tryfl1      ;test if file exists
                bcs tryfl3      ;if present then return, else:
tryfl2:                         ;Return A=0 from caller
                pla             ;discard return address on stack (ew!)
                pla
                lda #$00        ;return A=0 as if from caller.
chkopr:
                rts

tryfl1:                         ;Test if file exists
                jsr frmnam      ;set current file from argument pointer
                jsr lookup      ;search for file in catalogue
                bcc tryfl3      ;if file not found then exit C=0
                tya             ;else transfer catalogue pointer to X:
                tax
tryfl0:                         ;Set up pointer to user's OSFILE block
                lda fcbadr+$00
                sta temp+$00
                lda fcbadr+$01
                sta temp+$01
tryfl3:
                rts

getlsz:                         ;Get start and size of user memory
                lda #$83        ;call OSBYTE $83 = read OSHWM
                jsr osbyte
                sty frpage      ;save MSB
                lda #$84        ;call OSBYTE $84 = read HIMEM
                jsr osbyte
                tya
                sec             ;save MSB
                sbc frpage
                sta frsize      ;subtract MSB of OSHWM
                rts             ;save result = no. pages of user memory.

getmem:                         ;Claim shared workspace
                jsr suspri      ;[D]not sending service call $0A
                ldy #colds-mainws ;set up pointer to private page
                lda #$FF        ;b7=1 to allow a warm start
                sta (temp),y    ;save in private page
                sta colds       ;and main workspace
                iny             ;y=memflg
                sta (temp),y    ;b7=1 iff we own the shared workspace
                rts

suspri:                         ;Set up pointer to private page
                pha
                lda #$00        ;clear LSB, always start on page boundary
                sta temp+$00
                ldx romid
                lda priptr,x    ;get private page number from table
                sta temp+$01    ;store MSB of pointer
                pla
                rts

clrkey:                         ;Call *FX 15,1 = clear input buffer
                jsr savita      ;save AXY
                lda #$0F
                ldx #$01
                ldy #$00
                beq bytjmp

wriwde:                         ;Call OSBYTE $03 = specify output stream in A
                tax
wriwdx:                         ;Call OSBYTE $03 = specify output stream
                lda #$03
                bne bytjmp

ackesc:                         ;Call OSBYTE $7E = acknowledge ESCAPE condition
                jsr savita      ;save AXY
                lda #$7E
                bne bytjmp

doswcl:                         ;Call OSBYTE $8F = issue service call
                lda #$8F
                bne bytjmp

                .if SQUEEZE
                .else
                                ;unreachable code
                                ;Call OSBYTE $FF = read/write startup options
                lda #$FF
                .endif
readby:
                ldx #$00
                ldy #$FF
bytjmp:
                jmp osbyte

;Table of addresses of extended vector handlers
vtabb:
                .word $FF1B     ;FILEV,         $0212 =         $FF1B
                .word $FF1E     ;ARGSV,         $0214 =         $FF1E
                .word $FF21     ;BGETV,         $0216 =         $FF21
                .word $FF24     ;BPUTV,         $0218 =         $FF24
                .word $FF27     ;GBPBV,         $021A =         $FF27
                .word $FF2A     ;FINDV,         $021C =         $FF2A
                .word $FF2D     ;FSCV,          $021E =         $FF2D

;Table of action addresses for extended vector table
vtabf:
                .word wfile     ;E FILEV,       evt + $1B =     $9D5D
                .char $00
                .word wargs     ;E ARGSV,       evt + $1E =     $974C
                .char $00
                .word wbget     ;E BGETV,       evt + $21 =     $985C
                .char $00
                .word wbput     ;E BPUTV,       evt + $24 =     $994A
                .char $00
                .word wbgpb     ;E GBPBV,       evt + $27 =     $9DA1
                .char $00
                .word wfind     ;E FINDV,       evt + $2A =     $95BD
                .char $00
                .word wfscm     ;E FSCV,        evt + $2D =     $9D8E
                .char $00

;Table of action addresses for FSC calls 0..11, low bytes
fscltb:
                .char <(wfopt -$01) ;FSC  0 = *OPT                  $89F8
                .char <(wfeof -$01) ;FSC  1 = read EOF state        $9825
                .char <(wnota -$01) ;FSC  2 = */                    $8832
                .char <(wname -$01) ;FSC  3 = unrecognised *cmd     $86C0
                .char <(wnota -$01) ;FSC  4 = *RUN                  $8832
                .char <(wdcat -$01) ;FSC  5 = *CAT                  $848E
                .char <(wfdie -$01) ;FSC  6 = new FS starting up    $94FF
                .char <(whlim -$01) ;FSC  7 = valid file handles    $94FA
                .char <(wstus -$01) ;FSC  8 = *command entered      $9F73
                .char <(ex    -$01) ;FSC  9 = *EX                   $8238
                .char <(info  -$01) ;FSC 10 = *INFO                 $8257
                .char <(wnota -$01) ;FSC 11 = *RUN from library     $8832

;Table of action addresses for FSC calls 0..11, high bytes
fschtb:
                .char >(wfopt -$01)
                .char >(wfeof -$01)
                .char >(wnota -$01)
                .char >(wname -$01)
                .char >(wnota -$01)
                .char >(wdcat -$01)
                .char >(wfdie -$01)
                .char >(whlim -$01)
                .char >(wstus -$01)
                .char >(ex    -$01)
                .char >(info  -$01)
                .char >(wnota -$01)

;Table of action addresses for OSFILE calls $FF,0..7, low bytes
filjpl:
                .char <(loader-$01) ;OSFILE $FF = load file         $87DD
                .char <(saver -$01) ;OSFILE   0 = save file         $881B
                .char <(fwrcat-$01) ;OSFILE   1 = wr. catalog info  $9FA1
                .char <(fwrlod-$01) ;OSFILE   2 = wr. load address  $9FB4
                .char <(fwrexe-$01) ;OSFILE   3 = wr. exec address  $9FAC
                .char <(fwratt-$01) ;OSFILE   4 = wr. attributes    $9FBC
                .char <(frdcat-$01) ;OSFILE   5 = read catalog info $9F8D
                .char <(fdefil-$01) ;OSFILE   6 = delete file       $9F96
                .char <(dirdo -$01) ;OSFILE   7 = create file       $8A3D
                .if BUGFIX
                .char <(return-$01) ;OSFILE   8 = create directory
                .char <(fwrlod-$01) ;OSFILE   9 = wr. timestamp
                .char <(saver -$01) ;OSFILE $0A = save w/timestamp
                .char <(dirdo -$01) ;OSFILE $0B = creat.w/timestamp
                .endif

;Table of action addresses for OSFILE calls $FF,0..7, high bytes
filjph:
                .char >(loader-$01)
                .char >(saver -$01)
                .char >(fwrcat-$01)
                .char >(fwrlod-$01)
                .char >(fwrexe-$01)
                .char >(fwratt-$01)
                .char >(frdcat-$01)
                .char >(fdefil-$01)
                .char >(dirdo -$01)
                .if BUGFIX
                .char >(return-$01)
                .char >(fwrlod-$01)
                .char >(saver -$01)
                .char >(dirdo -$01)
                .endif

;Table of action addresses for OSGBPB calls 0..8, low bytes
wgptbl:
                .char <return   ;OSGBPB 0 = no operation        $8626
                .char <wbptr    ;OSGBPB 1 = set PTR and write   $9F58
                .char <wbptr    ;OSGBPB 2 = write data          $9F58
                .char <wbgtr    ;OSGBPB 3 = set PTR and read    $9F41
                .char <wbgtr    ;OSGBPB 4 = read data           $9F41
                .char <rdtco    ;OSGBPB 5 = read title/opt/drv  $9EAF
                .char <rdbir    ;OSGBPB 6 = read CSD drv/dir    $9EDE
                .char <rlbir    ;OSGBPB 7 = read lib'y drv/dir  $9EF1
                .char <wcbat    ;OSGBPB 8 = read CSD filenames  $9E63

;Table of action addresses for OSGBPB calls 0..8, high bytes
wgptbh:
                .char >return
                .char >wbptr
                .char >wbptr
                .char >wbgtr
                .char >wbgtr
                .char >rdtco
                .char >rdbir
                .char >rlbir
                .char >wcbat

;Table of microcode bytes for OSGBPB calls 0..8
wbrwtb:
                .char $04       ;%000001 0 . to memory,   special handler
                .char $02       ;%000000 1 0 from memory, xfer data, set PTR
                .char $03       ;%000000 1 1 from memory, xfer data, leave PTR
                .char $06       ;%000001 1 0 to memory,   xfer data, set PTR
                .char $07       ;%000001 1 1 to memory,   xfer data, leave PTR
                .char $04       ;%000001 0 . to memory,   special handler
                .char $04       ;%000001 0 . to memory,   special handler
                .char $04       ;%000001 0 . to memory,   special handler
                .char $04       ;%000001 0 . to memory,   special handler

help:                           ;*HELP DFS
                tya             ;save command line offset
                ldx #<(comtab-comtab-$01) ;point to DFS command table
                ldy #$10        ;16 entries to print
help1:
                pha             ;save command line offset
                jsr vstrng      ;print DFS banner
                .char $0D
                .text "DFS 2.24"
                .char $0D
                stx comtxt      ;save command table offset
                sty vtemp+$01   ;[D]using counter in zp
help0:
                lda #$00
                sta etemp       ;no error message being built print to screen
                ldy #$02        ;y=2 print two spaces
                jsr LA1E5       ;print number of spaces in Y
                jsr psyntx      ;print command name and syntax
                jsr pcrlf       ;print newline
                dec vtemp+$01   ;decrement count of entries
                bne help0       ;loop until none remain
                pla             ;restore command line offset to Y
                tay
help2:
                ldx #<(hlptab-comtab-$03) ;point to *HELP keyword table
                jmp wname0      ;scan next argument for *HELP keywords

                .if SQUEEZE
                .else
                                ;unreachable code
                                ;was *HELP UTILS
                tya
                ldx #<(initbl-comtab-$01) ;point to utility command table
                ldy #$01        ;1 entry to print
                bne help1
                .endif

nohelp:                         ;Unrecognised *HELP keyword
                jsr setupr      ;call GSINIT with C=0
                beq psynt4      ;if no argument present then return
nohlp1:
                jsr rdchr       ;call GSREAD
                bcc nohlp1      ;until end of argument (discarding it)
                bcs help2       ;then scan next argument (always)

chksyn:                         ;Call GSINIT with C=0 and require argument
                jsr setupr      ;call GSINIT with C=0
                bne psynt4      ;if argument present then return, else:
synerr:                         ;Raise "Syntax: " error
                jsr fstrng
                .char $DC
                .text "Syntax: "
                stx etemp       ;x>0, printing to error message, suppress TAB
                jsr psyntx      ;print command name and syntax
                lda #$00        ;$00 = error message terminator byte
                jsr phelpc      ;append NUL to error message
                jmp errbuf      ;jump to BRK to raise error

psyntx:                         ;Print command name and syntax
                ldx comtxt      ;get command table offset
                lda #$09        ;[D]9 characters in command name column
                sta ztemp
syner1:
                inx             ;increment offset
                lda comtab,x    ;get byte of command name
                bmi syner0      ;if terminator reached then print syntax
                jsr phelpc      ;else print character in A (OSASCI)
                jmp syner1      ;and loop

syner0:
                ldy ztemp       ;[D]
                cpy #$0C        ;if number of spaces remaining <> 12
                beq LA1A2
                jsr LA1E5       ;then print number of spaces in Y
LA1A2:
                inx             ;skip action address
                inx
                stx comtxt      ;update command table offset
                lda comtab,x    ;get syntax byte
                jsr psynt5      ;print syntax element
                jsr sfour       ;shift A right 4 places:
psynt5:                         ;Print syntax element
                jsr savita      ;save AXY
                and #$0F        ;mask b3..0 current syntax element
                beq psynt4      ;if null element then return
                tay             ;else transfer to Y for use as counter
                lda #$20        ;print a space
                jsr phelpc      ;print character in A (OSASCI)
                ldx #$FF        ;set offset=$FF going to 0:
psynt2:
                inx             ;increment offset
                lda argtbl,x    ;get character of syntax element table
                bpl psynt2      ;loop until b7=1
                dey             ;decrement number of elements(+1) to skip
                bne psynt2      ;when Y=0 we've reached correct element:
                and #$7F        ;mask off start-of-element marker in b7
psynt3:
                jsr phelpc      ;print character in A (OSASCI)
                inx             ;increment offset
                lda argtbl,x    ;get character of syntax element table
                bpl psynt3      ;loop until start of next element reached
                rts             ;then exit

phelpc:                         ;Print character to screen or error message
                jsr savita      ;save AXY
                ldx etemp       ;get pointer to end of error message
                beq phlpc0      ;if zero then print to screen
                inc etemp       ;else increment pointer
                sta errbuf,x    ;and store character at old pointer
psynt4:
                rts

phlpc0:
                dec ztemp       ;[D]else decrement no. spaces to next TAB
                jmp pchr        ;and print character in A (OSASCI)

LA1E5:                          ;Print number of spaces in Y
                lda etemp       ;if error message being built
                bne LA1F1       ;then return
                lda #$20        ;else print a space
LA1EB:
                jsr phelpc      ;print character to screen or error message
                dey             ;loop until Y = 0
                bne LA1EB
LA1F1:
                rts

argtbl:                         ;Table of syntax elements
                .text $BC,"fsp>"
                .text $BC,"afsp>"
                .text $A8,"L)"
                .text $BC,"source> <dest.>"
                .text $BC,"old fsp> <new fsp>"
                .text $A8,"<dir>)"
                .text $A8,"<drive>)"
                .text $BC,"title>"
                .text $BC,"drive> (40)(80)" ;[D]
                .text $B4,"0/80" ;[D]
                .text $A8,"<drive>)..." ;[D]
                .text $A8,"<rom>)" ;[D]
                .text $FF

compct:                         ;*COMPACT
                jsr readrv      ;select specified or default volume
                jsr vstrng      ;print "Compacting :"
                .text "Compacting :"
                sta fdriv       ;set as source drive
                sta tdriv       ;set as destination drive
                jsr digout      ;print hex nibble
                jsr pcrlf       ;print newline
                ldy #$00        ;point Y to workspace of invalid channel $10
                .if BUGFIX
                jsr wshut       ;close all files
                .else
                jsr vshut       ;close file [BUG] does nothing; should be wshut
                .endif
                jsr getlsz      ;get start and size of user memory
                jsr getdir      ;load volume catalogue L4
                ldy dirlen      ;get number of files in catalogue
                sty cpycat      ;set as catalogue pointer
                lda #$02        ;data area starts at LBA $0002
                sta dstlo
                lda #$00
                sta dsthi
loopx:
                ldy cpycat      ;set Y to catalogue pointer
                jsr unstep      ;subtract 8 from Y
                cpy #$F8        ;if we've reached end of catalogue
                bne notdun
                lda dirhig+$07  ;then get LSB volume size
                sec             ;subtract LSB destination LBA
                sbc dstlo       ;i.e. start of free space
                pha             ;=LSB number of free sectors
                lda dirhig+$06  ;get boot option/top bits volume size
                and #$03        ;extract volume size in b1,b0
                sbc dsthi       ;subtract MSB start of free space
                jsr digout      ;print hex nibble
                pla             ;restore LSB number of free sectors
                jsr bytout      ;print hex byte
                jsr vstrng      ;print " free sectors" + newline
                .text " free sectors"
                .char $0D
                nop
                rts             ;exit.

notdun:
                sty cpycat      ;else set new catalogue pointer
                jsr inform      ;print *INFO line if verbose
                ldy cpycat
                lda cathig+$04,y
                cmp #$01
                lda #$00
                sta lodlo       ;set LSB load address = 0
                sta lenlo       ;set LSB transfer size = 0
                adc cathig+$05,y ;add C to 2MSB length, rounding up
                sta todolo      ;store LSB length of file in sectors
                lda cathig+$06,y ;get top bits exec/length/load/start sector
                php             ;save carry flag from addition
                jsr isolen      ;extract length from b5,4 to b1,0
                plp             ;restore carry flag
                adc #$00        ;add C to MSB length, rounding up
                sta todohi      ;store length in sectors in zero page
                lda cathig+$07,y ;get LSB start sector
                sta srclo       ;set LSB source LBA
                lda cathig+$06,y ;get top bits exec/length/load/start sector
                and #$03        ;extract b1,b0 of A
                sta srchi       ;set MSB source LBA
                cmp dsthi       ;compare with destination LBA
                bne cmpct2      ;if unequal then compact file
                lda srclo       ;else compare LSBs source - destination LBA
                cmp dstlo
                bne cmpct2      ;if unequal then compact file
                clc             ;else add file length to destination LBA
                adc todolo
                sta dstlo       ;store updated LSB destination LBA
                lda dsthi       ;= srchi
                adc todohi      ;carry out to MSB destination LBA
                sta dsthi
                jmp cmpct4      ;and loop for next file

cmpct2:                         ;Compact file
                lda dstlo       ;set LSB start sector = destination LBA
                sta cathig+$07,y
                lda cathig+$06,y ;get top bits exec/length/load/start sector
                and #$FC        ;clear b1,b0 MSB start sector
                ora dsthi       ;replace with MSB destination LBA
                sta cathig+$06,y ;set top bits exec/length/load/start sector
                lda #$00
                sta linno       ;no catalogue entry waiting to be created
                sta L00A9       ;$00 = source and dest. are different drives
                                ;(no swapping)
                jsr mvdkda      ;copy source drive/file to destination
                jsr dirout      ;write volume catalogue L4
cmpct4:
                ldy cpycat
                jsr prtinf      ;print *INFO line
                jmp loopx       ;loop for next file

chkena:                         ;Ensure *ENABLE active
                bit enaflg      ;test *ENABLE flag
                bpl chken0      ;if b7=0 then current command is enabled
                jsr sure        ;else print "Go?" and ask user yes or no
                beq chkna1      ;if yes then print newline and return
                pla             ;else pop return address (ew!)
                pla             ;to return to caller's superroutine
chkna1:
                jmp pcrlf       ;print newline and exit.

get2dr:                         ;Parse and print source and dest. volumes
                jsr chksyn      ;call GSINIT with C=0 and reject empty arg
                jsr getdrv      ;parse volume spec
                sta fdriv       ;store source volume
                jsr chksyn      ;call GSINIT with C=0 and reject empty arg
                jsr getdrv      ;parse volume spec
                sta tdriv       ;store destination volume
                tya             ;save GSINIT offset in Y
                pha
                lda #$00
                sta L00A9       ;$00 = source and dest. are different drives
                lda tdriv       ;get destination drive
                cmp fdriv       ;compare with source drive
                bne copyns      ;if equal
                lda #$FF        ;then A=$FF
                sta L00A9       ;b7=1 source and dest. share drive (swapping)
                sta utemp       ;b7=1 dest. disc in drive (ask for source)
copyns:
                jsr getlsz      ;get start and size of user memory
                jsr vstrng      ;print "Copying from :"
                .text "Copying from :"
                lda fdriv       ;get source volume
                jsr digout      ;print hex nibble
                jsr vstrng      ;print " to :"
                .text " to :"
                lda tdriv       ;get destination volume
                jsr digout      ;print hex nibble
                jsr pcrlf       ;print newline
                pla             ;restore GSINIT offset to Y
                tay
                clc
chken0:
                rts

                .if SQUEEZE
chkdsf:                         ;Select source volume
                jsr savita      ;save AXY
                bit L00A9       ;if source and dest. are different drives
                bpl chken0      ;then return
                lda #$00        ;else A=$00 = we want source disc
                beq chkds0      ;branch (always)

chkdst:                         ;Select destination volume
                jsr savita      ;save AXY
                bit L00A9       ;if source and dest. are different drives
                bpl chken0      ;then return
chkds2:
                lda #$80        ;else A=$80 = we want destination disc
chkds0:
                cmp utemp       ;compare wanted disc with disc in drive
                beq chken0      ;if the same then do not prompt
                .else
chkdsf:                         ;Select source volume
                jsr savita      ;save AXY
                bit L00A9       ;if source and dest. are different drives
                bpl chkds1      ;then return
                lda #$00        ;else A=$00 = we want source disc
                beq chkds0      ;branch (always)

chkdst:                         ;Select destination volume
                jsr savita      ;save AXY
                bit L00A9       ;if source and dest. are different drives
                bmi chkds2      ;can save 1 byte (BPL chken0)
chkds1:
                rts             ;then return

chkds2:
                lda #$80        ;else A=$80 = we want destination disc
chkds0:
                cmp utemp       ;compare wanted disc with disc in drive
                beq chkds1      ;if the same then do not prompt
                .endif
                sta utemp       ;else wanted disc is going into drive
                jsr vstrng      ;print "Insert "
                .text "Insert "
                nop
                bit utemp       ;if b7=1
                bmi chkds3      ;then print "destination"
                jsr vstrng      ;else print "source"
                .text "source"
                bcc chkds4      ;and branch (always)

chkds3:
                jsr vstrng      ;print " destination"
                .text "destination"
                nop
chkds4:
                jsr vstrng      ;print " disk and hit a key"
                .text " disc and hit a key"
                nop
                jsr clrkey      ;call *FX 15,1 = clear input buffer
                jsr osrdch      ;call OSRDCH, wait for input character
                bcs abort       ;if ESCAPE was pressed then raise error, else:
pcrlf:                          ;Print newline
                pha
                lda #$0D
                jsr pchr
                pla
                rts

LA403:                          ;Print " : " and ask user yes or no
                jsr vstrng
                .text " : "
                bcc getyn

sure:                           ;Print "Go?" and ask user yes or no
                jsr vstrng
                .text "Go (Y/N) ? "
                nop
getyn:
                jsr clrkey      ;call *FX 15,1 = clear input buffer
                jsr osrdch      ;call OSRDCH, wait for input character
                bcs abort       ;if ESCAPE was pressed then raise error
                and #$5F        ;else clear bit 7, make uppercase
                cmp #$59        ;is it "Y"?
                php             ;save the answer
                beq getyn0      ;if so then print "Y"
                lda #$4E        ;else print "N"
getyn0:
                jsr pchr        ;print character in A (OSASCI)
                plp             ;return Z=1 if "Y" or "y" pressed
                rts

abort:
                jmp escape      ;acknowledge escape condition and raise error

nocop:
                jmp noroom      ;raise "Disc full" error

cpydsk:                         ;*BACKUP
                jsr get2dr      ;parse and print source and dest. volumes
                jsr chkena      ;ensure *ENABLE active
                lda #$00
                sta srchi       ;set source volume LBA = 0
                sta dsthi
                sta dstlo       ;set destination volume LBA = 0
                sta srclo
                sta linno       ;no catalogue entry waiting to be created
                jsr chkdsf      ;select source volume
                lda fdriv       ;get source drive
                sta fdrive      ;set as current drive
                jsr L93C0       ;load volume catalogue
                lda dirhig+$07  ;get LSB source volume size
                sta todolo      ;store LSB no. sectors to transfer
                lda dirhig+$06  ;get boot option/top bits volume size
                and #$03        ;extract volume size in b1,b0
                sta todohi      ;store MSB no. sectors to transfer
                jsr chkdst      ;select destination volume
                lda tdriv       ;get destination drive
                sta fdrive      ;set as current drive
                jsr L93C0       ;load volume catalogue
                lda dirhig+$06  ;get boot option/top bits volume size
                and #$03        ;extract volume size in b1,b0
                cmp todohi      ;compare MSBs dest volume size - source
                bcc nocop       ;if dest < source then raise error
                bne cpydk4      ;if dest > source then proceed
                lda dirhig+$07  ;else compare LSBs dest - source
                cmp todolo
                bcc nocop       ;if dest < source then raise error
cpydk4:
                jsr mvdkda      ;copy source drive/file to destination
                jmp L93C0       ;load volume catalogue (which??)

cpyfil:                         ;*COPY
                jsr setwld      ;allow wildcard characters in filename
                jsr get2dr      ;parse and print source and dest. volumes
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr getnam      ;set current file from file spec
                jsr chkdsf      ;select source volume
                lda fdriv       ;get source drive
                jsr dodriv      ;select drive in A
                jsr errlok      ;ensure matching file in catalogue
cpyfl3:
                lda qualif      ;save directory spec given to *COPY
                pha
                lda vtemp+$00
                sta ltemp       ;save cat. offset of found file in zero page
                jsr prtinf      ;print *INFO line
                ldx #$00
copyl:
                lda catlow,y    ;copy matching filename+dir to current file
                sta wrknam,x
                sta namtra,x    ;and to workspace
                lda cathig,y    ;copy matching file's catalogue information
                sta wrkcat-$01,x ;to OSFILE block (aligned lower than usual)
                sta tmpcat,x    ;and to workspace
                inx
                iny
                cpx #$08        ;loop until 8 bytes of each field copied
                bne copyl
                lda wrkcat-$01+$06 ;get top bits exec/length/load/start sector
                jsr isolen      ;extract b5,b4 of A
                sta lenhl-$01   ;set MSB length (really a new temp used like lenhl)
                lda wrkcat-$01+$04 ;get LSB length
                .if SQUEEZE
                cmp #$01        ;set C=1 iff file includes partial sector
                .else
                clc             ;can save 1 byte, CMP #$01
                adc #$FF        ;set C=1 iff file includes partial sector
                .endif
                lda wrkcat-$01+$05 ;get 2MSB length
                adc #$00        ;round up to get LSB length in sectors
                sta todolo
                lda lenhl-$01   ;get extracted MSB length
                adc #$00        ;carry out to get MSB length in sectors
                sta todohi
                lda tmpcat+$07  ;get LSB start LBA (also at wrkcat-$01+$07)
                sta srclo       ;can save 1 byte (zp address above)
                lda tmpcat+$06  ;get top bits exec/length/load/start sector
                and #$03        ;extract b1,b0 of A
                sta srchi       ;store MSB start LBA
                lda #$FF
                sta linno       ;catalogue entry is waiting to be created
                jsr mvdkda      ;copy source drive/file to destination
                jsr chkdsf      ;select source volume
                lda fdriv       ;get source drive
                jsr dodriv      ;select drive in A
                jsr getdir      ;load volume catalogue
                lda ltemp       ;restore cat. offset of found file
                sta vtemp+$00   ;to workspace
                pla             ;restore directory spec given to *COPY
                sta qualif
                jsr next        ;find next matching file
                bcs cpyfl3      ;loop while match found, else exit
                rts

regen:                          ;Create destination catalogue entry
                jsr swpfcb      ;swap work with tmpcin
                jsr chkdst      ;select destination volume
                lda tdriv
                sta fdrive
                lda qualif      ;save current directory
                pha
                jsr getdir      ;load volume catalogue L4
                jsr lookw       ;search for wrknam in catalogue
                bcc copyfe      ;if found
                jsr delfil      ;then delete catalogue entry
copyfe:
                pla             ;restore current directory
                sta qualif      ;set as current directory (what clobbers??)
                jsr decodl      ;expand 18-bit load address to 32-bit
                jsr decode      ;expand 18-bit exec address to 32-bit
                lda wrkcat+$06  ;get top bits exec/length/load/start sector
                jsr isolen      ;extract b5,b4 of A
                sta lenhl       ;store MSB length
                jsr genfil      ;create catalogue entry
                lda wrkcat+$06  ;get top bits exec/length/load/start sector
                and #$03        ;extract b1,b0 of A
                pha             ;save MSB start sector
                lda wrkcat+$07  ;get LSB start sector
                pha             ;save LSB start sector
                jsr swpfcb      ;swap work with tmpcin
                pla
                sta dstlo       ;store LSB start sector
                pla
                sta dsthi       ;store MSB start sector
                rts

swpfcb:                         ;Swap work with tmpcin
                ldx #$11
swpfc0:
                .if SQUEEZE
                ldy tmpcin,x
                lda work,x
                sty work,x
                sta tmpcin,x
                .else
                lda tmpcin,x
                ldy work,x
                sta work,x
                tya             ;can save 1 byte (STY work,X)
                sta tmpcin,x
                .endif
                dex
                bpl swpfc0
                rts

mvdkda:                         ;Copy source drive/file to destination
                lda #$00
                sta lodlo       ;set LSB load address = 0
                sta lenlo       ;set LSB transfer size = 0
                .if BUGFIX
                lda todolo      ;test if file size is zero
                ora todohi
                bne cpyfl5      ;if not then can transfer data
                bit linno       ;else handle empty files specially
                bpl cpyfl4      ;if catalogue entry waiting to be created
                jmp regen       ;then create entry while control block pristine

                .else
                beq cpyfl8      ;branch to avoid transferring nothing (removable??)
                .endif

cpyfl5:
                .if SQUEEZE
                ldy todolo      ;compare remaining file size
                cpy frsize      ;- available memory
                .else
                lda todolo      ;compare remaining file size
                tay             ;- available memory
                cmp frsize
                .endif
                lda todohi
                sbc #$00
                bcc sizet       ;if remainder fits then Y=file size in pages
                ldy frsize      ;else Y=size of available memory in pages
sizet:
                sty lenhi       ;set MSB transfer size = no. pages in Y
                lda srclo       ;set LBA = source volume LBA
                sta lbalo
                lda srchi
                sta lbahi
                lda frpage      ;set MSB load address = start of user memory
                sta lodhi
                lda fdriv       ;get source drive
                sta fdrive      ;set as current drive
                jsr chkdsf      ;select source volume
                jsr LA5D1       ;set high word of OSFILE load address = $FFFF
                jsr blkrd       ;read extended file L5
                lda tdriv       ;get destination drive
                sta fdrive      ;set as current drive
                bit linno       ;if catalogue entry is waiting to be created
                bpl cpyfl9
                jsr regen       ;then create destination catalogue entry
                lda #$00        ;[BUG] empty files are not copied
                sta linno       ;no catalogue entry waiting to be created
cpyfl9:
                lda dstlo       ;set LBA = destination volume LBA
                sta lbalo
                lda dsthi
                sta lbahi
                lda frpage      ;set MSB save address = start of user memory
                sta lodhi
                jsr chkdst      ;select destination volume
                jsr LA5D1       ;set high word of OSFILE load address = $FFFF
                jsr blkwr       ;write extended file L5
                lda lenhi       ;add transfer size to destination volume LBA
                clc
                adc dstlo
                sta dstlo
                bcc cpyfl6      ;carry out to high byte
                inc dsthi
cpyfl6:
                lda lenhi       ;add transfer size to source volume LBA
                clc
                adc srclo
                sta srclo
                bcc cpyfl7      ;carry out to high byte
                inc srchi
cpyfl7:
                sec
                lda todolo      ;get LSB remaining size of file in sectors
                sbc lenhi       ;subtract number of pages transferred
                sta todolo      ;update LSB remaining size
                bcs cpyfl8
                dec todohi      ;borrow in from MSB remaining size if req'd
cpyfl8:
                lda todolo
                ora todohi      ;or MSB with LSB, Z=0 if pages remain
                bne cpyfl5      ;if file transfer is incomplete then loop
                .if BUGFIX
cpyfl4:
                .endif
                rts

                .if SQUEEZE
                .else
LA5D1:                          ;Set high word of OSFILE load address = $FFFF
                lda #$FF        ;redundant to $8B21, decodl
                sta ldlow+$02
                sta ldlow+$03
                rts
                .endif

verify:                         ;*VERIFY
                lda #$00        ;clear formatting flag
                beq LA5E3       ;branch (always)

form:                           ;*FORM
                lda #$FF
                sta catdrv      ;forget catalogue in workspace
LA5E3:
                sta L00C9       ;set formatting flag
                sta LC290+$00   ;drive no.=0 if verifying, =$FF if formatting
                bpl LA604       ;if formatting
                jsr chksyn      ;call GSINIT with C=0 and require argument
                jsr L8461       ;input number up to 3 digits
                sta LC29F       ;store number of tracks to format
                bcs LA601       ;if number invalid then raise "Syntax: " error
                cmp #$23        ;else if 35 tracks requested
                beq LA604       ;then accept number of tracks
                cmp #$28        ;else if 40 tracks requested
                beq LA604       ;then accept number of tracks
                cmp #$50        ;else if 80 tracks requested
                beq LA604       ;then accept number of tracks
LA601:
                jmp synerr      ;else raise "Syntax: " error

LA604:
                jsr setupr      ;call GSINIT with C=0
                sty L00CA       ;store pointer to start of argument
                bne LA656       ;if no argument present
                bit L00C9       ;then select prompt
                bmi LA61A       ;if formatting then ask "Format which drive ? "
                jsr vstrng      ;else ask "Verify which drive ? "
                .text "Verify"
                bcc LA624       ;branch (always)

LA61A:                          ;print "Format"
                jsr vstrng
                .text "Format"
                nop
LA624:
                jsr vstrng      ;print " which drive ? "
                .text " which drive ? "
                nop
                jsr osrdch      ;get character from console
                bcs LA67C       ;if Escape pressed then raise "Escape" error
                cmp #$20        ;if control character input
                bcc LA67F       ;then raise "Bad drive" error
                jsr pchr        ;else echo character to console
                sec             ;convert ASCII digit to binary
                sbc #$30
                .if SQUEEZE
                .else
                bcc LA67F       ;redundant
                .endif
                cmp #$04        ;if not in range 0..3
                bcs LA67F       ;then raise "Bad drive" error
                sta fdrive      ;else set current drive
                jsr pcrlf       ;print newline
                ldy L00CA       ;restore pointer to end of command line
                jmp LA659

LA656:
                jsr getdrv      ;argument present, select specified drive
LA659:
                sty L00CA       ;store pointer to next argument
                bit L00C9       ;if formatting
                bpl LA666
                ldx fdrive      ;then X=current drive
                lda #$00
                sta LC2DE,x     ;clear 40-track flag for drive X
LA666:
                .if SQUEEZE
                bit L00C9
                .else
                bit LC290+$00   ;can save 1 byte (BIT L00C9)
                .endif
                bpl LA671       ;if formatting
                jsr chkena      ;then ensure *ENABLE active
                jsr getlsz      ;get start and size of user memory
LA671:
                jsr LA682       ;format or verify current drive
                ldy L00CA       ;restore pointer to next argument
                jsr setupr      ;call GSINIT with C=0
                bne LA656       ;if argument present then format another drive
                rts             ;else exit

LA67C:
                jmp escape      ;raise "Escape" error

LA67F:
                jmp drverr      ;raise "Bad drive" error

LA682:
                bit L00C9       ;if verifying
                bmi LA694
                jsr vstrng      ;then print "Verifying"
                .text "Verifying"
                bcc LA6A9       ;branch (always)

LA694:
                jsr LA78B       ;else clear volume catalogue
                jsr vstrng      ;print "Formatting"
                .text "Formatting"
                ldx fdrive      ;get current drive
                stx LC290+$00   ;set drive parameter in high OSWORD $7F block
LA6A9:
                jsr vstrng      ;print " drive "
                .text " drive "
                lda fdrive      ;get current drive
                jsr digout      ;print hex nibble
                jsr vstrng      ;print " track   "
                .text " track   "
                nop
                bit L00C9       ;if verifying
                bmi LA6D5
                jsr LA7ED       ;calculate number of tracks on current drive
                txa             ;test number of tracks containing data
                bne LA6D2       ;if zero then nothing to do
                jmp pcrlf       ;so print newline and skip to next drive

LA6D2:
                sta LC29F       ;else store number of tracks to verify
LA6D5:
                lda #$00        ;start at track 0
                sta LC290+$07   ;1st parm, track number
LA6DA:
                lda #$08        ;print two backspaces
                jsr pchr        ;to position cursor after "track "
                jsr pchr
                lda LC290+$07   ;1st parm, track number
                jsr bytout      ;print hex byte
                lda #$06        ;5 attempts
                sta LC29D       ;set attempt counter
LA6ED:
                jsr LA75C       ;set up OSWORD $7F control block for formatting
                bit L00C9       ;if verifying
                bpl LA701       ;then verify only
                jsr LA7A7       ;else create ID table
                ldx #<LC290     ;point XY to high OSWORD $7F control block
                ldy #>LC290
                jsr L9163       ;call OSWORD $7F
                tax             ;test result code (redundant)
                bne LA729       ;if command failed then hard error, report
LA701:
                lda #$00
                sta LC290+$08   ;2nd parm, starting sector
                lda LC290+$09   ;3rd parm, sector size+count
                and #$1F        ;mask off sector size code
                sta LC290+$09
                lda #$03        ;3 parameters
                sta LC290+$05
                lda #$5F        ;$5F = verify data
                sta LC290+$06
                jsr L93E6       ;check for escape condition
                ldx #<LC290     ;point XY to high OSWORD $7F control block
                ldy #>LC290
                jsr L9163       ;call OSWORD $7F
                beq LA731       ;if succeeded then finish track
                dec LC29D       ;else decrement attempt counter
                bne LA6ED       ;if attempts remaining then loop
LA729:                          ;else hard error
                jsr vstrng      ;print "?"
                .text "?"
                nop
                jmp dknern      ;translate result code to error

LA731:
                lda LC29D       ;get attempt counter
                cmp #$06        ;if done in one try then show clean track
                beq LA740
                jsr vstrng      ;else print "?   "
                .text "?   "
                nop
LA740:
                bit L00C9       ;if formatting
                bpl LA747
                jsr LA798       ;then add 10 sectors to volume size
LA747:
                inc LC290+$07   ;increment track number
                lda LC290+$07   ;get new track number
                cmp LC29F       ;compare with number of tracks to process
                bne LA6DA       ;if less then process next track
                bit L00C9       ;else test command type
                bpl LA759       ;if formatting
                jsr L93A5       ;then write volume catalogue as-is
LA759:
                jmp pcrlf       ;print newline to finish.

LA75C:                          ;Set up OSWORD $7F control block for formatting
                ldx #$00
                stx LC290+$01   ;LSB data address = 0
                stx LC290+$0A   ;4th parm, gap5 = 0
                dex
                stx LC290+$03   ;high bytes of address = $FF
                stx LC290+$04
                lda frpage      ;3MSB data address= OSHWM
                sta LC290+$02
                lda #$05        ;5 parameters
                sta LC290+$05
                lda #$63        ;$63 = format track
                sta LC290+$06
                lda #$2A
                sta LC290+$09   ;3rd parm, 10 * 256-byte sectors
                ldx #$10
                ldy #$13
                stx LC290+$0B   ;5th parm, gap1
                sty LC290+$08   ;2nd parm, gap3
                rts

LA78B:                          ;Clear volume catalogue
                lda #$00
                tay
LA78E:
                sta dirlow,y
                sta dirhig,y
                iny
                bne LA78E
                rts

LA798:                          ;Add 10 sectors to volume size
                lda #$0A        ;10 sectors per track
                clc
                adc dirhig+$07  ;add to LSB volume size
                sta dirhig+$07  ;update LSB
                bcc LA7A6       ;carry out to MSB in bits 1,0
                inc dirhig+$06  ;(previously cleared)
LA7A6:
                rts

LA7A7:                          ;Create ID table
                lda #$00        ;set up pointer to start of user memory
                sta temp+$00    ;clear LSB, start on page boundary
                lda frpage      ;get OSHWM
                sta temp+$01    ;store MSB of pointer
                lda #$0A        ;10 CHRN records to compose
                sta xtemp
                lda LC290+$07   ;1st parm, track number
                beq LA7C3       ;if formatting track 0 then first sector = 0
                ldy #$02        ;else get R parameter of first sector
                lda (temp),y
                clc             ;add track skew = 10 - 7 = 3
                adc #$07        ;same R occurs 3 sectors later
                jsr LA7E4       ;a := a mod 10
LA7C3:
                tax             ;first sector of track to X
                ldy #$00        ;point to C field of first sector
LA7C6:
                lda LC290+$07   ;1st parm, track number
                sta (temp),y    ;store cylinder number  C
                iny
                lda #$00        ;head number = 0
                sta (temp),y    ;store head humber      H
                iny
                txa             ;transfer sector number to A
                sta (temp),y    ;store record number    R
                iny
                lda #$01        ;size code = 1, 256-byte sector
                sta (temp),y    ;store size code        N
                iny
                inx             ;increment sector number
                jsr LA7E3       ;x := x mod 10
                dec xtemp       ;loop until all CHRN records composed
                bne LA7C6
                rts

LA7E3:                          ;x := x mod 10
                txa
LA7E4:                          ;a := a mod 10
                sec             ;set carry flag for subtraction
LA7E5:
                sbc #$0A        ;subtract 10
                bcs LA7E5       ;until A underflows
                adc #$0A        ;c=0; undo last subtraction
                tax             ;leave positive remainder in A and X
                rts

                .if SQUEEZE
LA7ED:                          ;Calculate number of tracks on current drive
                jsr L93A9       ;load catalogue with execute privilege
                lda dirhig+$06  ;get boot option/top bits volume size
                and #$03        ;extract volume size in b1,b0
                tay             ;save MSB volume size in Y
                lda dirhig+$07  ;get LSB volume size
                ldx #$FF        ;track number = $FF going to 0:
LA7FF:
                sec             ;set carry flag for subtract
LA800:
                inx             ;increment track number
                sbc #$0A        ;subtract 10 sectors for each track
                bcs LA800       ;loop until LSB underflows
                dey             ;borrow from MSB
                bpl LA7FF       ;loop until MSB underflows
                adc #$0A        ;c=0, add number of sectors per track
                beq LA811       ;if starting sector or remainder >0
                inx             ;then increment no. tracks containing data
LA811:
                rts
                .else
LA7ED:                          ;Calculate number of tracks on current drive
                jsr L93A9       ;load catalogue with execute privilege
                lda dirhig+$06  ;get boot option/top bits volume size
                and #$03        ;extract volume size in b1,b0
                tax             ;save MSB volume size in X
                lda dirhig+$07  ;get LSB volume size
                ldy #$0A        ;10 sectors per track
                sty temp        ;can save 4 bytes
                ldy #$FF        ;track number = $FF going to 0:
LA7FF:
                sec             ;set carry flag for subtract
LA800:
                iny             ;increment track number
                sbc temp        ;SBC #$0A faster since temp=$0A
                bcs LA800       ;loop until LSB underflows
                dex             ;borrow from MSB
                bpl LA7FF       ;loop until MSB underflows
                adc temp        ;c=0, add number of sectors per track
                pha             ;=starting sector or remainder, save
                tya             ;copy track number to X
                tax             ;can save 4 bytes (accumulate directly into X)
                pla             ;restore remainder
                beq LA811       ;if >0
                inx             ;then increment no. tracks containing data
LA811:
                rts
                .endif

free:                           ;*FREE
                sec             ;no map display required
                bcs LA816       ;branch (always)

map:                            ;*MAP
                clc             ;display disc usage map
LA816:
                ror L00C6       ;store *FREE flag
                jsr readrv      ;select specified or default drive
                jsr getdir      ;load volume catalogue
                bit L00C6       ;if *MAP called
                bmi LA837
                jsr ustrng      ;then print "Address :  Length" +CR
                .text "Address :  Length"
                .char $0D
LA837:
                lda dirhig+$06  ;get boot option/top bits volume size
                and #$03        ;extract volume size in b1,b0
                sta todohi      ;store MSB volume size
                sta headhi      ;store MSB data area size
                lda dirhig+$07  ;get LSB volume size
                sta todolo      ;store LSB volume size
                sec             ;subtract 2 sectors for volume catalogue
                sbc #$02
                sta headlo      ;store LSB data area size
                bcs LA84E       ;borrow in from MSB
                dec headhi
LA84E:
                lda #$02        ;set LSB start of data area = $02
                sta baselo      ;after volume catalogue
                lda #$00        ;set MSB start of data area = $00
                sta basehi
                sta freelo      ;clear amount of free space found
                sta freehi
                lda dirlen      ;get pointer to last catalogue entry
                and #$F8        ;mask off b2..b0
                tay             ;to Y as offset
                beq LA88A       ;if no files then print free space/summary
                bne LA875

LA864:
                jsr LA901       ;calculate end LBA of next file
                jsr unstep      ;subtract 8 from Y
                lda todolo      ;get LSB volume size
                sec             ;subtract LSB end LBA
                sbc baselo      ;and discard result
                lda todohi      ;get MSB volume size
                sbc basehi      ;subtract MSB end LBA
                bcc LA88A       ;if file beyond end of volume then print summary
LA875:
                lda cathig-$01,y ;get LSB start LBA of next file
                sec             ;subtract LSB end LBA of current file
                sbc baselo
                sta headlo      ;store LSB headroom/amount of free space
                .if SQUEEZE
                .else
                php             ;redundant
                .endif
                lda cathig-$02,y ;get top bits exec/length/load/start sector
                and #$03        ;extract MSB start LBA of next file
                .if SQUEEZE
                .else
                plp             ;redundant
                .endif
                sbc basehi      ;subtract MSB end LBA of current file
                sta headhi      ;store MSB headroom/amount of free space
                bcc LA864       ;if negative then overlaps next file, skip file!
LA88A:
                sty frecat      ;save current catalogue pointer
                bit L00C6       ;if *MAP called
                bmi LA899
                lda headlo      ;then test headroom/amount of free space
                ora headhi
                beq LA899       ;if headroom before next file
                jsr LA8DD       ;then print free space range.
LA899:
                lda headlo      ;add LSB headroom
                clc             ;to LSB total free space
                adc freelo
                sta freelo      ;update LSB total free space
                lda headhi      ;carry out and add MSB headroom
                adc freehi      ;to MSB total free space
                sta freehi      ;update MSB total free space
                ldy frecat      ;get number of catalogue entries to examine
                bne LA864       ;loop until all entries processed
                bit L00C6       ;if *FREE called
                bpl LA8DC
                tay             ;then XY = number of sectors free
                ldx freelo
                lda #$F8        ;set A=size of full catalogue = 31 files * 8
                sec             ;subtract number of used catalogue entries
                sbc dirlen      ;leave A=8 * number of free catalogue entries
                jsr LA92C       ;print summary line
                jsr ustrng      ;print "Free" +newline
                .text "Free"
                .char $0D
                lda todolo      ;get LSB volume size
                sec             ;subtract LSB total free space
                sbc freelo
                tax             ;put result in X
                lda todohi      ;get MSB volume size
                sbc freehi      ;subtract MSB total free space
                tay             ;put used space in XY
                lda dirlen      ;put number of used catalogue entries in A
                jsr LA92C       ;print summary line
                jsr ustrng      ;print "Used" +newline and exit.
                .text "Used"
                .char $0D
                nop
LA8DC:
                rts

LA8DD:                          ;Print free space range
                lda basehi      ;get MSB end of file/start of free space
                jsr LA9E9       ;print hex nibble
                lda baselo      ;get LSB end of file/start of free space
                jsr LA9E1       ;print hex byte
                jsr ustrng      ;print "     :  "
                .text "     :  "
                lda headhi      ;get MSB headroom/size of free space
                jsr LA9E9       ;print hex nibble
                lda headlo      ;get LSB headroom/sise of free space
                jsr LA9E1       ;print hex byte
                lda #$0D        ;print newline:
                jsr osasci
LA901:                          ;Calculate end LBA of next file
                lda cathig-$02,y ;get top bits exec/length/load/start sector
                pha             ;save them
                jsr isolen      ;extract b5,b4
                sta basehi      ;hold MSB file length
                pla             ;restore top bits
                and #$03        ;extract MSB start sector in b1,b0
                clc             ;add MSB file length
                adc basehi
                sta basehi      ;store MSB end sector (uncorrected)
                lda cathig-$04,y ;get LSB file length
                .if SQUEEZE
                cmp #$01        ;c=0 if whole sectors or C=1 if partial sector
                lda #$00
                .else
                beq LA919       ;can save 1 byte (CMP#1;LDA#0)
                lda #$01        ;a=0 if whole sectors or A=1 if partial sector
LA919:
                clc
                .endif
                adc cathig-$03,y ;add to 2MSB file length = LSB length in sectors
                bcc LA921       ;on overflow A=0, increment MSB end sector
                inc basehi      ;if this INC, then not the other
LA921:
                clc
                adc cathig-$01,y ;add LSB length in sectors to LSB start LBA
                sta baselo      ;store LSB end LBA
                bcc LA92B       ;carry out to MSB end LBA
                inc basehi
LA92B:
                rts

LA92C:                          ;Print summary line
                jsr sthree      ;divide catalogue index by 8 = number of files
                jsr LA9DE       ;print decimal byte
                jsr ustrng      ;print " Files "
                .text " Files "
                stx intwa+$01   ;store 3MSB number of bytes
                sty intwa+$02   ;store 2MSB number of bytes
                tya             ;put MSB number of sectors in A
                jsr LA9E9       ;print hex nibble
                txa             ;put LSB number of sectors in A
                jsr LA9E1       ;print hex byte
                jsr ustrng      ;print " Sectors "
                .text " Sectors "
                lda #$00
                sta intwa+$00   ;clear LSB number of bytes
                sta intwa+$03   ;clear MSB number of bytes
                ldx #$1F        ;32 bits to shift
                stx bitcnt      ;10 characters to print
                ldx #$09        ;[BUG]should be 5 for efficiency
LA960:
                sta buffer,x    ;clear 10 digit counters
                dex
                bpl LA960
LA966:
                asl intwa+$00   ;double the integer
                rol intwa+$01   ;and shift one bit out of the top byte
                rol intwa+$02
                rol intwa+$03   ;into C
                ldx #$00        ;start at units digit
                ldy #$09        ;[BUG]should be 5
LA972:
                lda buffer,x    ;double digit and add C
                rol a
                cmp #$0A        ;if less than 10 then C=0
                bcc LA97C
                sbc #$0A        ;else subtract 10, C=1 in and out
LA97C:
                sta buffer,x    ;store updated digit
                inx             ;move to next digit up
                dey             ;decrement digit count
                bpl LA972       ;loop until 10 digits updated
                dec bitcnt      ;decrement bit shift count
                bpl LA966       ;loop until 32 bits shifted into digits
                ldy #$20        ;padding character = space
                ldx #$05        ;6 digits to print, branch always
LA98B:
                bne LA98F       ;if printing last (units) digit
                ldy #$2C        ;then Y=comma, force printing as a digit
LA98F:
                lda buffer,x    ;test digit
                bne LA99C       ;if non-zero then print it and all the rest
                cpy #$2C        ;else zero, test separator
                beq LA99C       ;if a comma then print "0"
                .if SQUEEZE
                tya             ;else a leading zero
                .else
                lda #$20        ;else a leading zero (can save 1 byte: TYA)
                .endif
                bne LA9A1       ;print a space (always)

LA99C:                          ;not a leading zero
                ldy #$2C        ;force all remaining digits to be printed
                .if SQUEEZE
                ora #$30        ;convert to ASCII digit "0".."9"
                .else
                clc             ;convert to ASCII digit "0".."9"
                adc #$30        ;can save 1 byte (ORA #$30)
                .endif
LA9A1:
                jsr osasci      ;print digit or padding space
                cpx #$03        ;if separator column reached
                bne LA9AC
                tya             ;then print comma or space
                jsr osasci
LA9AC:
                dex             ;decrement number of digits remaining
                bpl LA98B       ;loop until all digits printed
                jsr ustrng      ;print " Bytes "
                .text " Bytes "
                nop
                rts             ;exit without newline

ustrng:                         ;Print string immediate (via OSASCI)
                sta itemp       ;save A on entry
                pla             ;pop caller's address into pointer
                sta ptemp+$00
                pla
                sta ptemp+$01
                lda itemp       ;restore A on entry and save on stack
                pha
                tya             ;save Y
                pha
                ldy #$00        ;set Y=0 for indirect indexed load
ustrlp:
                jsr tmpinc      ;increment ptemp
                lda (ptemp),y   ;get character from after JSR
                bmi ustrnx      ;if b7=1 then opcode terminator, execute it
                jsr osasci      ;else print character
                jmp ustrlp      ;and loop

ustrnx:
                pla             ;restore AY
                tay
                pla
                clc             ;jump to address of end of string with C=0
                jmp (ptemp)

LA9DE:
                jsr L8426       ;convert binary value in A to BCD
LA9E1:
                pha             ;save lower nibble
                jsr sfour       ;shift A right 4 places
                jsr LA9E9       ;print hex nibble (via OSASCI)
                pla             ;restore lower nibble:
LA9E9:                          ;Print hex nibble (via OSASCI)
                jsr digut1      ;convert hex nibble to ASCII
                jmp osasci      ;print via OSASCI and exit

pdspc:                          ;Print two spaces
                jsr pspace      ;print a space:
pspace:                         ;Print a space
                pha             ;save A
                lda #$20        ;set A = space character
                jsr osasci      ;print via OSASCI
                pla             ;restore A
                clc             ;exit C=0
                rts

LA9FB:                          ;Z-BREAK
                jsr savita      ;save AXY
                lda #$40        ;set b6 of 40-track flag on drive 0
                sta LC2DE       ;enable i8271 emulation on drive 0
                lda #$A8        ;(tested at L8D49)
                jsr readby      ;OSBYTE $A8 = read address of ROM pointer table
                stx temp+$00    ;set up pointer in zero page
                sty temp+$01
                ldy #$0F        ;$0F = offset of EBYTEV in extended vector table
                lda #$4C        ;instruction at LC2E2 = JMP absolute
                sta LC2E2+$00   ;set up trampoline to previous OSBYTE handler
                lda bytev+$00   ;get LSB of existing BYTEV
                sta LC2E2+$01   ;store LSB of trampoline jump address
                lda bytev+$01   ;get MSB of existing BYTEV
                sta LC2E2+$02   ;store MSB of trampoline jump address
                php             ;save interrupt flag state
                sei             ;disable interrupts
                lda #$0F        ;$0F = LSB of ROMBYT extended vector entry point
                sta bytev+$00   ;store LSB of BYTEV
                lda #$FF        ;$FF = MSB of ROMBYT extended vector entry point
                sta bytev+$01   ;store MSB of BYTEV
                lda #<LAA3B     ;set A = LSB address of OSBYTE handler
                sta (temp),y    ;store new LSB of address in EBYTEV
                iny             ;$10 = offset of MSB of address in EBYTEV
                lda #>LAA3B     ;set A = LSB address of OSBYTE handler
                sta (temp),y    ;store new MSB of address in EBYTEV
                iny             ;$11 = offset of ROM slot number in EBYTEV
                lda romid       ;get our paged ROM slot number
                sta (temp),y    ;store new ROM slot number in EBYTEV
                plp             ;restore interrupt flag state and exit
                rts

LAA3B:                          ;OSBYTE handler
                cmp #$00        ;OSBYTE $00 = display MOS version
                beq LAA50       ;if A=$00 then branch to handler
                cmp #$81        ;OSBYTE $81 = read key within time limit
                bne LAA4D       ;if A<>$81 and A<>0 then pass to previous handler
                cpy #$FF        ;else INKEY.  test MSB of parameter
                bne LAA4D       ;if <-256 or >=0 then pass to previous handler
                cpx #$00        ;else test LSB parameter
                bne LAA4D       ;if parameter <>-256 then pass call on
                dex             ;else INKEY(-256). return $FFFF = -1
                rts             ;meaning MOS 1.00/1.20

LAA4D:                          ;Jump to previous OSBYTE handler
                jmp LC2E2

LAA50:                          ;OSBYTE $00 = display MOS version
                php             ;save interrupt flag state
                sei             ;disable interrupts
                lda LC2E2+$01   ;get LSB previous OSBYTE handler address
                sta bytev+$00   ;set LSB of BYTEV
                lda LC2E2+$02   ;likewise with MSB
                sta bytev+$01   ;so that OSBYTE $00 cancels OSBYTE interception
                lda #$00        ;restore A=$00 OSBYTE call number on entry
                ldx #$01        ;return X=$01, MOS 1.20
                plp             ;restore interrupt flag state and exit
                rts             ;[BUG]doesn't print version even if X=0 on entry


;Start of SRAM 1.04

LAA64:                          ;Text of *HELP SRAM
                .text $0A,"SRAM 1.04",$0D,$0A
                .text "  SRDATA  <id.>",$0D,$0A
                .text "  SRLOAD  <filename> <sram address> (<id.>) (Q)",$0D,$0A
                .text "  SRREAD  <dest. start> <dest. end> <sram start> (<id.>)",$0D,$0A
                .text "  SRROM   <id.>",$0D,$0A
                .text "  SRSAVE  <filename> <sram start> <sram end> (<id.>) (Q)",$0D,$0A
                .text "  SRWRITE <source start> <source end> <sram start> (<id.>)",$0D,$0A
                .text "End addresses may be replaced by +<length>",$0D,$0A

LAB9F:                          ;Paged ROM service
                jsr L9ADE       ;offer service call to DFS
                pha             ;save call number on stack
                tax             ;and hold it in X
                lda L00B8+$00   ;save contents of private page pointer
                pha
                lda L00B8+$01
                pha
                tya             ;save service call parameter
                pha
                txa             ;restore call number to A
                ldx romid       ;put paged ROM slot number back in X
                jsr LB1FB       ;set up pointer to private page
                bit L00B8+$01   ;test MSB of pointer
                bpl LABBA       ;if address < $8000 then test b14
                bvc LABF7       ;if $8000 <= addr < $C000 then quit
                bvs LABBC       ;else addr >= $C000, handle call (always)

LABBA:
                bvs LABF7       ;if $4000 <= addr < $8000 then quit
LABBC:
                cmp #$08
                bne LABF0
                lda worda       ;Service call $08 = unrecognised OSWORD
                cmp #$43        ;get OSWORD reason code (in A on entry)
                bne LABD1       ;if OSWORD $43 = load/save sideways RAM
                jsr LACB3       ;then call its handler, then:
LABC9:
                tsx             ;transfer stack pointer to X
                lda #$00        ;return A=0 on exit
                sta stack+$04,x ;claim service call
                beq LABF7       ;quit service call handler (always)

LABD1:
                cmp #$42        ;if OSWORD $42 = block transfer SWRAM
                bne LABF7
                ldy #$09        ;then 10 bytes to copy:
LABD7:
                lda (wordx),y   ;copy offsets 8,9 from control block
                sta L00BC-$08,y ;to sideways address pointer, L00BC
                dey             ;2 bytes copied
                cpy #$08
                bcs LABD7       ;finish with Y=7
LABE1:
                lda (wordx),y   ;copy offsets 0..7 from control block
                sta L00B0,y     ;to workspace
                dey             ;loop until 8 bytes copied
                bpl LABE1
                cli             ;enable interrupts
                jsr LB6C0       ;do SWRAM block transfer
                jmp LABC9       ;claim service call and quit handler.

LABF0:
                cmp #$02        ;if not service call $02
                bne LAC03       ;then handle other service calls
                jsr LB263       ;else handle call $02 and pass it on:
LABF7:                          ;quit service call handler
                pla             ;restore service call parameter to Y
                tay
                pla             ;restore private page pointer
                sta L00B8+$01
                pla
                sta L00B8+$00
                pla             ;restore service call number to A
                ldx romid       ;put paged ROM slot number back in X
                rts             ;exit

LAC03:
                cmp #$06
                bne LAC15
                ldy #sramon     ;service call $06 = break
                lda (L00B8),y   ;get last byte of private page
                cmp #$4E        ;is it =$46, capital N?
                bne LABF7       ;if not then pass call on
                jsr LAFD7       ;else close SWRAM image file
                jmp LABF7       ;and then pass it on.

LAC15:
                cmp #$04
                bne LAC32
                jsr LB3C5       ;Service call $04 = unrecognised OSCLI
                bcs LABF7       ;scan for keyword in table
                asl a           ;double keyword number for use as offset
                beq LABF7       ;if keyword 0 (SRAM) then quit
                tax             ;else transfer to X as index
                lda LB53D-($01*$02)+$00,x ;get LSB of action address
                sta L00B0+$00   ;store in zero page
                lda LB53D-($01*$02)+$01,x ;get MSB of action address
                sta L00B0+$01   ;store in zero page
                jsr LACAF       ;call routine at action address
                jmp LABC9       ;claim service call and quit handler.

LAC32:
                cmp #$07
                bne LAC4F
                lda worda       ;Service call $07 = unrecognised OSBYTE
                cmp #$44        ;test OSBYTE call number
                bne LAC47       ;if A=$44 test RAM presence
                ldy #srwork+$00 ;then Y=$EE offset of RAM bitmap:
LAC3E:
                lda (L00B8),y   ;get byte from private page at offset in Y
                and #$3F        ;clear bits 7 and 6
                sta wordx       ;return value on exit from OSBYTE in X
                .if SQUEEZE
                bpl LABC9       ;claim service call and quit handler.
                .else
                jmp LABC9       ;claim service call and quit handler.
                                ;can save 1 byte: BPL/BRA LABC9 (just in range)
                .endif

LAC47:
                cmp #$45        ;if A<>$45
                bne LABF7       ;then quit service call handler
                ldy #srpsmp     ;else OSBYTE $45 = test pseudo-addressing bank use
                bne LAC3E       ;Y=$FD offset of pseudo bitmap, return in X

LAC4F:
                cmp #$09
                bne LABF7
                .if SQUEEZE
                                ;Service call $09 = *HELP
                jsr LB477       ;check for arguments
                .else
                lda #$0D        ;Service call $09 = *HELP
                jsr LB479       ;check for arguments (can save 2 bytes)
                .endif
                bcs LAC7E       ;if argument present then scan for keyword
                ldx #$00        ;else *HELP -clear offset into SRAM listing:
LAC5C:
                lda LAC6A,x     ;get character of *HELP listing
                jsr oswrch      ;print character using OSWRCH
                inx             ;increment offset
                cpx #LAC7E-LAC6A ;compare with length of listing
                bne LAC5C       ;loop until 20 characters of listing printed
LAC67:
                jmp LABF7       ;quit service call handler.

LAC6A:                          ;*HELP listing for SRAM
                .text $0A,"SRAM 1.04",$0D,$0A ;LF, "SRAM 1.04", CR, LF
                .text "  SRAM",$0D,$0A ;indent 2 spaces, "SRAM" keyword, CR, LF

;[BUG] *HELP with multiple keywords is ignored.  Only *HELP SRAM is accepted.

LAC7E:                          ;*HELP with keyword
                jsr LB3C5       ;scan for keyword in table
                bcc LAC8F       ;if match found then check keyword number
                lda (linptr),y  ;else mismatch.  test first char of keyword
                cmp #$2E        ;is it a dot?
                bne LAC67       ;if not then quit service call handler, else:
                jsr LB4B5       ;*HELP . -increment user offset past dot
                jmp LAC92       ;only one expansion, treat as *HELP SRAM

LAC8F:                          ;*HELP with matching keyword
                tax             ;if keyword number is not 0, SRAM
                bne LAC67       ;then quit service handler, else:
LAC92:                          ;*HELP SRAM
                jsr LB477       ;test for end of command line
                bcs LAC67       ;if characters present then quit svc handler
                ldy #$00        ;can save 2 bytes by printing whole page last
LAC99:
                lda LAA64+$0000,y ;print first page of *HELP SRAM
                jsr oswrch
                iny             ;loop until 256 characters printed
                bne LAC99
LACA2:
                lda LAA64+$0100,y ;print second page of *HELP SRAM
                jsr oswrch
                iny
                cpy #<(LAB9F-LAA64) ;compare offset with (length of text - 256)
                bne LACA2       ;loop until partial second page printed
                beq LAC67       ;then quit service call handler.

LACAF:                          ;Jump to action address
                jmp ($00B0)

                .if SQUEEZE
                .else
                                ;unreachable code
                rts
                .endif

LACB3:                          ;OSWORD $43 = load/save sideways RAM
                jsr LB1FB       ;set up pointer to private page
                lda #srwork     ;point it to SRAM OSWORD workspace
                sta L00B8+$00
                ldy #$0B        ;XY+11 = MSB of buffer length, last byte:
LACBC:
                lda (wordx),y   ;get byte of OSWORD control block
                cpy #$00        ;if at XY+0 = OSWORD mode bits
                bne LACCC
                and #$C0        ;then mask bits 7,6 direction and addressing mode
                sta L00BC+$00   ;store b7,b6 in zero page
                lda (L00B8),y   ;get SWRAM bitmap from private page
                and #$3F        ;mask off b7,b6, keep SWRAM bitmap
                ora L00BC+$00   ;replace mode bits with ones from control block
LACCC:
                sta (L00B8),y   ;store byte in SRAM workspace
                dey             ;decrement offset
                bpl LACBC       ;loop until 12 bytes copied
                cli             ;then enable interrupts:
LACD2:                          ;Load/save sideways RAM
                jsr LB1FB       ;set up pointer to private page
                lda #$00        ;OSARGS 0,0 = return current temporary filing system
                tay
                ldx #L00BA      ;x = scratch space pointer, unused
                jsr osargs
                pha             ;save current FS
                jsr LB1FB       ;set up pointer to private page
                ldy #srwork+$04 ;XY+4 = LSB of start address
                lda (L00B8),y   ;get LSB of address
                tax             ;hold in X
                iny             ;XY+5 = MSB of start address
                lda (L00B8),y   ;get MSB start address
                jsr LB22B       ;test OSWORD mode bits
                bvs LACFC       ;if b6=0 absolute addressing
                ldy #srwork+$03 ;then XY+3 = ROM ID
                lda (L00B8),y   ;get paged ROM slot number
                tay             ;hold in Y
                cpy #$14        ;if <20 = 16 real banks+4 mapped RAM banks
                bcc LAD0B       ;then use given slot number
LACF7:
                ldx #$00        ;else error 0, "Illegal parameter"
                jmp LB2CB       ;raise error by internal number

LACFC:                          ;pseudo-addressing selected
                jsr LB086       ;convert pseudo-address to absolute address
                sty L00BA+$00   ;store RAM pseudo-slot number
                ldy #srwork+$05 ;XY+5 = MSB start address
                sta (L00B8),y   ;store MSB of converted address
                txa             ;put LSB of converted address in A
                dey             ;XY+4 = LSB start address
                sta (L00B8),y   ;store LSB of converted address
                ldy L00BA+$00   ;restore RAM pseudo-slot number:
LAD0B:
                jsr LB0CF       ;test pseudo-addressing of slot Y
                tax             ;hold result in X
                tya             ;put real slot number in A
                ldy #srwork+$03 ;XY+3 = ROM ID
                sta (L00B8),y   ;store paged ROM slot number
                txa
                ldy #srwork+$00 ;XY+0 = OSWORD mode bits/RAM bitmap
                eor (L00B8),y   ;compare OSWORD addressing mode
                and #$40        ;with addressing mode of slot, mask result
                bne LACF7       ;if unequal then raise "Illegal parameter" error
                pla             ;else restore current temporary FS
                .if SQUEEZE
                .else
                tax             ;redundant
                .endif
                bne LAD26       ;if FS = 0
                ldx #$02        ;then error 2, "No filing system"
                jmp LB2CB       ;raise error by internal number

LAD26:
                pha             ;save current temporary FS
                jsr LB8AC       ;disable ROM slot if loading image
                pla             ;restore FS
                cmp #$04        ;if FS = 1 to 3, i.e. CFS or RFS
                bcs LADA9
                jsr LB22B       ;then test OSWORD mode bits
                bpl LAD64       ;if b7=1, loading to sideways RAM
                jsr LAFB3       ;then open sideways RAM image for reading
                jsr LAFEC       ;test EOF state of SWRAM image file
                bne LAD60       ;if end-of-file reached then close file and exit
                beq LAD41       ;else read bytes into SWRAM until EOF (always)

LAD3E:
                jsr LB044       ;increment transfer address
LAD41:
                ldy #sramfh     ;$FA = offset of SWRAM image file handle
                lda (L00B8),y   ;get file handle
                tay             ;transfer to Y as parameter
                jsr osbget      ;call OSBGET
                jsr LB1FB       ;set up pointer to private page
                ldy #srwork+$04 ;XY+4 = LSB of start address
                jsr LB20D       ;copy word from private page to general pointer
                tax             ;put byte read from file in X
                ldy #srwork+$03 ;XY+3 = ROM ID
                lda (L00B8),y   ;get paged ROM slot number from OSWORD wksp
                tay             ;transfer to Y for routine
                txa             ;put byte read from file in A
                jsr LB116       ;write byte to sideways RAM
                jsr LAFEC       ;test EOF state of SWRAM image file
                beq LAD3E       ;if not at end-of-file then read more bytes, else:
LAD60:
                .if SQUEEZE
                jmp LAFD7       ;close SWRAM image file and exit
                .else
                jsr LAFD7       ;close SWRAM image file and exit
                rts             ;(can save 1 byte)
                .endif

LAD64:
                jsr LAFD3       ;open sideways RAM image for writing
                jsr LAFFB       ;test number of bytes to be saved
                beq LAD60       ;if none remaining then close file and exit
                bne LAD71       ;else write bytes until count finished (always)

LAD6E:
                jsr LB044       ;increment transfer address
LAD71:
                ldy #srwork+$06 ;XY+6 = LSB of file length
                lda (L00B8),y   ;get LSB number of bytes to be saved
                sec             ;subtract 1
                sbc #$01
                sta (L00B8),y   ;store updated LSB
                .if SQUEEZE
                bcs LAD86       ;if no borrow then skip MSB
                iny             ;else XY+7 = MSB of file length
                lda (L00B8),y   ;get MSB number of bytes to be saved
                sbc #$00        ;c=0; subtract 1
                sta (L00B8),y   ;store updated MSB
                .else
                cmp #$FF        ;redundant (CC indicates borrow)
                bne LAD86       ;if no borrow then skip MSB
                iny             ;else XY+7 = MSB of file length
                lda (L00B8),y   ;get MSB number of bytes to be saved
                sec             ;redundant (CS from CMP; otherwise SBC #$00)
                sbc #$01        ;subtract 1
                sta (L00B8),y   ;store updated MSB
                .endif
LAD86:
                ldx #romptr     ;$F6 = OSRDSC read address
                ldy #srwork+$04 ;XY+4 = LSB of start address
                jsr LB20F       ;copy word from private page to zero page
                ldy #srwork+$03 ;XY+3 = ROM ID
                lda (L00B8),y   ;get paged ROM slot number from OSWORD wksp
                tay             ;transfer to Y as parameter
                jsr osrdsc      ;call OSRDSC
                tax             ;hold byte read from RAM in X
                ldy #sramfh     ;$FA = offset of SWRAM image file handle
                lda (L00B8),y   ;get file handle
                tay             ;transfer to Y as parameter
                txa             ;restore byte read from RAM to A
                jsr osbput      ;call OSBPUT
                jsr LB1FB       ;set up pointer to private page
                jsr LAFFB       ;test number of bytes to be saved
                bne LAD6E       ;if bytes remaining then write more bytes
                beq LAD60       ;else close SWRAM image file and exit (always)

LADA9:                          ;not CFS or RFS
                ldy #srwork+$0B ;XY+11 = MSB of buffer length
                lda (L00B8),y   ;get MSB
                bmi LADCD       ;if bit 7 set then use user memory
                dey             ;else XY+11 = LSB of buffer length
                ora (L00B8),y   ;or MSB with LSB
                bne LADF5       ;if buffer length >0 then use supplied buffer
                .if SQUEEZE
                rol a           ;else c=1; default buffer length = 256 bytes
                .else
                lda #$00        ;redundant
                sta (L00B8),y   ;redundant
                lda #$01        ;else default buffer length = 256 bytes
                .endif
                iny             ;XY+11 = MSB of buffer length
                sta (L00B8),y   ;LSB clear already, set XY+10 = $0100
                ldy #srwork+$08 ;XY+8 = LSB of buffer start address
                .if SQUEEZE
                lsr a           ;a=$00
                .else
                lda #$00        ;can save 1 byte (LSR A)
                .endif
                sta (L00B8),y   ;clear LSB of pointer, start on page boundary
                ldx L00B8+$01   ;get private page number
                inx             ;point to second private page
                txa             ;hold in A for storing
                iny             ;XY+9 = MSB of buffer start address
                sta (L00B8),y   ;store MSB of pointer
                .if SQUEEZE
                bne LADF5
                .else
                jmp LADF5
                .endif

LADCD:                          ;using user memory (Q)
                lda #$84        ;OSBYTE $84 = read top of user RAM
                jsr osbyte      ;call OSBYTE
                tya             ;save YX on stack
                pha
                txa
                pha
                lda #$83        ;OSBYTE $83 = read OS high water mark (OSHWM)
                jsr osbyte      ;call OSBYTE
                jsr LB1FB       ;set up pointer to private page
                stx L00BA+$00   ;set general pointer = OSHWM
                sty L00BA+$01
                ldy #srwork+$08 ;XY+8 = LSB of buffer start address
                jsr LB21C       ;copy word from general pointer to private page
                pla             ;restore LSB of HIMEM
                sec             ;subtract LSB of OSHWM
                sbc L00BA+$00
                ldy #srwork+$0A ;XY+10 = LSB of buffer length
                sta (L00B8),y   ;store LSB of buffer length
                pla             ;restore MSB of HIMEM
                sbc L00BA+$01   ;subtract MSB of OSHWM
                iny             ;XY+11 = MSB of buffer length
                sta (L00B8),y   ;store MSB of buffer length
LADF5:
                jsr LB22B       ;test OSWORD mode bits
                bmi LADFD       ;if b7=0 writing from sideways RAM
                jmp LAEC1       ;then jump to handler

LADFD:                          ;else reading to sideways RAM
                jsr LAFB3       ;open sideways RAM image for reading
                tsx             ;reserve 16 bytes on stack
                txa
                sec
                sbc #$10
                tax             ;X points to empty slot before reserved bytes
                txs             ;update stack pointer
                ldy #srwork+$02 ;XY+2 = MSB of file name address
                lda (L00B8),y   ;get MSB
                pha             ;push on stack before block
                dey             ;XY+1 = LSB of file name address
                lda (L00B8),y   ;get LSB
                pha             ;push on stack before MSB
                dex             ;point X to LSB
                ldy #>stack     ;point XY to new OSFILE block in stack page
                lda #$05        ;OSFILE   5 = read catalogue information
                jsr osfile      ;call OSFILE
                jsr LB1FB       ;set up pointer to private page
                tsx             ;point X to empty slot before LSB file name
                lda stack+$0B,x ;OSFILE XY+10 = LSB of object length
                ldy #srwork+$06 ;XY+6 = LSB of file length
                sta (L00B8),y   ;store in OSWORD workspace
                sta L00BA+$00   ;store in general pointer
                lda stack+$0C,x ;OSFILE XY+11 = 3MSB of object length
                iny             ;XY+7 = MSB of file length
                sta (L00B8),y   ;store in OSWORD workspace
                sta L00BA+$01   ;store in general pointer
                lda stack+$0D,x ;test MSB and 2MSB of OSFILE object length
                ora stack+$0E,x
                beq LAE3A       ;if file less than 64 KiB then accept, else:
LAE35:                          ;Raise "Illegal address" error
                ldx #$01        ;error number = 1
                jmp LB2CB       ;raise error by internal number

LAE3A:
                jsr LB23D       ;pop 18 bytes from stack
                bit LAF65       ;set V=1, default to loading in one (OSFILE)
                lda L00BA+$00   ;test 3MSB and LSB of OSFILE object length
                ora L00BA+$01
                bne LAE4A       ;if anything to transfer then proceed, else:
LAE46:
                jsr LAFD7       ;close SWRAM image file and exit
                rts

LAE4A:                          ;is like LAED7
                ldx #L00BC      ;$BC = buffer length
                ldy #srwork+$0A ;XY+10 = LSB of buffer length
                jsr LB20F       ;copy word from private page to zero page
                ldy #L00BA
                jsr LAF71       ;compare buffer length - file length
                bcs LAE5C       ;if file fits in buffer then read it all
                jsr LAF66       ;else set transfer size = buffer length
                clv             ;and V=0, needs multiple loads (OSGBPB)
LAE5C:
                ldy #sramln+$00 ;$FB = sideways RAM image file length
                jsr LB21C       ;copy word from general pointer to private page
                bvc LAE98       ;if file can be read in one
                jsr LAFD7       ;then close SWRAM image file
                tsx             ;reserve 13 bytes on stack
                txa
                sec
                sbc #$0B
                tax             ;X points to empty slot before reserved bytes
                txs             ;update stack pointer
                lda #$00        ;OSFILE XY+6 = LSB of execution address
                pha             ;in OSFILE $FF, XY+6=0 load to specified address
                lda #$FF        ;set high word of load address = $FFFF
                pha             ;load to I/O memory
                pha
                ldy #srwork+$09 ;XY+9 = MSB of buffer start address
                lda (L00B8),y   ;get MSB
                pha             ;OSFILE XY+3 = 3MSB of load address
                dey             ;XY+8 = LSB of buffer start address
                lda (L00B8),y   ;get LSB
                pha             ;OSFILE XY+2 = LSB of load address
                ldy #srwork+$02 ;XY+2 = MSB of file name address
                lda (L00B8),y   ;get MSB
                pha             ;push onto OSFILE control block
                dey             ;XY+1 = LSB of file name address
                lda (L00B8),y   ;get LSB
                pha             ;push onto OSFILE control block
                tsx             ;point X to empty slot before LSB file name
                inx             ;point X to LSB
                ldy #>stack     ;point XY to new OSFILE block in stack page
                lda #$FF        ;OSFILE $FF = load file
                jsr osfile      ;call OSFILE
                jsr LB1FB       ;set up pointer to private page
                jsr LB23D       ;pop 18 bytes from stack
                jmp LAE9D

LAE98:
                lda #$04        ;OSGBPB 4 = read from file at current pointer
                jsr LAF7E       ;transfer buffer to sideways RAM image
LAE9D:
                ldx #L00B1
                ldy #srwork+$08 ;XY+8 = LSB of buffer start address
                jsr LB20F       ;copy word from private page to zero page
                ldx #L00B3
                ldy #srwork+$04 ;XY+4 = LSB of start address
                jsr LB20F       ;copy word from private page to zero page
                ldx #L00BE
                ldy #sramln+$00 ;$FB = LSB transfer size
                jsr LB20F       ;copy word from private page to zero page
                sec
                jsr LB199
                ldx #L00B3      ;select L00B3, destination pointer
                jsr LB003       ;subtract transfer size from bytes remaining
                beq LAE46       ;if no bytes remain then close file and exit
                clv             ;else restore V=0, needs multiple loads
                .if SQUEEZE
                bne LAE4A       ;and loop (always).
                .else
                jmp LAE4A       ;and loop. can save 1 byte; BNE LAE4A
                .endif

LAEC1:                          ;OSWORD mode b7=0 writing from sideways RAM
                jsr LAFD3       ;open sideways RAM image for writing
                bit LAF65       ;set V=1, default to saving in one (OSFILE)
                php             ;flag held and manipulated on stack
LAEC8:
                ldy #srwork+$06 ;XY+6 = LSB of file length
                jsr LB20D
                jsr LAFFB       ;test number of bytes to be saved
                bne LAED7       ;if anything to transfer then proceed, else:
LAED2:
                plp             ;discard flags on stack
                jsr LAFD7       ;close SWRAM image file and exit
                rts

LAED7:                          ;is like LAE4A
                ldx #L00BC      ;$BC = buffer length
                ldy #srwork+$0A ;XY+10 = LSB of buffer length
                jsr LB20F       ;copy word from private page to zero page
                ldy #L00BA
                jsr LAF71       ;compare buffer length - file length
                bcs LAEEB       ;if file fits in buffer then save in one
                jsr LAF66       ;else set transfer size = buffer length
                plp
                clv             ;and V=0 on stack, needs multiple saves (OSGBPB)
                php
LAEEB:
                ldy #sramln+$00 ;$FB = LSB transfer size
                jsr LB21C       ;copy word from general pointer to private page
                ldx #L00B1
                ldy #srwork+$04 ;XY+4 = LSB of start address
                jsr LB20F       ;copy word from private page to zero page
                ldx #L00B3
                ldy #srwork+$08 ;XY+8 = LSB of buffer start address
                jsr LB20F       ;copy word from private page to zero page
                ldx #L00BE
                ldy #sramln+$00 ;$FB = LSB transfer size
                jsr LB20F       ;copy word from private page to zero page
                clc
                jsr LB199       ;transfer (L00BE) bytes to sideways RAM
                ldx #L00B1      ;select L00B1, source pointer
                jsr LB003       ;subtract transfer size from bytes remaining
                plp             ;retrieve flags from stack
                php             ;and push them back
                bvs LAF1D       ;if file can be saved in one then branch
                lda #$02        ;else OSGBPB 2 = write to file at current pointer
                jsr LAF7E       ;transfer buffer to sideways RAM image
                plp
                clv             ;set V=0 on stack, needs multiple saves (OSGBPB)
                php
                jmp LAEC8       ;and loop until transfer complete.

LAF1D:
                jsr LAFD7       ;close SWRAM image file
                lda #$FF        ;set high word, address in I/O memory
                pha
                pha
                ldy #srwork+$08 ;XY+8 = LSB of buffer start address
                jsr LB20D       ;copy word from private page to general pointer
                ldy #sramln+$00 ;$FB = LSB transfer size
                lda L00BA+$00   ;get LSB buffer start address
                clc             ;add LSB transfer size
                adc (L00B8),y
                tax             ;hold LSB end address in X
                lda L00BA+$01   ;get MSB buffer start address
                iny             ;XY+9 = LSB of buffer start address
                adc (L00B8),y   ;add MSB transfer size
                pha             ;push MSB end address onto OSFILE control block
                txa             ;push LSB end address
                pha             ;OSFILE XY+14 = LSB of end address or attributes
                lda #$FF        ;set high word, address in I/O memory
                pha
                pha
                lda L00BA+$01   ;get MSB buffer start address
                pha             ;push onto OSFILE control block
                lda L00BA+$00   ;get LSB buffer start address
                pha             ;OSFILE XY+10 = LSB of start address
                lda #$FF        ;push eight $FF bytes:
                ldx #$08
LAF47:
                pha             ;OSFILE XY+6 = LSB of execution address
                dex             ;OSFILE XY+2 = LSB of load address
                bne LAF47       ;file not executable, not for loading
                ldy #srwork+$02 ;XY+2 = MSB of file name address
                lda (L00B8),y   ;get MSB
                pha             ;push onto control block
                dey             ;XY+1 = LSB of file name address
                tsx             ;point X to empty slot to contain LSB
                lda (L00B8),y   ;get LSB
                pha             ;OSFILE XY+0 = LSB file name address
                ldy #>stack     ;point XY to new OSGBPB block in stack page
                lda #$00        ;OSFILE   0 = save file
                jsr osfile      ;call OSFILE
                jsr LB1FB       ;set up pointer to private page
                jsr LB23D
                jmp LAED2       ;close SWRAM image file (redundant) and exit

LAF65:                          ;constant with b6=1 for setting V with BIT
                .char $40

LAF66:                          ;Copy zero page word (X) to (Y)
                lda $00,x
                sta $0000,y
                lda $01,x
                sta $0001,y
                rts

LAF71:                          ;Compare zero page words (X) - (Y)
                lda $01,x       ;return Z=1 iff (X) == (Y)
                cmp $0001,y     ;       C=1 iff (X) >= (Y)
                bne LAF7D
                lda $00,x
                cmp $0000,y
LAF7D:
                rts

LAF7E:                          ;Transfer buffer to sideways RAM image
                pha             ;on entry A=OSGBPB reason code
                pha             ;push 4 copies as placeholders
                pha             ;OSGBPB XY+9..12 = file pointer
                pha
                lda #$00        ;clear high word, transfer <64 KiB
                pha
                pha
                ldy #sramln+$01 ;get MSB transfer size
                lda (L00B8),y
                pha             ;push onto OSGBPB control block
                dey             ;Y=$FB=sramln
                lda (L00B8),y   ;get LSB transfer size
                pha             ;OSGBPB XY+5..8 = no. bytes to transfer
                lda #$FF        ;set high word, address in I/O memory
                pha
                pha
                ldy #srwork+$09 ;XY+9 = MSB of buffer start address
                lda (L00B8),y   ;get MSB
                pha             ;push onto OSGBPB control block
                dey             ;XY+8 = LSB of buffer start address
                lda (L00B8),y   ;get LSB
                pha             ;OSGBPB XY+1..4 = transfer start address
                tsx             ;point X to empty slot to contain file handle
                ldy #sramfh
                lda (L00B8),y   ;get file handle
                pha             ;push onto control block where X points
                lda stack+$09,x ;get back OSGBPB reason code
                ldy #>stack     ;point XY to new OSGBPB block in stack page
                jsr osgbpb      ;call OSGBPB
                ldx #$0D        ;control block size = 13 bytes
                jsr LB23F       ;pop X bytes from stack
                jsr LB1FB       ;set up pointer to private page and exit
                rts

LAFB3:                          ;Open sideways RAM image for reading
                lda #$40        ;OSFIND $40 = open file for reading:
LAFB5:                          ;Open sideways RAM image
                pha             ;save file open mode
                ldy #srwork+$01 ;XY+1 = LSB of file name address
                lda (L00B8),y   ;get LSB
                tax             ;put in X for OSFIND
                iny             ;XY+2 = MSB of file name address
                lda (L00B8),y   ;get MSB
                tay             ;put in Y for OSFIND
                pla             ;restore file open mode to A
                jsr osfind      ;call OSFIND
                tax             ;test result, if A=0 no file opened
                bne LAFCB
                ldx #$04        ;then error 4 = "File not found"
                jmp LB2CB       ;raise error by internal number

LAFCB:
                ldy #sramfh     ;$FA = offset of SWRAM image file handle
                jsr LB1FB       ;set up pointer to private page
                sta (L00B8),y   ;store handle of opened file
LAFD2:
                rts

LAFD3:                          ;Open sideways RAM image for writing
                lda #$80        ;OSFIND $80 = open file for writing
                bne LAFB5       ;branch (always)

LAFD7:                          ;Close SWRAM image file
                ldy #sramfh     ;$FA = offset of SWRAM image file handle
                lda (L00B8),y   ;get file handle
                beq LAFD2       ;if no image file open then exit
                pha             ;else save file handle
                lda #$00        ;A=$00 no SWRAM image file open
                sta (L00B8),y   ;store value in SRAM workspace
                pla             ;restore file handle
                tay             ;transfer to Y as parameter
                lda #$00        ;OSFIND $00 = close a file/all files
                jsr osfind      ;call OSFIND
                jmp LB1FB       ;set up pointer to private page and exit

LAFEC:                          ;Test EOF state of SWRAM image file
                ldy #sramfh     ;$FA = offset of SWRAM image file handle
                lda (L00B8),y   ;get file handle
                tax             ;transfer to X as parameter
                lda #$01        ;FSC  1 = read EOF state
                jsr LB23A       ;issue Filing System Call
                jsr LB1FB       ;set up pointer to private page
                txa             ;return NE=end-of-file condition
                rts

LAFFB:                          ;Test number of bytes to be saved
                ldy #srwork+$06 ;XY+6 = LSB of file length
                lda (L00B8),y   ;get LSB of no. bytes to be saved
                iny             ;XY+7 = MSB of file length
                ora (L00B8),y   ;or with MSB, return EQ=no bytes remaining
                rts

LB003:                          ;Subtract transfer size from bytes remaining
                stx L00BC+$00   ;save address of pointer
                ldy #sramln+$00 ;$FB = sideways RAM image file length
                jsr LB20D       ;copy word from private page to general pointer
                ldy #srwork+$06 ;XY+6 = LSB of file length
                lda (L00B8),y   ;get LSB bytes transferred
                sec             ;subtract LSB SWRAM file length
                sbc L00BA+$00
                sta (L00B8),y   ;new LSB bytes remaining to [sramln+$00]
                sta L00BA+$00   ;and to general pointer
                iny             ;y = sramln+$01
                lda (L00B8),y
                sbc L00BA+$01
                sta (L00B8),y   ;new LSB bytes remaining to [sramln+$00]
                sta L00BA+$01   ;and to general pointer
                ora L00BA+$00   ;test L00BA == $0000
                beq LB043       ;if no bytes remaining then return Z=1
                ldx L00BC+$00   ;else restore address of pointer
                jsr LB22B       ;test OSWORD mode bits
                bvc LB03A       ;if b6=1, use pseudo-addressing
                lda $01,x       ;then test high byte of pointer
                cmp #$C0        ;if pointer has reached $C000
                bcc LB03A
                lda #<(LB263-LB253+lang) ;then reset it to $8010
                sta $00,x
                lda #>(LB263-LB253+lang)
                sta $01,x
                jsr LB070       ;and increment sideways RAM slot number
LB03A:
                ldx L00BC+$00   ;copy selected pointer to [sramln]
                ldy #srwork+$04 ;XY+4 = LSB of start address
                jsr LB21E       ;copy word from zero page to private page
                lda #$FF        ;return Z=0, bytes remaining to transfer
LB043:
                rts

LB044:                          ;Increment transfer address
                ldx #L00BD      ;point X to temporary workspace
                ldy #srwork+$04 ;XY+4 = LSB of start address
                jsr LB20F       ;copy word from private page to zero page
                inc L00BD+$00   ;increment LSB of address
                bne LB061       ;carry out to MSB
                inc L00BD+$01
                beq LB06D       ;if MSB overflows then raise "Illegal address"
                jsr LB22B       ;else test OSWORD mode bits
                bvc LB061       ;if b6=1 pseudo-addressing
                lda L00BD+$01   ;then test MSB of updated address
                cmp #$C0        ;if =$C0, overflowed into MOS/Hazel
                bne LB061
                .if BUGFIX
                lda #<(LB263-LB253+lang) ;then reset it to $8010
                sta L00BD+$00
                lda #>(LB263-LB253+lang)
                sta L00BD+$01
                .endif
                jsr LB070       ;then increment sideways RAM slot number
                                ;[BUG]does not restart at $8010??
LB061:
                lda L00BD+$00   ;get LSB of updated address
                ldy #srwork+$04 ;XY+4 = LSB of start address
                sta (L00B8),y   ;store LSB in OSWORD workspace
                lda L00BD+$01   ;get MSB of updated address
                iny             ;XY+5 = MSB of start address
                sta (L00B8),y   ;store MSB in OSWORD workspace and exit
                rts

LB06D:
                jmp LAE35       ;raise "Illegal address" error

LB070:                          ;Increment sideways RAM slot number
                ldy #srwork+$03 ;XY+3 = ROM ID
                lda (L00B8),y   ;get paged ROM slot number from OSWORD wksp
                clc             ;increment slot number
                adc #$01
                cmp #$08        ;if past 7, highest RAM slot on Master 128
                bcs LB06D       ;then raise "Illegal address" error
                .if SQUEEZE
                .else
                ldy #srwork+$03 ;else XY+3 = ROM ID (redundant)
                .endif
                sta (L00B8),y   ;store updated paged ROM slot number
                tay             ;transfer slot number to Y
                jsr LB0CF       ;test pseudo-addressing of slot Y
                beq LB06D       ;if slot absolutely addressed then "Illegal address"
                rts             ;else exit

LB086:                          ;Convert pseudo-address to absolute address
                ldy #$10        ;xa = address. start at pseudo-slot $10, "W":
LB088:
                cmp LB0AF-$10,y ;compare MSB - end address of bank Y
                bcc LB09F       ;if less then map address to bank Y
                bne LB097       ;if greater then skip to next bank
                pha             ;else save MSB
                txa             ;compare LSB - end address of bank Y
                cmp LB0AB-$10,y
                pla             ;result in C, restore MSB
                bcc LB09F       ;if address < end address then map to bank Y
LB097:
                iny             ;else increment bank number
                cpy #$14        ;if $13, "Z" or less
                bcc LB088       ;then loop
                jmp LAE35       ;else raise "Illegal address" error.

LB09F:                          ;Map pseudo-address in XA to address in bank Y
                pha             ;save MSB
                txa             ;transfer LSB to A
                clc             ;add LSB of offset to memory area of bank Y
                adc LB0B3-$10,y
                tax             ;return LSB of result in X
                pla             ;restore MSB to A
                adc LB0B7-$10,y ;add MSB of offset to memory area of bank Y
                rts             ;return absolute address in XA

;Table of mappings from pseudo-addresses to sideways RAM banks
LB0AB:                          ;LSBs of ends of pseudo-address segments
                .char <(($4000+LB253-LB263)*1)
                .char <(($4000+LB253-LB263)*2)
                .char <(($4000+LB253-LB263)*3)
                .char <(($4000+LB253-LB263)*4)
LB0AF:                          ;MSBs of ends of pseudo-address segments
                .char >(($4000+LB253-LB263)*1)
                .char >(($4000+LB253-LB263)*2)
                .char >(($4000+LB253-LB263)*3)
                .char >(($4000+LB253-LB263)*4)
LB0B3:                          ;LSBs of offsets from pseudo-address to RAM bank
                .char <($C000-($4000+LB253-LB263)*1)
                .char <($C000-($4000+LB253-LB263)*2)
                .char <($C000-($4000+LB253-LB263)*3)
                .char <($C000-($4000+LB253-LB263)*4)
LB0B7:                          ;LSBs of offsets from pseudo-address to RAM bank
                .char >($C000-($4000+LB253-LB263)*1)
                .char >($C000-($4000+LB253-LB263)*2)
                .char >($C000-($4000+LB253-LB263)*3)
                .char >($C000-($4000+LB253-LB263)*4)
                                ;NB +$C040 overflows and is effectively -$3FC0

LB0BB:                          ;Convert RAM pseudo-slot to real slot
                cpy #$10        ;if pseudo-slot number less than 16
                bcs LB0C0       ;then it is a real slot, return in Y
                rts

LB0C0:
                tya             ;else map to real slot number
                sec             ;on the Master 128, RAM is in slots 4 to 7
                sbc #$0C        ;so just subtract 12
                tay             ;and return result in Y.
                rts

                .if SQUEEZE
                .else
                                ;unreachable code
                tya
                and #$01
                ldy #$FE
                ora (L00B8),y
                tay
                rts
                .endif

LB0CF:                          ;Test pseudo-addressing of slot Y
                jsr LB0BB       ;convert RAM pseudo-slot to real slot
                tya             ;hold real slot number in X
                tax
                lda LB0F7,y     ;look up RAM bitmap mask for slot Y
                pha             ;save mask
                ldy #srwork+$00 ;$EE = offset of RAM bitmap
                and (L00B8),y   ;mask RAM bitmap
                bne LB0E9       ;if a RAM slot and RAM present then branch
                lda (L00B8),y   ;else get OSWORD mode bits/RAM bitmap
                and #$C0        ;mask OSWORD mode bits
                cmp #$80        ;if b7=1, b6=0 load to absolute address
                beq LB0E9       ;then accept command
                jmp LAE35       ;else raise "Illegal address" error

LB0E9:
                pla             ;restore mask
                ldy #srpsmp     ;set Y=$FD offset of pseudo-addressing bitmap
                and (L00B8),y   ;mask pseudo-addressing bitmap
                pha             ;save result
                txa             ;put real slot number back in Y
                tay
                pla             ;restore and test result
                beq LB0F6       ;if pseudo-addressing enabled for slot Y
                lda #$FF        ;then return A=$FF
LB0F6:
                rts             ;else A=0, slot Y absolutely addressed

;Table of sideways RAM banks installed in the Master 128
LB0F7:
                .char $00,$00,$00,$00 ;no RAM in slots 0 to 3
                .char $01,$02,$04,$08 ;bit masks of RAM banks 0 to 3
                .char $00,$00,$00,$00 ;no RAM in slots 8 to 11
                .char $00,$00,$00,$00 ;no RAM in slots 12 to 15

LB107:                          ;SWRAM write code copied to private page
                sty romid       ;set MOS copy of ROMSEL from Y
                sty romsw       ;page in sideways RAM slot in Y
                ldy #$00        ;clear Y for use as offset
                sta (L00BA),y   ;write byte in A to address in general pointer
                stx romid       ;set MOS copy of ROMSEL from X
                stx romsw       ;page SRAM back in and exit
                rts

LB116:                          ;Write byte to sideways RAM
                sta L00BF       ;save A in temp
                txa             ;save XY
                pha
                tya
                pha
                ldx romid       ;get our paged ROM slot number
                lda priptr,x    ;get first private page number for our slot
                sta L00B0+$01   ;set MSB of private page pointer
                inc L00B0+$01   ;increment to point to second page
                lda #$00        ;clear LSB of pointer
                sta L00B0+$00
                ldy #$0E        ;15 bytes to copy:
LB12B:
                lda LB107,y     ;get byte of SWRAM write code
                sta (L00B0),y   ;store at start of second page
                dey             ;loop until 15 bytes copied
                bpl LB12B       ;L00B0 points to the routine
                pla             ;restore Y
                pha             ;X contains ROM slot number
                tay
                lda L00BF       ;restore A
                jsr LACAF       ;write byte in A to (L00BA),Y
                pla             ;restore XY
                tay
                pla
                tax
                lda L00BF       ;restore A from temp and exit.
                rts

LB142:                          ;SWRAM transfer code pushed on stack
                sta romid       ;set MOS copy of ROMSEL from A
                sta romsw       ;set ROMSEL, select slot number in A
LB147:
                lda (L00B1),y   ;get byte from source pointer+Y
                sta (L00B3),y   ;store byte at target pointer+Y
                iny             ;increment offset
                bne LB153       ;loop until 256*n bytes copied
                inc L00B1+$01   ;then increment MSB source pointer
                inc L00B3+$01   ;and increment MSB target pointer
                dex             ;decrement MSB number of bytes
LB153:
                cpy L00B5+$00   ;compare Y - LSB number of bytes
                bne LB147       ;if unequal then loop
                txa             ;else test MSB number of bytes
                bne LB147       ;if more pages to do then loop
                pla             ;else pop our (SRAM) slot number
                sta romid       ;set MOS copy of ROMSEL from A
                sta romsw       ;page SRAM back in
                jmp LB182       ;jump back into ROM to finish

LB163:                          ;Transfer data to sideways RAM
                lda L00B5+$00   ;test number of bytes to transfer
                ora L00B5+$01
                beq LB198       ;if zero then nothing to do, exit
                ldx #LB163-LB142-$01 ;else transfer code has offsets 0..32:
LB16B:
                lda LB142,x     ;get byte of SWRAM transfer code
                pha             ;push on stack
                dex             ;loop until 33 bytes of code pushed
                bpl LB16B
                tsx             ;point X to empty slot before routine.
                lda romid       ;get our paged ROM slot number
                pha             ;push onto stack where X points
                lda #>stack     ;form MSB of routine call address
                pha             ;push $01 on stack
                txa             ;A = (start of routine)-$01
                pha             ;push LSB of routine call address
                lda L00B0a      ;get sideways RAM bank number in A
                ldx L00B5+$01   ;get MSB transfer size (no. pages) in X
                ldy #$00        ;clear offset, start transfer at pointers
                rts             ;jump to SWRAM transfer code on stack

LB182:
                ldx #LB163-LB142 ;$21 = transfer code size
                jsr LB23F       ;pop X bytes from stack
                ldx #$02        ;point X to destination address:
LB189:
                lda L00B1,x     ;get LSB of address
                clc             ;add number of bytes transferred
                adc L00B5+$00
                sta L00B1,x     ;update LSB of address
                bcc LB194       ;carry out to MSB
                inc L00B1+$01,x
LB194:
                dex             ;point X to source address
                dex
                bpl LB189       ;and loop once to update source address.
LB198:
                rts

LB199:                          ;Transfer (L00BE) bytes to sideways RAM
                ldy #srwork+$03 ;XY+3 = ROM ID
                lda (L00B8),y   ;get paged ROM slot number from OSWORD wksp
                sta L00B0a      ;store ROM slot number in zero page
                .if SQUEEZE
                lda #$00        ;clear b7..b2
                rol a           ;set b1 from carry flag, writing to SWRAM
                sec             ;set b0=1
                rol a
                sta L00B7       ;store resulting flag in zero page
                jsr LB22B       ;test OSWORD mode bits
                bvs LB1BD       ;if b6=1, pseudo-addressing then branch
                .else
                ldx L00BE+$00   ;set XY=number of bytes to transfer
                ldy L00BE+$01   ;can save 4 bytes (fall through to LB1B2)
                lda #$00        ;clear b7..b2
                rol a           ;set b1 from carry flag, writing to SWRAM
                asl a           ;set b0=1
                sta L00B7       ;store resulting flag in zero page
                inc L00B7       ;can save 1 byte (SEC:ROL A)
                jsr LB22B       ;test OSWORD mode bits
                bvs LB1BD       ;if b6=1, pseudo-addressing then branch
                bvc LB1B6       ;[BUG] should be BVC before BVS
                .endif

LB1B2:
                ldx L00BE+$00   ;set XY from L00BE:
                ldy L00BE+$01
LB1B6:                          ;Transfer XY bytes to sideways RAM
                stx L00B5+$00   ;set number of bytes to transfer from XY
                sty L00B5+$01
                jmp LB163       ;and transfer data to sideways RAM.

LB1BD:                          ;using pseudo-addressing.
                lda #$00        ;set A = LSB of end of SWRAM window, $C000
                sec
                ldx L00B7       ;point X to source or destination pointer
                sbc L00B1-$01,x ;subtract LSB of transfer start address
                sta L00B5+$00   ;= LSB distance to end of window, store
                lda #$C0        ;set A = MSB of end of SWRAM window, $C000
                sbc L00B1-$01+$01,x ;subtract MSB of transfer start address
                sta L00B5+$01   ;= MSB distance to end of window, store
                ldx #L00B5
                ldy #L00BE
                jsr LAF71       ;compare max transfer size - requested size
                bcs LB1B2       ;if request fits SWRAM bank then copy in one
                lda L00BE+$00   ;else get LSB requested transfer size
                sec             ;subtract LSB maximum transfer size
                sbc L00B5+$00
                sta L00BE+$00   ;update LSB of remaining transfer size
                lda L00BE+$01   ;get MSB requested transfer size
                sbc L00B5+$01   ;subtract MSB maximum transfer size
                sta L00BE+$01   ;update MSB of remaining transfer size
                jsr LB163       ;transfer data to sideways RAM
                lda #<(LB263-LB253+lang) ;reset source or destination pointer
                ldx L00B7       ;to $8010
                sta L00B1-$01,x
                lda #>(LB263-LB253+lang)
                sta L00B1-$01+$01,x
                jsr LB070       ;increment sideways RAM slot number
                ldy #srwork+$03 ;XY+3 = ROM ID
                lda (L00B8),y   ;get paged ROM slot number from OSWORD wksp
                sta L00B0a      ;save updated slot number in zero page
                jmp LB1BD       ;and loop back to transfer more.

LB1FB:                          ;Set up pointer to private page
                pha             ;save AX
                txa
                pha
                lda #$00        ;clear LSB of pointer
                sta L00B8+$00
                ldx romid       ;get our paged ROM slot number
                lda priptr,x    ;get private page number for our slot
                sta L00B8+$01   ;set MSB of pointer to private page
                pla             ;restore AX and exit.
                tax
                pla
                rts

LB20D:                          ;Copy word from private page to general pointer
                ldx #L00BA      ;point X to general pointer:
LB20F:                          ;Copy word from private page to zero page
                pha             ;preserve A on entry
                lda (L00B8),y   ;get LSB of word from private page
                sta $00,x       ;store in zero page byte addressed by X
                iny             ;increment Y to point to MSB
                lda (L00B8),y   ;get MSB of word from private page
                sta $01,x       ;store in zero page byte addressed by X+1
                dey             ;restore Y on entry
                pla             ;restore A on entry
                rts             ;exit

LB21C:                          ;Copy word from general pointer to private page
                ldx #L00BA      ;point X to general pointer:
LB21E:                          ;Copy word from zero page to private page
                pha             ;preserve A on entry
                lda $00,x       ;get zero page byte addressed by X
                sta (L00B8),y   ;store LSB of word in private page
                iny             ;increment Y to point to MSB
                lda $01,x       ;get zero page byte addressed by X+1
                sta (L00B8),y   ;store MSB of word in private page
                dey             ;restore Y on entry
                pla             ;restore A on entry
                rts             ;exit

LB22B:                          ;Test OSWORD mode bits
                pha             ;save AY
                tya
                pha
                ldy #srwork+$00 ;XY+0 = OSWORD mode bits/RAM bitmap
                lda (L00B8),y   ;get mode bits in b7,b6
                sta L00F6       ;romptr+$00 used as a temp
                pla             ;restore AY
                tay
                pla
                bit L00F6       ;return N=load to SWRAM, V=use pseudo-addressing
                rts

LB23A:                          ;Issue Filing System Call
                jmp (fscv)

LB23D:                          ;Pop 18 bytes from stack
                ldx #$12
LB23F:                          ;Pop X bytes from stack
                stx L00F7       ;romptr+$01 used as a temp
                pla             ;save LSB return address in Y
                tay
                pla             ;save MSB return address in temp
                sta L00F6       ;romptr+$00 used as a temp
                tsx             ;stack pointer to A
                txa
                clc             ;add number of bytes to discard
                adc L00F7
                tax             ;update stack pointer from A
                txs
                lda L00F6       ;restore MSB return address
                pha             ;push on stack
                tya             ;restore LSB return address
                pha             ;push on stack
                rts             ;return to caller.

LB253:                          ;Header copied to pseudo-addressed RAM banks
                rts             ;$8000, language entry: return

                .char $00,$00

                rts             ;$8003, service entry: return

                .char $00,$00
LB259:
                .char $02       ;$8006, ROM type: no service, no language, no Tube address, 6502 format
                .char $0C       ;$8007, copyright string offset: =$800C (LB25F)
                .char $FF       ;$8008, binary version number
                .text "RAM"     ;$8009, ROM title terminated by NUL
LB25F:
                .char $00       ;copyright string: NUL followed by "(C)"
                .text "(C)"

LB263:                          ;Service call $02 = reserve private workspace
                lda #$00
                ldy #srpsmp     ;set Y=$FD offset of pseudo-addressing bitmap
                sta (L00B8),y   ;clear pseudo-addressing for all slots
                ldy #srwork+$00 ;set Y=$EE offset of RAM bitmap
                sta (L00B8),y   ;set all slots to ROM
                ldy #sramfh
                sta (L00B8),y   ;no SWRAM image file open
                ldy #sramon
                lda #$4E        ;SRAM initialised/close SWRAM image file on BRK
                sta (L00B8),y
                ldy #$0F        ;start at slot 15:
LB279:
                lda LB0F7,y     ;look up RAM table for slot Y
                beq LB2C7       ;if slot marked as ROM then skip
                tya             ;else save SWRAM bank number (used by OSRDSC)
                pha
                lda #<(lang+$08) ;set A=LSB address of binary version no, $8008
                sta romptr+$00  ;set LSB read address for OSRDSC
                sta L00BA+$00   ;set LSB write address for LB116
                lda #>(lang+$08) ;set A=MSB address of binary version no, $8008
                sta romptr+$01  ;set MSB read address for OSRDSC
                sta L00BA+$01   ;set MSB write address for LB116
                jsr osrdsc      ;read byte from sideways RAM
                sta L00BD+$00   ;store read value in temp
                pla             ;restore SWRAM bank number to Y
                pha
                tay
                lda L00BD+$00   ;get back byte read
                eor #$FF        ;invert value
                jsr LB116       ;write byte to sideways RAM
                jsr osrdsc      ;read byte back from sideways RAM
                cmp L00BD+$00   ;compare with value read originally
                beq LB2C5       ;if the same then ROM, skip bank
                pla             ;else restore SWRAM bank number to X
                pha
                tax
                ldy #srwork+$00 ;set Y=$EE offset of RAM bitmap
                lda (L00B8),y   ;get current value of bitmap
                ora LB0F7,x     ;set bit corresponding to SWRAM bank in X
                sta (L00B8),y   ;update SWRAM bitmap
                txa             ;transfer SWRAM bank number to Y
                tay
                lda L00BD+$00   ;get back original value of $8008
                jsr LB116       ;write byte to sideways RAM
                jsr LB356       ;detect type of pseudo-addressed RAM in slot Y
                cmp #$02        ;if not $02 = valid pseudo-addressed RAM found
                bne LB2C5       ;then go to next bank
                lda LB0F7,y     ;else get bitmap bit corresponding to bank Y
                ldy #srpsmp     ;set Y=$FD offset of pseudo-addressing bitmap
                ora (L00B8),y   ;set bit corresponding to bank Y
                sta (L00B8),y   ;update pseudo-addressing bitmap
LB2C5:
                pla             ;restore SWRAM bank number to Y
                tay
LB2C7:
                dey             ;decrement bank number
                bpl LB279       ;loop until banks 15..0 tested, then exit.
                rts

LB2CB:                          ;Raise error by internal number
                .if SQUEEZE
                lda LB350,x     ;get OS error number
                sta errbuf+$01  ;set offset 1 = OS error number
                lda LB349+$01,x ;get offset of next error string
                sta L00BF       ;set loop terminator value
                ldy LB349,x     ;set Y = offset of error string
                ldx #$00        ;clear buffer offset
                stx errbuf+$00  ;set offset 0 of buffer = BRK
                .else
                lda #$00        ;number in X
                sta errbuf+$00  ;set offset 0 of buffer = BRK
                lda LB350,x     ;get OS error number
                sta errbuf+$01  ;set offset 1 = OS error number
                lda LB349+$01,x ;get offset of next error string
                sta L00BF       ;set loop terminator value
                ldy LB349,x     ;set Y = offset of error string
                ldx #$00        ;clear buffer offset (can save 2, LDX):
                .endif
LB2E0:
                lda LB2F4,y     ;get character of error message
                sta stack+$02,x ;store in error buffer
                inx             ;increment buffer offset
                iny             ;increment table offset
                cpy L00BF       ;compare with offset of next error
                bcc LB2E0       ;loop if less
                lda #$00        ;else store $00, error message terminator
                sta stack+$02,x ;after last character of message
                jmp errbuf      ;execute BRK to raise error.

LB2F4:                          ;Table of error messages
eilprm:
                .text "Illegal parameter"
ebaddr:
                .text "Illegal address"
enofs:
                .text "No filing system"
ebcom:
                .text "Bad command"
enofil:
                .text "File not found"
erammo:
                .text "RAM occupied"
etable:

LB349:                          ;Table of error message offsets
                .char eilprm-LB2F4
                .char ebaddr-LB2F4
                .char enofs -LB2F4
                .char ebcom -LB2F4
                .char enofil-LB2F4
                .char erammo-LB2F4
                .char etable-LB2F4

LB350:                          ;Table of OS error numbers
                .char $80,$81,$82,$FE
                .char $D6,$83

LB356:                          ;Detect type of pseudo-addressed RAM in slot Y
                txa             ;save XY
                pha
                tya             ;Y = ROM slot number
                pha
                ldx #<(lang+$07) ;point ROMPTR to copyright string offset
                stx romptr+$00  ;at $8007
                lda #>(lang+$07)
                sta romptr+$01
                jsr osrdsc      ;get copyright offset
                sta romptr+$00  ;point ROMPTR to starting NUL of copyright string
                ldx #$00        ;set counter = 0:
LB369:
                stx L00BF       ;store counter in temp
                pla             ;restore ROM slot number to Y
                pha
                tay
                jsr osrdsc      ;read byte of copyright string
                ldx L00BF       ;restore counter
                cmp LB25F,x     ;compare with correct copyright string
                bne LB3BE       ;if unequal then return $FF = invalid paged ROM
                inc romptr+$00  ;else increment ROMPTR to point to next character
                bne LB37E       ;carry out to high byte
                inc romptr+$01
LB37E:
                inx             ;increment counter
                cpx #$04        ;loop until 4 bytes compared, NUL+"(C)"
                bcc LB369
                lda #$02        ;$02 = valid pseudo-addressed RAM found
                sta L00BF
                ldx #<(LB263-LB253-$01+lang) ;$0F = offset of last byte of header
                lda #>(LB263-LB253-$01+lang) ;set MSB of ROMPTR to first page of ROM:
                sta romptr+$01
LB38D:
                stx romptr+$00  ;set LSB of ROMPTR
                pla             ;restore ROM slot number to Y
                pha
                tay
                jsr osrdsc      ;get byte of first page of ROM
                ldx romptr+$00  ;restore counter
                cmp LB253,x     ;compare with pseudo-addressed RAM bank header
                bne LB3A9       ;if unequal then return $00 or $01
LB39C:
                dex             ;else step backwards through ROM
                cpx #LB259-LB253 ;loop until ROM type bytes compared at $8006
                bcs LB38D
LB3A1:
                clc             ;return C=0 valid ROM with copyright string:
LB3A2:
                pla             ;restore XY
                tay
                pla
                tax
                lda L00BF       ;return bank type in A
                rts

LB3A9:
                cpx #<(lang+$09+$01) ;if failure point is not 2nd char of title
                bne LB3B8       ;then return $00 = other valid ROM
                cmp #$4F        ;else if the character found is not "O"
                bne LB3B8       ;then return $00 = other valid ROM
                lda #$01        ;else $01 = valid pseudo-addressed ROM found
                sta L00BF
                .if SQUEEZE
                bne LB39C       ;loop to validate rest of header to $8006
                .else
                jmp LB39C       ;loop to validate rest of header to $8006
                                ;can save 1 byte: BNE / BRA
                .endif

LB3B8:                          ;return $00 = other valid ROM
                lda #$00        ;besides pseudo-addressed RAM or ROM bank
                sta L00BF
                beq LB3A1       ;return C=0 (always)

LB3BE:                          ;return C=1, A=$FF = valid ROM not found
                lda #$FF
                sta L00BF
                sec
                bcs LB3A2

LB3C5:                          ;Scan for keyword in table
                jsr LB46F       ;skip spaces in command line
                tya             ;save offset of start of user word
                pha
                ldx #$00        ;clear offset into *command table:
LB3CC:
                bit LAF65       ;set V=1
LB3CF:
                lda (linptr),y  ;get character of user's command line
                and #$DF        ;convert to uppercase
                cmp #$0D        ;if equal to CR (or -, hackable??)
                beq LB3E5       ;then user word too short, reject command
                cmp LB506,x     ;else compare with character of *command table
                bne LB3F9       ;if unequal then handle mismatch/abbreviation
LB3DC:
                inx             ;else increment table offset
                lda LB506,x     ;test next character of command
                beq LB407       ;if terminator then accept command
                iny             ;else advance to next user word character
                bne LB3CF       ;and loop to compare rest of word (always)

LB3E5:                          ;reject command
                inx             ;step through *command table
                lda LB506,x     ;test byte of command word
                bne LB3E5       ;loop until terminator reached
                pla             ;pop user word start offset
                pha             ;push it back
                tay             ;and restore offset to Y
                inx             ;advance past terminator
                inx             ;advance past command number
                lda LB506,x     ;test first character of next *command
                bne LB3CC       ;if not end of table then compare next command
                pla             ;else discard offset of user word
                .if SQUEEZE
                .else
                tay             ;redundant, user word offset left in Y
                .endif
                sec             ;return C=1, *command not recognised
                rts

LB3F9:                          ;handle mismatch or abbreviation
                lda (linptr),y  ;get user's character complete with b5
                cmp #$2E        ;is it a dot?
                bne LB40E       ;if not then handle mismatch
                bvs LB3E5       ;else if V=1 then ambiguous abbreviation, reject else:
LB401:                          ;accept abbreviated command
                inx             ;step through *command table
                lda LB506,x     ;test byte of command word
                bne LB401       ;loop until terminator reached:
LB407:                          ;accept command
                pla             ;discard offset of user word
                lda LB506+$01,x ;get command number
                iny             ;advance past last character of user's word
                clc             ;return C=0, *command recognised, number in A
                rts

LB40E:
                ora #$20        ;convert to lowercase
                cmp LB506,x     ;compare with character of *command
                bne LB3E5       ;if unequal then reject command
                clv             ;else V=0, accept abbreviations AFTER this point
                bvc LB3DC       ;check rest of words match (always)
                                ;[BUG] BVC sensitive to glitches, use BEQ or BRA

;Note: when this code reaches the last letter of a command word and it
;is lowercase, LB3DC accepts the command immediately, even if the user's
;word continues (in contrast to the MOS parser and DFS above, wname0).
;This only applies to keyword 0, SRAM, used solely as a *HELP keyword.
;Commands such as *HELP SRAM. or *HELP SRAMX get as far as LAC92 where
;the presence of trailing characters (. or X) is tested and the requests
;are rejected.

LB418:                          ;Parse hexadecimal argument from command line
                txa             ;save X
                pha
                jsr LB46F       ;skip spaces in command line
                lda #$00        ;clear working area
                sta L00BC+$00
                sta L00BC+$01
                sta L00BC+$02
                sta L00BC+$03
                sec             ;c=1, argument invalid
                php             ;save result flag on stack
LB429:
                lda (linptr),y  ;get character of argument
                cmp #$30        ;if less than "0"
                bcc LB465       ;then return
                cmp #$3A        ;else if "9" or less
                bcc LB43D       ;then accept digit
                cmp #$47        ;else if greater than "F"
                bcs LB465       ;then return
                cmp #$41        ;else if less than "A"
                bcc LB465       ;then return
                sbc #$07        ;else C=1, subtract 7; "A".."F" -> 10..15:
LB43D:
                sec             ;subtract value of ASCII "0"
                sbc #$30
                plp             ;restore V=0 input 16 bits or V=1 input 32 bits
                php
                .if SQUEEZE
                .else
                pha             ;save current nibble (redundant)
                .endif
                ldx #$04        ;shift 4 bits into working area:
LB445:
                asl L00BC+$00   ;shift zero into LSB
                rol L00BC+$01   ;shift b7 into b8
                bvc LB44F       ;if word input then trap overflow here
                rol L00BC+$02   ;else shift b15 into b16
                rol L00BC+$03   ;shift b23 into b24, C=b31
LB44F:
                bcs LB461       ;if C=1 then overflow, return C=1 argument invalid
                dex             ;else loop until 4 bits shifted
                bne LB445
                .if SQUEEZE
                .else
                pla             ;restore current nibble (redundant)
                .endif
                ora L00BC+$00   ;or with LSB whose low nibble is zero
                sta L00BC+$00   ;update LSB
                plp             ;set C=0 on stack, argument valid
                clc
                php
                iny             ;skip to next character of argument
                beq LB462       ;if offset overflows then return C=1
                bcc LB429       ;else loop to process next character (always)

LB461:
                .if SQUEEZE
                .else
                pla             ;discard current nibble (redundant):
                .endif
LB462:
                plp             ;set C=1 on stack, argument invalid:
                sec
                php
LB465:
                plp             ;restore carry flag from stack
                pla             ;restore X and exit.
                tax
                rts

LB469:                          ;Skip current character and spaces in command line
                iny             ;increment command line offset
                bne LB46F       ;if not overflowed then loop
                jmp LB4AD       ;else raise "Bad command" error.

LB46F:                          ;Skip spaces in command line
                lda (linptr),y  ;get character of command line
                cmp #$20        ;is it a space?
                beq LB469       ;if so then advance and test next character
                clc             ;else return C=0.
                rts

LB477:                          ;Test for end of command line
                lda #$0D        ;i.e. next non-space character is CR:
LB479:                          ;Compare A with non-space character of command line
                pha             ;save comparand
                jsr LB46F       ;skip spaces in command line
                pla             ;restore comparand
                cmp (linptr),y  ;compare with character at index Y
                bne LB485       ;if unequal then return C=1
                clc             ;else return C=0, character found
                iny             ;and skip the character.
                rts

LB485:
                sec
                rts

LB487:                          ;Address and ensure first argument
                jsr LB46F       ;skip spaces in command line
                tya             ;save offset of command line tail
                pha
                clc             ;add LSB of address of command line
                adc linptr+$00
                ldy #srwork+$01
                sta (L00B8),y   ;store in private page
                lda linptr+$01  ;carry out to MSB of address
                adc #$00
                iny             ;y=$F0
                sta (L00B8),y   ;store in private page
                pla             ;restore command line tail offset
                tay
                bit LAF65       ;set V=1, no argument present:
LB49F:
                lda (linptr),y  ;get character of command line
                cmp #$20        ;if it's a space
                beq LB4B2       ;then stop scanning
                cmp #$0D        ;if it's CR
                beq LB4B2       ;then stop scanning
                clv             ;else it's part of an argument, V=0
                iny             ;loop until end of first argument reached
                bne LB49F       ;if no CR or space in 256 characters then:
LB4AD:                          ;Raise "Bad command" error
                ldx #$03        ;internal error number = 3
                jmp LB2CB       ;raise error by internal number

LB4B2:                          ;end of first argument reached
                bvs LB4AD       ;if no argument present then "Bad command"
                rts             ;else exit

LB4B5:
                iny             ;increment offset
                beq LB4AD       ;if offset overflows then "Bad command"
                rts             ;else return

LB4B9:                          ;Parse bank specifier
                stx L00BF       ;save X in temp
                jsr LB46F       ;skip spaces in command line
                lda (linptr),y  ;get bank specifier character
                ldx #$03        ;4 ranges to test, 3..0:
LB4C2:
                cmp LB4FE,x     ;if beyond end of current range
                bcs LB4F6       ;then invalid, exit C=1
                cmp LB4FA,x     ;else if before start of range
                bcc LB4F3       ;then try next range
                sbc LB502,x     ;else convert to bank number
                jsr LB4B5       ;increment offset
                cmp #$01        ;if bank number <> 1
                bne LB4EA       ;then return A=bank number, C=0
                lda (linptr),y  ;else it may be a two-digit argument
                cmp #$36        ;if next character > "5"
                bcs LB4E8       ;then return A=1, C=0
                cmp #$30        ;else if character < "0"
                bcc LB4E8       ;then return A=1, C=0
                sbc #$26        ;else C=1, convert second digit to 10..15
                jsr LB4B5       ;increment offset
                jmp LB4EA       ;return A=bank number, C=0

LB4E8:
                lda #$01        ;"1" with no more digits, return A=1:
LB4EA:
                pha             ;save bank number
                jsr LB46F       ;skip spaces in command line
                pla             ;restore bank number to A
                ldx L00BF       ;restore X
                clc             ;return C=0, bank number valid
                rts

LB4F3:
                dex             ;point X to next table entry
                bpl LB4C2       ;if more entries to test then loop, else:
LB4F6:
                ldx L00BF       ;restore X
                sec             ;return C=1, bank number invalid.
                rts

;Tables of ASCII to ROM bank mappings
;  $30..$39  "0".."9"  -> $00..$09
;  $41..$46  "A".."F"  -> $0A..$0F
;  $57..$5A  "W".."Z"  -> $10..$13 remapped to found RAM banks
;  $77..$7A  "w".."z"  -> $0D..$10 [BUG]

LB4FA:
                .char $30,$41,$57,$77
LB4FE:
                .char $3A,$47,$5B,$7B
LB502:
                .if BUGFIX
                .char $30,$37,$47,$67
                .else
                .char $30,$37,$47,$6A
                .endif

LB506:                          ;Table of SRAM *commands
                .text "sram"
                .char $00,$00   ;command terminator, command number
                .text "SRlOAD"
                .char $00,$01
                .text "SRsAVE"
                .char $00,$02
                .text "SRwRITE"
                .char $00,$03
                .text "SRReAD"
                .char $00,$04
                .text "SRdATA"
                .char $00,$05
                .text "SRRoM"
                .char $00,$06
                .char $00       ;table terminator

LB53D:                          ;Table of SRAM *command addresses
                .word LB549     ;*SRLOAD                        $B549
                .word LB54D     ;*SRSAVE                        $B54D
                .word LB5DA     ;*SRWRITE                       $B5DA
                .word LB5DE     ;*SRREAD                        $B5DE
                .word LB63E     ;*SRDATA                        $B63E
                .word LB688     ;*SRROM                         $B688

LB549:                          ;*SRLOAD
                lda #$C0        ;b7=1 load to SWRAM, b6=1 use pseudo-addressing
                bne LB54F       ;enter routine with mode bits in A (always)

LB54D:                          ;*SRSAVE
                lda #$40        ;b7=0 save from SWRAM, b6=1 use pseudo-addressing
LB54F:
                pha             ;save mode bits on stack
                jsr LB487       ;address and ensure first argument
                clv             ;v=0 input 16-bit address
                jsr LB418       ;parse hexadecimal argument from command line
                bcs LB572       ;if argument invalid then raise "Bad command" error
                sty L00BA+$00   ;else save offset of end of argument
                ldx #L00BC      ;point X to converted argument
                ldy #srwork+$04 ;XY+4 = LSB of start address
                jsr LB21E       ;copy word from zero page to private page
                ldy L00BA+$00   ;restore offset of end of argument
                pla             ;test command type and preserve on stack
                pha
                bmi LB593       ;if doing *SRSAVE
                lda #$2B        ;then set A="+"
                jsr LB479       ;compare A with non-space character of command line
                php             ;save result
                clv             ;v=0 input 16-bit address
                jsr LB418       ;parse hexadecimal argument from command line
LB572:
                bcs LB5D7       ;if argument invalid then raise "Bad command" error
                sty L00BA+$00   ;else save offset of end of argument
                plp             ;restore result of "+" test
                bcc LB58C       ;if "+" was not present
                ldy #srwork+$04 ;then the second argument is the end address
                .if SQUEEZE
                .else
                sec             ;(redundant)
                .endif
                lda L00BC+$00   ;get LSB end address
                sec             ;subtract LSB start address
                sbc (L00B8),y
                sta L00BC+$00   ;store LSB data transfer size
                iny
                lda L00BC+$01   ;get MSB end address
                sbc (L00B8),y   ;subtract MSB start address
                bcc LB5D7       ;if transfer size underflows then "Bad command"
                sta L00BC+$01   ;else store MSB data transfer size
LB58C:
                ldx #L00BC      ;point X to converted argument
                ldy #srwork+$06 ;XY+6 = LSB of file length
                jsr LB21E       ;copy word from zero page to private page
LB593:
                ldy L00BA+$00   ;restore offset of end of last argument
                jsr LB4B9       ;parse bank specifier
                sty L00BA+$00   ;save offset of end of argument
                bcs LB5A4       ;if a valid bank argument is present
                ldy #srwork+$03 ;then store bank number in private page
                sta (L00B8),y
                pla             ;and clear b6 of mode bits on stack
                and #$80        ;b6=use pseudo-addressing
                pha
LB5A4:
                pla
                sta L00BA+$01
                ldy #srwork+$00 ;y=$EE offset of RAM bitmap
                lda (L00B8),y   ;get OSWORD mode bits/RAM bitmap
                and #$3F        ;clear b7=load to SWRAM, b6=use pseudo-addressing
                ora L00BA+$01   ;apply mode bits generated by *command
                sta (L00B8),y   ;update mode bits/RAM bitmap
                ldy L00BA+$00   ;restore offset of end of last argument
                jsr LB46F       ;skip spaces in command line
                lda (linptr),y  ;get first character of next argument
                and #$DF        ;convert to uppercase
                ldx #$00        ;x=$00 do not use user memory for transfer
                cmp #$51        ;if character = "Q"
                bne LB5C5
                jsr LB4B5       ;then skip over it
                .if SQUEEZE
                dex             ;and flag fast transfer, X=$FF
                .else
                ldx #$FF        ;and flag fast transfer (can save 1 byte: DEX)
                .endif
LB5C5:
                jsr LB477       ;test for end of command line
                bcs LB5D7       ;if more arguments then raise "Bad command" error
                ldy #srwork+$0A ;XY+10 = LSB of buffer length
                lda #$00        ;buffer length = $0000 use default buffer/
                sta (L00B8),y   ;$FF00 use user memory OSHWM..HIMEM
                iny             ;XY+11 = MSB of buffer length
                txa
                sta (L00B8),y   ;store Q flag in private page
                jmp LACD2       ;load/save sideways RAM and exit.

LB5D7:
                jmp LB4AD       ;raise "Bad command" error

LB5DA:                          ;*SRWRITE
                lda #$C0        ;b7=1 load to SWRAM, b6=1 use pseudo-addressing
                bne LB5E0       ;enter routine with mode bits in A (always)

LB5DE:                          ;*SRREAD
                lda #$40        ;b7=0 save from SWRAM, b6=1 use pseudo-addressing
LB5E0:
                pha             ;save mode bits on stack
                bit LAF65       ;v=1 input 32-bit address
                jsr LB418       ;parse hexadecimal argument from command line
                bcs LB5D7       ;if argument invalid then raise "Bad command" error
                ldx #$03        ;else 4 bytes to copy:
LB5EB:
                lda L00BC,x     ;copy start address to workspace
                sta L00B1,x
                dex             ;loop until 4 bytes copied
                bpl LB5EB
                lda #$2B        ;set A="+"
                jsr LB479       ;compare A with non-space character of command line
                bcs LB5FA       ;v=1 still; if "+" present then next argument = size
                clv             ;so V=0 input 16-bit address:
LB5FA:
                jsr LB418       ;parse hexadecimal argument from command line
                bcs LB5D7       ;if argument invalid then raise "Bad command" error
                bvc LB61A       ;if +size argument given then skip
                .if SQUEEZE
                .else
                sec             ;(redundant)
                .endif
                ldx #$00        ;else end address argument given; start at LSB:
                sec
LB605:
                lda L00BC,x     ;get byte of end address
                sbc L00B1,x     ;subtract byte of start address
                sta L00BC,x     ;store byte of transfer size
                inx             ;increment offset
                txa             ;test for offset=4, preserving C
                and #$04
                beq LB605       ;loop until 4 bytes subtracted
                lda L00BC+$02   ;test high word of transfer size
                ora L00BC+$03
                beq LB61A       ;if 64 KiB or more to transfer
                jmp LAE35       ;then raise "Illegal address" error

LB61A:
                lda L00BC+$00   ;else copy transfer size to workspace
                sta L00B5+$00
                lda L00BC+$01
                sta L00B5+$01
                clv             ;v=0 input 16-bit address
                jsr LB418       ;parse hexadecimal argument from command line
                bcs LB5D7       ;if argument invalid then raise "Bad command" error
                jsr LB4B9       ;else parse bank specifier
                bcs LB633       ;if bank argument valid
                sta L00B7       ;then store bank number in workspace
                pla             ;and clear b6 of mode bits on stack
                and #$BF        ;b6=0 use absolute addressing
                pha
LB633:
                jsr LB477       ;test for end of command line
                bcs LB5D7       ;if more arguments then raise "Bad command" error
                pla             ;else store mode bits in workspace
                sta L00B0+$00
                jmp LB6C0       ;do SWRAM block transfer

LB63E:                          ;*SRDATA
                jsr LB4B9       ;parse bank specifier
LB641:
                bcs LB5D7       ;if argument invalid then raise "Bad command" error
                pha             ;else save bank number
                jsr LB477       ;test for end of command line
                bcs LB5D7       ;if more arguments then raise "Bad command" error
                pla             ;else restore bank number to Y
                tay
                jsr LB0CF       ;test pseudo-addressing of slot Y
                bne LB66B       ;if pseudo-addressing enabled then reserve and exit
                jsr LB356       ;else detect type of pseudo-addressed RAM in slot Y
                tax             ;if 0, other valid ROM
                bne LB65B
                ldx #$05        ;then error 5, "RAM occupied"
                jmp LB2CB       ;raise error by internal number

LB65B:
                sty L00BF       ;store bank number in temp
                lda LB0F7,y     ;look up RAM bitmap mask for slot Y
                ldy #srpsmp     ;set Y=$FD offset of pseudo-addressing bitmap
                ora (L00B8),y   ;set bit corresponding to bank Y
                sta (L00B8),y   ;update pseudo-addressing bitmap
                ldy L00BF       ;restore bank number
                jsr LB66F       ;write pseudo-addressing RAM header to bank Y
LB66B:
                jsr LB8D1       ;reserve paged ROM slot Y for RAM
                rts

LB66F:                          ;Write pseudo-addressing RAM header to bank Y
                ldx #$0F        ;maintain offset counter in X, 15..0
                stx L00BA+$00   ;set LSB write address for LB116
                lda #>lang      ;set A=page number of standard ROM header
                sta L00BA+$01   ;set MSB write address for LB116
LB677:
                lda LB253,x     ;get byte of pseudo-addressed RAM header
                cpx #$01        ;but if writing to $8001
                bne LB67F       ;then replace with bank's own number
                tya             ;to prevent MOS unplugging as a duplicate
LB67F:
                jsr LB116       ;write byte to sideways RAM
                dex             ;decrement offset counter
                stx L00BA+$00   ;update write address
                bpl LB677       ;loop until $8000..$800F written
                rts

LB688:                          ;*SRROM
                jsr LB4B9       ;parse bank specifier
                bcs LB641       ;if argument invalid then raise "Bad command" error
                pha             ;else save bank number
                jsr LB477       ;test for end of command line
                bcs LB641       ;if more arguments then raise "Bad command" error
                pla             ;else restore bank number to Y
                tay
                jsr LB0CF       ;test pseudo-addressing of slot Y
                beq LB6B9
LB69A:
                sty L00BC+$00   ;store bank number in temp
                jsr LB66F       ;write pseudo-addressing RAM header to bank Y
                lda #<(lang+$09+$01) ;(L00BA) = $8000; update write address to $800A
                sta L00BA+$00   ;= address of "A" in title string "RAM"
                lda #$4F        ;replace with "O" to make "ROM"
                jsr LB116       ;write byte to sideways RAM
                lda LB0F7,y     ;look up RAM bitmap mask for slot Y
                eor #$FF        ;invert mask
                ldy #srpsmp     ;set Y=$FD offset of pseudo-addressing bitmap
                and (L00B8),y   ;clear bit corresponding to bank Y
                sta (L00B8),y   ;update pseudo-addressing bitmap
                ldy L00BC+$00   ;restore bank number
                jsr LB8D1       ;reserve paged ROM slot Y for RAM
                rts

LB6B9:
                jsr LB356       ;detect type of pseudo-addressed RAM in slot Y
                tax             ;if not $00 = other valid ROM
                bne LB69A       ;then repeat rewriting title until it takes
                rts             ;else exit.

LB6C0:                          ;Do SWRAM block transfer
                lda L00B0+$00   ;get OSWORD mode bits/RAM bitmap
                and #$C0        ;mask mode bits
                sta L00BE+$00   ;store in workspace
                ldy #srwork+$00 ;XY+0 = OSWORD mode bits/RAM bitmap
                lda (L00B8),y   ;get RAM bitmap
                and #$3F        ;clear b7=load to SWRAM, b6=use pseudo-addressing
                ora L00BE+$00   ;apply mode bits generated by *command
                sta (L00B8),y   ;update mode bits/RAM bitmap
                bit L00B0+$00   ;test bit 6
                bvs LB6DD       ;if b6=0, using absolute addressing
                ldy L00B7       ;then get bank number in Y and test
                cpy #$14        ;if not a real slot number or remapped RAM bank no.
                bcc LB6E8
LB6DA:
                jmp LACF7       ;then raise "Illegal parameter" error.

LB6DD:
                ldx L00BC+$00   ;set XA = pseudo-address
                lda L00BC+$01
                jsr LB086       ;convert pseudo-address to absolute address
                stx L00BC+$00   ;replace pseudo-address with absolute address
                sta L00BC+$01
LB6E8:
                jsr LB0CF       ;test pseudo-addressing of slot Y
                pha             ;save result, $FF=pseudo $00=absolute
                tya
                ldy #srwork+$03 ;XY+3 = ROM ID
                sta (L00B8),y   ;store bank number in control block
                pla             ;restore pseudo-addressing status
                eor L00B0+$00   ;compare mode of SWRAM transfer command
                and #$40        ;mask result in b6
                bne LB6DA       ;if modes mismatch then raise "Illegal parameter"
                jsr LB8AC       ;else disable ROM slot if loading image
                jsr LB8A0       ;test presence of Tube coprocessor
                bcs LB722       ;if Tube absent
LB700:
                ldx #L00B5      ;then copy transfer size to control block
                ldy #L00BE
                jsr LAF66       ;copy zero page word (X) to (Y)
                rol L00B0+$00   ;test b7 of mode bits
                bcc LB715       ;if b7=1, loading to SWRAM
                .if SQUEEZE
                ldy #L00B3      ;then copy to target pointer
LB70F:
                ldx #L00BC      ;from SWRAM address
                .else
                ldx #L00BC      ;then copy SWRAM address
                ldy #L00B3      ;to target pointer
LB70F:
                .endif
                jsr LAF66       ;copy zero page word (X) to (Y)
                jmp LB199       ;transfer (L00BE) bytes to sideways RAM
                                ;can save 2 bytes; common LDX

LB715:                          ;else saving from sideways RAM
                ldx #L00B1      ;copy main memory address
                ldy #L00B3      ;to target pointer
                jsr LAF66       ;copy zero page word (X) to (Y)
                .if SQUEEZE
                .else
                ldx #L00BC      ;copy SWRAM address
                .endif
                ldy #L00B1      ;to source pointer
                bne LB70F       ;branch to transfer from SWRAM (always)

LB722:                          ;transferring with Tube present
                lda L00B1+$02   ;test high word of main memory address
                and L00B1+$03
                cmp #$FF        ;if high word = $FFFF
                beq LB700       ;then address in I/O proc., treat as no Tube
                lda L00BC+$00   ;else save SWRAM address
                pha
                lda L00BC+$01
                pha
                ldx #$03        ;4 bytes to copy:
LB732:
                lda L00B1,x     ;copy byte of main memory start address
                sta L00BA,x     ;to Tube transfer address
                dex             ;loop until 4 bytes copied
                bpl LB732
                ldx #L00B5      ;point X to transfer size
                ldy #srwork+$06 ;XY+6 = LSB of file length
                jsr LB21E       ;copy word from zero page to private page
                bit L00B0+$00   ;test mode bits
                bmi LB747       ;if b7=0 saving from SWRAM
                jmp LB7C8       ;then write from SWRAM to parasite

LB747:
                pla             ;else restore SWRAM address to target pointer:
                sta L00B3+$01
                pla
                sta L00B3+$00
LB74D:                          ;Read from parasite to SWRAM
                ldx #L00BE
                ldy #srwork+$06 ;XY+6 = LSB of file length
                jsr LB20F       ;copy word from private page to zero page
                lda L00BE+$01   ;test MSB of transfer size
                bne LB787       ;if >=256 bytes to transfer then branch
                ldx L00BE+$00   ;else load and test LSB of transfer size
                beq LB7C7       ;if transfer size = 0 then nothing to do, exit
                .if SQUEEZE
                .else
                lda #$00        ;(redundant)
                .endif
                sta (L00B8),y   ;else clear LSB of transfer size in OSWORD block
                inc L00B8+$01   ;point private page pointer to second page
                jsr LB88A       ;claim Tube for SRAM
                lda #$00        ;TUBADR $00 = bytes to host
                ldx #<L00BA     ;point XY to copy of transfer address
                ldy #>L00BA
                jsr tubadr      ;call TUBADR to set up data transfer
                ldy #$0B        ;wait 34 microseconds
                jsr LB898
                nop             ;wait 2 microseconds:
                nop
LB775:
                lda reg3        ;read from R3DATA
                sta (L00B8),y   ;store in I/O memory buffer
                ldx #$08        ;wait 26.5 microseconds
                jsr LB89C
                iny             ;increment buffer offset
                .char $CC       ;compare offset with LSB transfer size
                .word L00BE+$00 ;CPY     L00BE; +0.5 us with absolute addressing
                bne LB775       ;loop until done at 36 microseconds per byte
                beq LB7B1

;Note: Application note 004 specifies data transfer type 0 as requiring
;only 24 microseconds' delay on return from TUBADR, and 24 microseconds
;between R3DATA reads.

LB787:
                lda #$00        ;set transfer size = 256 bytes
                sta L00BE+$00
                lda #$01
                sta L00BE+$01
                inc L00B8+$01   ;point buffer pointer to second private page
                jsr LB88A       ;claim Tube for SRAM
                lda #$06        ;TUBADR $06 = page to host
                ldx #<L00BA     ;point XY to Tube transfer address
                ldy #>L00BA
                jsr tubadr      ;call TUBADR to set up data transfer
                ldy #$08        ;wait 26.5 microseconds
                jsr LB898
                nop             ;wait 2 microseconds:
                nop
LB7A4:
                lda reg3        ;read Tube FIFO 3
                sta (L00B8),y   ;store in buffer (5 us so far)
                jsr LB8AB       ;wait 6 microseconds
                lda $00         ;wait 1.5 microseconds (LDA zp)
                iny             ;increment and loop back
                bne LB7A4       ;taking 15 microseconds per byte
LB7B1:
                jsr LB892       ;release Tube from SRAM
                ldx #L00B8      ;copy buffer pointer as source address
                ldy #L00B1      ;at $00B1..2
                jsr LAF66       ;copy zero page word (X) to (Y)
                dec L00B8+$01   ;reset buffer pointer to first private page
                sec             ;c=1, writing to sideways RAM
                jsr LB199       ;transfer (L00BE) bytes to sideways RAM
                jsr LB856       ;add 256 to Tube transfer address
                jmp LB74D       ;and loop to read next page.

;Note: Data transfer type 6 requires only 19 microseconds' delay before the first
;transfer and 10 microseconds between transfers, per application note 004.

LB7C7:
                rts

LB7C8:                          ;Write from SWRAM to parasite
                pla             ;restore SWRAM address to source pointer:
                sta L00B1+$01
                pla
                sta L00B1+$00
LB7CE:
                ldx #L00BE
                ldy #srwork+$06 ;XY+6 = LSB of file length
                jsr LB20F       ;copy word from private page to zero page
                lda L00BE+$01   ;test MSB file length
                bne LB7E1       ;if >0 then write a page to parasite
                ldx L00BE+$00   ;else <256 bytes. test LSB
                .if SQUEEZE
                bne LB7EB       ;if >0 then A=$00, partial page to write
                rts             ;else nothing to do, exit

LB7E1:                          ;set transfer size = 256 bytes
                lda #$00
                sta L00BE+$00
                lda #$01
                sta L00BE+$01   ;A=$01, whole page to write:
LB7EB:
                pha             ;save transfer type
                inc L00B8+$01   ;point buffer pointer to second private page
                ldx #L00B8      ;copy buffer pointer to target address
                ldy #L00B3
                jsr LAF66       ;copy zero page word (X) to (Y)
                lda L00BE+$00   ;save LSB transfer size
                pha
                dec L00B8+$01   ;point buffer pointer to first private page
                clc             ;c=0, reading from sideways RAM
                jsr LB199       ;transfer (L00BE) bytes to sideways RAM
                pla             ;restore LSB transfer size
                sta L00BE+$00
                pla             ;restore transfer type
                bne LB82E       ;if A=$00, partial page transfer
                .else
                beq LB7C7       ;if 0 then nothing to do, exit
                lda #$01        ;else A=$01, partial page to write
                bne LB7EB       ;branch into loop (always)
                                ;can save 2 bytes: keep A=0 and reverse sense

LB7E1:                          ;set transfer size = 256 bytes
                lda #$00
                sta L00BE+$00
                lda #$01
                sta L00BE+$01
                lda #$07        ;A<>$01, whole page to write:
LB7EB:
                pha             ;save transfer type
                inc L00B8+$01   ;point buffer pointer to second private page
                ldx #L00B8      ;copy buffer pointer to target address
                ldy #L00B3
                jsr LAF66       ;copy zero page word (X) to (Y)
                lda L00BE+$00   ;save LSB transfer size
                pha
                dec L00B8+$01   ;point buffer pointer to first private page
                clc             ;c=0, reading from sideways RAM
                jsr LB199       ;transfer (L00BE) bytes to sideways RAM
                pla             ;restore LSB transfer size
                sta L00BE+$00
                pla             ;restore transfer type
                cmp #$01        ;if A=$01, partial page transfer
                bne LB82E
                lda #$00
                .endif
                ldy #srwork+$06 ;then XY+6 = LSB of file length
                sta (L00B8),y   ;set file length to zero (MSB = $00)
                inc L00B8+$01   ;point buffer pointer to second private page
                jsr LB88A       ;claim Tube for SRAM
                lda #$01        ;TUBADR $01 = bytes from host
                ldx #<L00BA     ;point XY to Tube transfer address
                ldy #>L00BA
                jsr tubadr      ;call Tube service to set up data transfer
                ldy #$00
LB81C:
                lda (L00B8),y   ;get byte from buffer
                sta reg3        ;store in Tube FIFO 3 (4.5 us so far)
                ldx #$08        ;wait 26.5 microseconds
                jsr LB89C
                nop             ;wait 1 microsecond
                iny             ;increment offset
                cpy L00BE+$00   ;test if end of buffer reached
                bne LB81C       ;if not then loop (36 us per byte)
                beq LB84B       ;else release Tube and loop for next page.

;Note: byte transfer interval again too long (vs 24 us per byte for type 1.)

LB82E:
                inc L00B8+$01   ;point buffer pointer to second private page
                jsr LB88A       ;claim Tube for SRAM
                lda #$07        ;TUBADR $07 = page from host
                ldx #<L00BA     ;point XY to Tube transfer address
                ldy #>L00BA
                jsr tubadr      ;call Tube service to set up data transfer
                ldy #$00        ;point Y to start of buffer:
LB83E:
                lda (L00B8),y   ;get byte from buffer
                sta reg3        ;store in Tube FIFO 3 (4.5 us so far)
                ldx #$03        ;wait 8 microseconds
LB845:
                dex
                bne LB845
                iny             ;increment offset
                bne LB83E       ;loop until 256 bytes sent (15 us per byte)
LB84B:
                jsr LB892       ;release Tube from SRAM
                dec L00B8+$01
                jsr LB856       ;add 256 to Tube transfer address
                jmp LB7CE       ;and loop to write next page.

;Note: transfer type 7 specifies down to 10 microseconds per byte.

LB856:                          ;Add 256 to Tube transfer address
                ldx #$01        ;point X to 3MSB
                .if BUGFIX
LB858:
                .endif
                inc L00BA,x     ;add 1 * 256 to address
                bne LB861       ;if overflow
                inx             ;then point X to 64 KiB place (redundant)
                cpx #$04        ;loop back (always) and add 256 again
                .if BUGFIX
                bcc LB858       ;increment 2MSB or MSB
                .else
                bcc LB856       ;[BUG] should be B858
                .endif

LB861:
                ldy #srwork+$07 ;XY+7 = MSB of file length
                lda (L00B8),y   ;subtract 256 from file length
                sec
                sbc #$01
                bcc LB889       ;if borrow then file finished, exit
                sta (L00B8),y   ;else update MSB of file length
                jsr LAFFB       ;test number of bytes to be saved
                beq LB889       ;if none remaining then exit
                ldx L00B7       ;else get offset, 1=read 3=write
                jsr LB22B       ;test OSWORD mode bits
                bvc LB889       ;if b6=0, absolute addressing then exit
                lda L00B1-$01+$01,x ;else get MSB SWRAM address (src/dest)
                cmp #$C0        ;if less than $C0
                bcc LB889       ;then within bank, exit
                lda #<(LB263-LB253+lang) ;else reset SWRAM address to $8010
                sta L00B1-$01,x
                lda #>(LB263-LB253+lang)
                sta L00B1,x
                jsr LB070       ;and increment sideways RAM slot number.
LB889:
                rts

LB88A:                          ;Claim Tube for SRAM
                lda #$C0+srtbid ;tube service call = $C0 + ID for SRAM (8)
                jsr tubadr      ;call Tube service
                bcc LB88A       ;loop until C=1, indicating claim granted
                rts

LB892:                          ;Release Tube from SRAM
                lda #$80+srtbid ;tube service call = $80 + ID for SRAM (8)
                jsr tubadr      ;call Tube service
                rts

LB898:                          ;Wait 2.5 * Y + 5.5 microseconds
                dey             ;(including JSR and RTS)
                bne LB898       ;add 1 us for the preceding LDY #imm
                rts

LB89C:                          ;Wait 2.5 * X + 5.5 microseconds
                dex             ;(including JSR and RTS)
                bne LB89C       ;add 1 us for the preceding LDX #imm
                rts

LB8A0:                          ;Test presence of Tube coprocessor
                lda #$EA        ;OSBYTE $EA = read Tube presence flag
                ldx #$00        ;$00 = don't alter variable
                ldy #$FF        ;$FF = don't update variable
                jsr osbyte      ;call OSBYTE
                cpx #$FF        ;return Z=1, C=1 iff Tube present
LB8AB:
                rts

LB8AC:                          ;Disable ROM slot if loading image
                jsr LB22B       ;test OSWORD mode bits
                bpl LB8D0       ;exit unless b7=1, load to sideways RAM
                bvs LB8D0       ;exit unless b6=0, absolute addressing
                lda #$00        ;a=$00, slot vacant, no access until validated
                pha             ;push on stack
                ldy #srwork+$03 ;XY+3 = ROM ID
                lda (L00B8),y   ;get paged ROM slot number from OSWORD wksp:
LB8BA:                          ;Update ROM type byte
                pha             ;new value on stack, A=ROM slot number, save
                lda #$AA        ;OSBYTE $AA = read address of ROM type table
                ldx #$00        ;x=$00 do not alter value
                ldy #$FF        ;y=$FF do not update value
                jsr osbyte      ;call OSBYTE
                jsr LB1FB       ;set up pointer to private page
                stx L00BA+$00   ;set up pointer to ROM table
                sty L00BA+$01
                pla             ;restore ROM slot number to Y
                tay             ;for use as offset
                pla             ;restore new type byte
                sta (L00BA),y   ;store in table
LB8D0:
                rts

LB8D1:                          ;Reserve paged ROM slot Y for RAM
                lda #$02        ;type byte=$02, 6502 format,
                pha             ;no language, no service
                tya             ;push on stack for LB8BA
                bpl LB8BA       ;slot number in A, branch (always)

                .if FASTGB
                jmp LAE35       ;raise "Illegal address" error

fastgb:
                jsr makatp      ;set up pointer to user's OSGBPB block
                lda wbrwtb,y    ;get microcode byte from table
                and #$03        ;test bit 1 = transfer data
                lsr a           ;set C=1 iff preserving PTR
                beq chain       ;if not a transfer then pass call downstream
                sty acc         ;else save call number
                ldy #$0C        ;13 bytes to copy, $0C..$00:
copyl0:
                lda (atemp),y   ;copy user's OSGBPB block
                sta dosram,y    ;to workspace
                dey             ;loop until 13 bytes copied
                bpl copyl0
                tay             ;file handle to Y
                ldx #$03        ;4 bytes to copy, $03..$00:
initl:
                lda dosram+$05,x ;copy L in OSGBPB block
                sta ltemp0,x    ;to working L
                dex             ;loop until 4 bytes copied
                bpl initl
                lda dosram+$09  ;get LSB of P, initial PTR to use for transfer
                bcc dcptr       ;if calls 1 or 3 then use P; else 2 or 4 use current PTR
                tya             ;convert file handle to workspace pointer
                jsr lfive       ;(file handle validated later)
                tay             ;to Y as offset
                lda seqpl,y     ;get LSB of file pointer PTR
                clc             ;clear carry flag for two's complement
dcptr:
                eor #$FF        ;take two's complement
                adc #$01        ;=no. bytes from start of transfer to a page boundary
                ldy #$FC        ;reverse counter, 4 bytes to set:
hdrext:                         ;do header/extender OSGBPB call
                sta dosram+$05-$FC,y ;replace L field with number of bytes to move
                lda #$00        ;set MSB,2MSB,(3MSB) of user's L to zero
                iny             ;increment offset
                bne hdrext      ;loop until 3 (4) bytes of L replaced
                jsr subwk       ;subtract L from working L
                bcc trailr      ;if underflow then within one sector, do trailer call
                bne align       ;else if remaining working L >= 256 then enter loop
trailr:                         ;else combine header/extender with trailer:
                jsr addtol      ;add working L to L
drain:
                lda #<dosram    ;point to OSGBPB block in workspace
                sta atemp+$00   ;-read user's block once
                lda #>dosram    ;upgbpb will write it back once
                sta atemp+$01
                ldy acc         ;restore call number
chain:
                jmp upgbpb      ;and pass call downstream

morfst:                         ;done a fast transfer, user's L = $00xxxx00
                lda ltemp0+$03  ;get MSB of working L
                jsr testl       ;test MSB, 2MSB, 3MSB of working L
                bne dofast      ;if >= 256 then try another fast transfer
                sta dosram+$06  ;else set user's L = 0
                sta dosram+$07
                lda ltemp0+$00  ;if 0 < working L < 256
                bne trailr      ;then do trailer call with L = working L
                clc             ;else C=0, no bytes remaining:
fgbfin:                         ;working L reached zero or something went wrong:
                php             ;save carry flag that says which
                jsr addtol      ;add remaining request to bytes not transferred
                plp             ;restore carry flag returned from OSGBPB call
                jsr makatp      ;set up pointer to user's OSGBPB block
                ldy #$0C        ;copy 13 bytes of OSGBPB control block
retnl:
                lda dosram,y    ;from DFS workspace
                sta (atemp),y   ;to user's address
                dey             ;loop until 13 bytes copied
                bpl retnl
                rts             ;return C=0 OSGBPB succeeded/C=1 OSGBPB failed

setmax:                         ;set fast transfer request = maximum transfer size
                sta dosram+$07  ;set MSB request = MSB maximum
                ora dosram+$06
                bne sectr1      ;if maximum > 0 then transfer sectors
throw:                          ;working L >= 256, L = $00xxxx00, maximum = 0
                ldy #$FD        ;set user's L = 256
                lda #$01
                bne hdrext      ;do extender OSGBPB call to extend file (always)

align:
                jsr drain       ;call OSGBPB on workspace control block.
                                ;this validates the file handle, sets PTR from P,
                                ;aligns it to a sector boundary, and sets L=0
                bcs fgbfin      ;return if call failed else continue transfer
dofast:                         ;working L >= 256, L = $00xxxx00, PTR on sector bdy
                ldx ltemp0+$03  ;test working L - are there 16 MiB or more to move?
                beq sclamp      ;if not then move 1..65535 sectors
                ldx #$FF        ;else transfer first 65535 sectors of remainder
sclamp:
                txa
                ora ltemp0+$02
                sta dosram+$07  ;set MSB of transfer length = 2MSB of L
                txa
                ora ltemp0+$01
                tax             ;hold LSB of transfer length in X
                lda dcby        ;get channel workspace offset
                sec
                adc acc         ;add 1+call number, 2..5 to workspace offset
                eor #$04        ;bit 2 = 1 if writing
                and #$E4        ;if writing then point to allocation instead of EXT
                tay
                lda seqlma,y    ;get 2MSB of channel EXT
                sec
                sbc dosram+$0A  ;subtract 2MSB of PTR
                sta dosram+$06  ;=LSB maximum transfer size
                lda seqlha,y    ;get MSB of EXT
                sbc dosram+$0B  ;subtract MSB of PTR = MSB maximum
                bcc throw       ;if maximum<0 throw back
                cmp dosram+$07  ;else compare MSB maximum - MSB request
                bcc setmax      ;if maximum < request then request = maximum
                bne sectr0      ;if maximum > request then transfer sectors
                cpx dosram+$06  ;else compare LSB request - LSB maximum
                bcs setmax      ;if request >= maximum then request = maximum
sectr0:                         ;transfer one or more sectors.
                stx dosram+$06  ;x=request, hold in 3MSB of L
sectr1:
                ldy dcby        ;undo EXT/allocation fudge
                jsr vlook       ;ensure open file still in drive
                jsr bflush      ;ensure buffer up-to-date on disc L6
                lda #$3F        ;b7=0 buffer does not contain PTR, b6=0 buffer not changed
                sta seqdah,y    ;set buffer LBA out of range to force re-reading
                jsr clrbit      ;clear b7,b6 of channel flags
                lda dosram+$01  ;copy OSGBPB transfer address
                sta lodlo       ;to load address in OSFILE block
                lda dosram+$02
                sta lodhi
                lda dosram+$03
                sta ldlow+$02
                lda dosram+$04
                sta ldlow+$03
                lda seqloc,y    ;get LSB LBA of start of open file
                clc
                adc dosram+$0A  ;add 2MSB of PTR
                sta lbalo       ;store LSB target LBA in OSFILE block
                lda seqlh,y     ;get MSB LBA
                adc dosram+$0B  ;add MSB of PTR
                and #$03        ;mask MSB of target LBA
                sta lbahi       ;store MSB target LBA in OSFILE block
                lda #$00        ;clear LSB file length in OSFILE block
                sta lenlo
                lda dosram+$06  ;copy transfer length
                sta lenhi       ;to file length in OSFILE block
                lda dosram+$07  ;get MSB transfer length
                jsr lfour       ;shift b1..b0 to b5..b4
                ora lbahi       ;combine with LSB target LBA
                sta wrkcat+$06  ;pack into last byte of OSFILE block
                ldx acc         ;(L8826 needs load+exec unpacked, but length packed)
                lda cmdtbl-$01,x ;1770 command $A0 to write or $80 to read
                inc seqsem      ;set *SPOOL/*EXEC critical flag (now $00)
                jsr L8826       ;transfer ordinary file L5
                dec seqsem      ;clear *SPOOL/*EXEC critical flag (now $FF)
                jsr subwk       ;subtract amount transferred from working L
                ldy dosram+$06  ;get and hold LSB number of sectors transferred
                tya
                clc             ;add to OSGBPB address field
                adc dosram+$02
                sta dosram+$02
                ldx dosram+$07  ;get and hold MSB number of sectors transferred
                txa
                adc dosram+$03  ;add to OSGBPB address field
                sta dosram+$03
                bcc updp        ;carry out to high byte
                inc dosram+$04
updp:
                tya             ;set A=LSB transfer size in sectors
                ldy dcby        ;set Y=channel workspace offset
                clc             ;add to open file's pointer
                adc seqpm,y
                sta seqpm,y     ;update PTR
                sta dosram+$0A  ;update OSGBPB control block in workspace
                txa             ;add MSB transfer size to MSB PTR
                adc seqph,y
                sta seqph,y
                sta dosram+$0B  ;(MSB OSGBPB P field cleared by upgbpb)
                tya
                jsr pcmp        ;compare PTR - EXT
                bcc doneit      ;if file not extended then loop
                beq doneit      ;if PTR = EXT, at EOF then loop
                                ;else PTR > EXT only possible if writing
                jsr updext      ;clamp PTR to 0..EXT by raising EXT
doneit:
                jmp morfst      ;loop to transfer more sectors

subwk:                          ;Subtract L from working L
                sec             ;set carry flag for subtract
                ldx #$FC        ;reverse counter, 4 bytes to subtract
subwkl:
                lda ltemp0-$FC,x ;get byte of working L
                sbc dosram+$05-$FC,x ;subtract byte of L in OSGBPB block
                sta ltemp0-$FC,x ;update byte of working L
                inx             ;loop until 4 bytes updated:
                bne subwkl
testl:                          ;Test whether working L >= 256
                ora ltemp0+$02  ;a=MSB, OR with 2MSB
                ora ltemp0+$01  ;or with 3MSB
                rts             ;return Z=1 iff working L < 256

addtol:                         ;add working L to L in OSGBPB block
                clc             ;clear carry flag for add
                ldx #$FC        ;reverse counter, 4 bytes to add:
addl:
                lda ltemp0-$FC,x ;get byte of working L
                adc dosram+$05-$FC,x ;add to byte of L in OSGBPB block
                sta dosram+$05-$FC,x ;update byte of L
                inx             ;loop until 4 bytes added
                bne addl
                rts

cmdtbl:
                .char $A0       ;OSGBPB 1=write data setting PTR
                .char $A0       ;OSGBPB 2=write data ignoring PTR
                .char $80       ;OSGBPB 3=read data setting PTR
                .char $80       ;OSGBPB 4=read data ignoring PTR

                .endif

                .if BUGFIX
*=$BFFF
                .char $00
                .elif NMOS
*=$BFFF
                .char $00
                .elif FASTGB
*=$BFFF
                .char $00
                .elif SQUEEZE
*=$BFFF
                .char $00
                .else
;Padding
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1,-1,-1,-1,-1,-1,-1
                .dint -1,-1
                .char -1
                .endif

end:


;This Perl script strips unused conditional assembly paths
;from this listing.
;Copy the text between the cut lines.
;Paste it into a new file, beebasmpp.pl, and remove the column of ;
;Then call it with
;  perl beebasmpp.pl -o dfs224-stripped.asm.txt dfs224.asm.txt
;  perl beebasmpp.pl -o dfs224-allpatches.asm.txt \
;    -D_BUGFIX -D_FASTGB -D_NMOS -D_TURBO -D_SQUEEZE dfs224.asm.txt
;-------->8---
;#!/usr/bin/perl
;
;#Usage: perl beebasmpp.pl
;#       {-D SYMBOL[=VALUE]} [-l] [-v] -o OUTFILE [FILE...]
;
;use Getopt::Std;
;use IO::Seekable qw(SEEK_SET SEEK_CUR SEEK_END);
;
;@x=(2); @t[6,7]=(2,4);
;
;for($i=0;$i<@ARGV && ($arg = $ARGV[$i]) ne '--'; ++$i) {
;  if(substr($arg,0,2) eq '-D') {
;    if(($dfn=substr($arg,2)) eq '') {
;      $dfn = $ARGV[++$i];
;    }
;    if(($x=index($dfn,'=')) > 0) {
;      $symbol{substr($dfn,0,$x)} = substr($dfn,$x+1);
;    } elsif($dfn ne '') {
;      $symbol{$dfn} = 1;
;    }
;  }
;}
;
;getopts("D:Edlo:v");
;die "No output file specified" if $opt_o eq '';
;$opt_b = hex($opt_b);$l=$opt_l ? "\n" : '';
;
;open(BIN,"+>$opt_o") or die;
;while(<>) {
;  y/\n\r//d;
;  if($opt_v || /^\s*(?:IF|ELIF|ELSE|ENDIF)/i) {
;    while(($key, $value) = each %symbol) {
;      $x=0;
;      while(($x = index($_,$key,$x)) >= 0) {
;        substr($_,$x,length($key),$value);
;        $x+=length($value);
;      }
;    }
;  }
;  if(/^\s*((?:EL)?)IF\s+NOT\s+(\S*)\s*$/i) {
;    unshift@x,4 if$1 eq'';
;    $x[0]=$t[$x[0]|$x[1]&2|($2 !=0)];$_=$l;
;  }elsif(/^\s*((?:EL)?)IF\s+(\S*)\s*$/i) {
;    unshift@x,4 if$1 eq'';
;    $x[0]=$t[$x[0]|$x[1]&2|($2 ==0)];$_=$l;
;  }elsif(/^\s*ELSE(?!\S)/i) {
;    $x[0]=$t[$x[0]|$x[1]&2];$_=$l;
;  }elsif(/^\s*ENDIF(?!\S)/i) {
;    shift@x;@x=(2)unless@x;$_=$l;
;  }elsif($x[0] & 2 && /^\s*(\S+)\s*=\?\s*(\S+)/) {
;    $symbol{$1}=$2 unless defined($symbol{$1});$_.="\n";
;  }elsif($x[0] & 2 && /^\s*(\S+)\s*=\s*(\S+)/) {
;    $symbol{$1}=$2;$_.="\n";
;  }else{
;    $_.="\n";
;  }
;  print BIN ($x[0] & 2 ? $_ : $l);
;}
;close(BIN);
;-------->8---

;End of dfs224.asm.txt
